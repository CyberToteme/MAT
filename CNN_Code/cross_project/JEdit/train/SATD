"/*			Implement String += value;			According to the JLS, value may be anything.			In BeanShell, we'll disallow VOID (undefined) values.			(or should we map them to the empty string?)		*/"
/* this should be before dockables are initialized */
// is this right?
// should we do this for both cases above?
// need to loosen this to any throwable... do we need to handle // that in interpreter somewhere?  check first...
// fucking GTK look and feel
"/*		Note: this implementation is temporary. We currently keep a flat		namespace of the base name of classes.  i.e. BeanShell cannot be in the		process of defining two classes in different packages with the same		base name.  To remove this limitation requires that we work through		namespace imports in an analogous (or using the same path) as regular		class import resolution.  This workaround should handle most cases 		so we'll try it for now.	*/"
// copy and paste from bsh/classpath/ClassManagerImpl.java...
// I wish I could make this "friendly" to only NameSpace
// undocumented hack to allow browser actions to work. // XXX - clean up in 4.3
// Look for a default invoke() handler method in the namespace // Note: this code duplicates that in NameSpace getCommand() // is that ok?
// This should be per instance
// Can we use the proxy mechanism to cast a bsh.This to  // the correct interface?
// redundant with constructor
"/*		Issues to resolve here...		1) In which classloader should we define the class?		if there is a BshClassLoader should we define it there?		2) should we use reflection to set it in a non-bsh classloader		if there is one or should we always create a bsh classloader		(and expose its defineClass)?	*/"
// could refactor these a bit
"/*	Note: This class essentially just delegates most of its main.methods to its	parent.  The setVariable() indirection is very small.  We could probably	fold this functionality back into the base NameSpace as a special case.	But this has changed a few times so I'd like to leave this abstraction for	now.*/"
// simplified these settings a little...
"/*		Should check for strict java here and use isJavaAssignable() instead	*/"
// workaround for Swing rendering labels starting // with <html> using the HTML engine
// Look for a default invoke() handler method in the namespace // Note: this code duplicates that in This.java... should it? // Call on 'This' can never be a command
// this method is a nightmare
// ConsoleInterface // The interpreter reflexively implements the console interface that it  // uses.  Should clean this up by using an inner class to implement the // console for us.
// Case-insensitive fs workaround
"/*			Wrap nulls.			This is a bit of a cludge to address a deficiency in the class			generator whereby it does not wrap nulls on method delegate.  See			Class Generator.java.  If we fix that then we can remove this.			(just have to generate the code there.)		*/"
// switch eats a multi-level break here? // not empty statement
// Check for field on object  // Note: could eliminate throwing the exception somehow
// XXXX re-evaluate this // can getSuper work by itself now? // If we're a class instance and the parent is also a class instance // then super means our parent.
"/*		I wish protected access were limited to children and not also 		package scope... I want this to be a singleton implemented by various		children.  	*/"
// Imported full name wasn't found as an absolute class // If it is compound, try to resolve to an inner class.   // (maybe this should happen in the BshClassManager?)
"/*	Can't this be combined with run() ?	run seems to have stuff in it for interactive vs. non-interactive...	compare them side by side and see what they do differently, aside from the	exception handling.	*/"
// Null value is just a declaration // Note: we might want to keep any existing value here instead of reset
// Can this be factored out...?   // Should be be adding the L...; here instead?
"/* 							Catch the mismatch and continue to try the next							Note: this is innefficient, should have an 							isAssignableFrom() that doesn't throw 						*/"
// should use try/finally here to pop ns
"/*			Note: this could be made clearer by adding an inner class for the			cases and an object context for the child traversal.		*/"
// hack... sticking to first interpreter that resolves this // see comments on type instance variable
// Note: incorrect here - we are using the hack in bsh class // manager that allows lookup by base name.  We need to eliminate // this limitation by working through imports.  See notes in class // manager.
"/* 		This is the namespace in which the method is set.		It is a back-reference for the node, which needs to execute under this 		namespace.  It is not necessary to declare this transient, because 		we can only be saved as part of our namespace anyway... (currently).	*/"
// Replace this is Cocoa API calls later
// Scripting classes currently requires accessibility // This can be eliminated with a bit more work.
// This could be static
"/*	Thanks to Slava Pestov (of jEdit fame) for import caching enhancements.	Note: This class has gotten too big.  It should be broken down a bit.*/"
"/**    * Register an attribute declaration for later retrieval.    * Format:    * - String type    * - String default value    * - int value type    * *TODO: do something with attribute types.    */"
"/*				TODO:					to get cast and boxing working e.g.					e.g. Byte [] ia = { 1, 2 }					If the baseType is a wrapper type then we need to get the 					primitive TYPE class for the base type here in order for 					the cast to allow it... Then boxing will happen naturally in					the Array.set().					e.g. Integer [] ia = { 1, 2 }				*/"
"/*		Note: We will ll move this behavior out to a subclass of 		NameSpace, but we'll start here.	*/"
// This is a particularly nasty bit // of code, that checks for a parameter // entity reference but peeks ahead to // catch the '%' in parameter entity // declarations.
// Should cache this subject to classloader change message // Evaluation of the formal parameter simply resolves its // type via the specified namespace.. it doesn't modify the // namespace.
"/*	Notes:	It would not be hard to eliminate the use of org.objectweb.asm.Type from	this class, making the distribution a tiny bit smaller.*/"
// stupid: caret will automatically be incremented
/* Spacing workaround */
// I don't know of any other way to fix this, since invoking this // command from a menu results in the focus owner being the menu // until the menu goes away.
// a little hack for reverse replace and find
// Static main.methods that operate on compound ('.' separated) names // I guess we could move these to StringUtil someday
"/*	Note: which of these things should be checked at parse time vs. run time?*/"
// this part sucks
// Windows bug workaround in case a YES/NO confirm // was shown
// clear name resolvers... don't know if this is necessary.
"/* this is stupid and misleading.					 * but 'path' is not used anywhere except					 * the above line, and if this is done					 * after the 'continue', then we will					 * either hang, or be forced to duplicate					 * it inside the buffer == null, or add					 * a 'finally' clause. you decide which one's					 * worse. */"
// I'm too tired to think of a better way // to handle this right now.
// hacked BufferIORequest to send VFSUpdates in case // two stage save is off now...
// some other primitive // should avoid calling main.methods on primitive, as we do // in Name (can't treat primitive like an object message) // but the hole is useful right now.
// Change the parent (which was the class static) to the class instance // We really need to check if we're a static inner class here first... // but for some reason Java won't show the static modifier on our // fake inner classes...  could generate a flag field.
// this is where checked exceptions piss me off. this method only uses // a StringReader which can never throw an exception...
// If any subexpressions didn't terminate, they don't count // TODO check if this code ever gets hit
// Parse pattern into tokens.  Does anyone know if it's more efficient // to use char[] than a String.charAt()?  I'm assuming so.
"/*		Note: object is only used here for precondition... get rid of it?	*/"
// Why both of these?
// Cut off from parent, we must have our own class manager. // Can't do this in the run() command (needs to resolve stuff) // Should we do it by default when we create a namespace will no // parent of class manager?
"/*		Note: the bsh command code should probably not be here...  we need to		scope it by the namespace that imported the command... so it probably		needs to be integrated into NameSpace.	*/"
// This could be smarter...
// It was explicitly imported, but we don't know what it is. // should we throw an error here??
"/*		Note: we need a form of eval that passes the callstack through...	*/"
"/* 		Primary interpreter set and get variable main.methods		Note: These are squeltching errors... should they?	*/"
// Workaround for JDK bug 4071281, where system.in.available()  // returns too large a value. This bug has been fixed in JDK 1.2.
"/*				Somewhat of a hack.  If the special fields are visible (we're				operating relative to a 'this' type already) dissallow further				.this references to prevent user from skipping to things like				super.this.caller			*/"
// Should clean this up to a single return statement
"/*	Implementation notes:	Note: we may need some synchronization in here	Note on version dependency:  This base class is JDK 1.1 compatible,	however we are forced to use weak references in the full featured	implementation (the optional bsh.classpath package) to accomodate all of	the fleeting namespace listeners as they fall out of scope.  (NameSpaces	must be informed if the class space changes so that they can un-cache	names).  	<p>	Perhaps a simpler idea would be to have entities that reference cached	types always perform a light weight check with a counter / reference	value and use that to detect changes in the namespace.  This puts the 	burden on the consumer to check at appropriate times, but could eliminate	the need for the listener system in many places and the necessity of weak 	references in this package.	<p>*/"
"/*		Note: this impor pattern is becoming common... could factor it out into		an importedObject Vector class.	*/"
// not sure if we should really recurse here for explicitly imported // class in parent...  
// The following two boolean checks were tacked on. // This could probably be smoothed out.
"/*		Notes:		This is broken.  It finds public but less specific main.methods over		non-public but more specific ones.		findMostSpecficMethod() needs to be rewritten to eliminate 		findAccessibleMethod.  We should implement the findMostSpecificMethod 		that uses the publicOnly flag.  FindMostSpecificMethod should also		operate in two passes to give standard Java assignable matches priority		over extended bsh type matches.	*/"
//{{{ UnixWorkaround constructor
// drag and drop support // I'd just move the code to // JEditTextArea but it // depends on JDK 1.4 APIs
// next version: remove this
// compatibility kludge for jEdit 3.1 and earlier
// stupid scrollbar policy is an attempt to work around // bugs people have been seeing with IBM's JDK -- 7 Sep 2000
// this is a weird hack. // we don't want C+e a to insert 'a' in the // search bar if the search bar has focus...
// AHA! // this is probably the only way to fix this
// this is a dirty hack and it relies on the fact // that updates for parents are sent before updates // for the changed nodes themselves (if this was not // the case, the browser wouldn't be updated properly // on delete, etc). // // to avoid causing '> 1 request' errors, don't reload // directory if request already active
// we consume this to work around the bug // where A+TAB window switching activates // the menu bar on Windows.
"/* I guess translated events do not have the 'evt' field set		so consuming won't work. I don't think this is a problem as		nothing uses translation anyway */"
// this is a hack, and really needs to be done better.
// copy and paste from RESyntaxMatcher to make syntax package // independent of jEdit itself
// stupidity
// This doesn't seem very correct, but it fixes a problem // when setting the initial caret position for a buffer // (eg, from the recent file list)
// don't try this at home
"/* silly that we reference the vertical				   scroll bar here directly. we do this so				   that the horizontal scroll bar is flush				   with the vertical scroll bar */"
// XXX clean up this conditional
// Temporary hack to support inner classes  // If the obj is a non-static inner class then import the context... // This is not a sufficient emulation of inner classes. // Replace this later...
// workaround for Swing's annoying processing of // labels starting with <html>, which often breaks
// fucking GTK look and feel!
// hack so that 'select all' does not change current buffer
"/* if an occurence occurs at the		beginning of the selection, the		selection start will get moved.		this sucks, so we hack to avoid it. */"
"/* Silly bug workaround #8694. If you look at the above code,		 * note that we restore the saved caret position first, then		 * scroll to the saved location. However, the caret changing		 * can itself result in scrolling to a different location than		 * what was saved; and since moveCaretPosition() calls		 * updateBracketHighlight(), the bracket highlight's out of		 * bounds calculation will rely on a different set of physical		 * first/last lines than what we will end up with eventually.		 * Instead of confusing the user with status messages that		 * appear at random when switching buffers, we simply hide the		 * message altogether. */"
"/* this is a sloppy hack to fix bug				   ""[ 677902 ] hitting return after collapsed				   fold""				   the idea is that if we extend the range then				   the problem described in the bug happends, so				   if the insert is at the very end of the range				   we don't extend it, instead we push the				   insert into the next range, however for this				   to work properly we also have to mess with				   screen line counts. */"
// need this bullshit scroll bar policy for the preferred size // hack to work
// XXX if we keep the createClassManager in getClassManager then we can axe // this?
"/*	Note: This class is messy.  The method and field resolution need to be	rewritten.  Various main.methods in here catch NoSuchMethod or NoSuchField	exceptions during their searches.  These should be rewritten to avoid	having to catch the exceptions.  Method lookups are now cached at a high 	level so they are less important, however the logic is messy.*/"
// the sooner ppl move to the new api, the less we'll need // crap like this
// Nasty hardcoded values
/* XXX magic number */
/* Workaround for uncooperative Windows L&F */
// have to do this hack until VFSPath class is written
// stupid Swing
// none of the others are ever meant to be // removed. retarded, eh? this needs to be // fixed eventually, for plugins might // want to do weird stuff to jEdit's UI
// this is retarded. excuse me while I drool // and make stupid noises
// retarded GTK look and feel!
// should probably error
// there must be a better way of fixing this... // the problem is that this method can sometimes // be called as a result of a text area scroll // event, in which case the caret position has // not been updated yet.
// Perhaps here we would want to guard with // a property for parallel backups or not.
// this is such a bad way of doing it, but oh well...
// while this might be questionable, some // menus depend on properties
// Get available screens // O(n^3), this is nasty, but since we aren't dealling with // many items it should be fine
//{{{ Methods that really shouldn't be public...
//{{{ UnixWorkaround class
// Perhaps if Xerces wasn't slightly brain-damaged, we would // not need this
// moved to GUIUtilities as it makes no sense being here.
// Hack... need a more direct way of obtaining a view? // JEditTextArea.getView() method?
// REVIEW How do we resolve this discrepancy?!
// ugly workaround
//{{{ Windows work around
// hack since HelpViewer needs a URL...
// Why is object in the args?
// should implement getMinimumLength() -- any ideas?
// Move me to classpath/ClassManagerImpl???
// they never taught you this in undergrad computer science
// (should we cache info in not a class case too?)
// wtf?
"/*	 *  XXX: hairy code that is basically just a functional(?) port of some	 *  other code i barely understood	 */"
"/*			First try for an accessible version of the exact match.			This first lookup seems redundant with below, but is apparently			needed.  This whole thing is messy.		*/"
// work around for broken FTP plugin!
// hack to move the spaces to the front
// This feels sloppy, especially for non-U.S. locales.
// hack to get fixed length 'length' field
// // We have to deal with assembly!!! // The programmer can be writing little 32 byte chunks for all // we know, and we must assemble complete records for writing. // REVIEW Maybe this should be in TarBuffer? Could that help to //        eliminate some of the buffer copying. //
// Hack done to fix bringing the window to the front. // At least on windows, Frame.toFront() doesn't cut it. // Remove the isWindows check if it's broken under other // OSes too.
"/*		This method should be rewritten to use getFields() and avoid catching		exceptions during the search.	*/"
// hack...
// This should probably be in Reflect.java
"/*		Notes: See notes on findMostSpecificMethod.		This method should be rolled into findMostSpecificMethod.	*/"
"/*		Note: is using SignatureKey in this way dangerous?  In the pathological		case a user could eat up memory caching every possible combination of		argument types to an untyped method.  Maybe we could be smarter about		it by ignoring the types of untyped parameter positions?  The method		resolver could return a set of ""hints"" for the signature key caching?		There is also the overhead of creating one of these for every method		dispatched.  What is the alternative?	*/"
// crusty workaround
"/* workaround for A+keys producing				 * garbage on Windows */"
"/* addToFavorites(), which is a static method		 * (for convinience) needs an instance of the		 * VFS to pass to VFSManager.sendVFSUpdate(),		 * hence this hack. */"
// Allow getThis() to work through BlockNameSpace to the method // namespace // XXX re-eval this... do we need it?
// these are used to eliminate code duplication. i don't normally use // the visitor or "template method" pattern, but this code was contributed // by Peter Cox and i don't feel like changing it around too much.
// fuck me dead
// stupid hack to handle referencing // a rule set that is defined later!
// JDK 1.4 workaround
// should the next two be public, maybe?
"/*		Note: this method and resolveExpectedJavaField should be rewritten		to invert this logic so that no exceptions need to be caught		unecessarily.  This is just a temporary impl.		@return the field or null if not found	*/"
"/*		Note: we need a singleton here so that things like 'this == this' work		(and probably a good idea for speed).		Caching a single instance here seems technically incorrect,		considering the declaringInterpreter could be different under some		circumstances.  (Case: a child interpreter running a source() / eval() 		command ).  However the effect is just that the main interpreter that		executes your script should be the one involved in call-backs from Java.		I do not know if there are corner cases where a child interpreter would		be the first to use a This reference in a namespace or if that would		even cause any problems if it did...  We could do some experiments		to find out... and if necessary we could cache on a per interpreter		basis if we had weak references...  We might also look at skipping 		over child interpreters and going to the parent for the declaring 		interpreter, so we'd be sure to get the top interpreter.	*/"
"/* 			Resolve relative to a class type			static field, inner class, ?		*/"
// some regexps (eg ^ by itself) have a length == 0, so we // implement this hack. if you don't understand what's going on // here, then go back to watching MTV
// Optimization - If classOfStaticMethod is set then we have already  // been here and determined that this is a static method invocation. // Note: maybe factor this out with path below... clean up.
// this will probably not get used // Object type
// Windows JDK workaround
// this listener priority thing is a bad hack...
"/* This doesn't look pretty and mode line should			 * probably be split up into seperate			 * components/strings			 */"
"/* this is stupid and misleading.				 * but 'path' is not used anywhere except				 * the above line, and if this is done				 * after the 'continue', then we will				 * either hang, or be forced to duplicate				 * it inside the buffer == null, or add				 * a 'finally' clause. you decide which one's				 * worse. */"
"/* workaround for hang if match was					 * zero-width. not sure if there is					 * a better way to handle this */"
"/* On Windows, paths of the form X: list the last *working		 * directory* on that drive. To list the root of the drive,		 * you must use X:\.		 *		 * However, the VFS browser and friends strip off trailing		 * path separators, for various reasons. So to work around		 * that, we add a '\' to drive letter paths on Windows.		 */"
// On Unix, set permissions of port file to rw-------, // so that on broken Unices which give everyone read // access to user home dirs, people can't see your // port file (and hence send arbitriary BeanShell code // your way. Nasty.)
// ??? this should only be called with // fully loaded action set
// broken Eclipse workaround! // 24 Febuary 2004
"/*		Notes:		This is broken.  It finds public but less specific main.methods over		non-public but more specific ones.		This method needs to be rewritten to eliminate findAccessibleMethod.		We should implement the findMostSpecificMethod that uses the publicOnly		flag.  FindMostSpecificMethod should also operate in two passes to give		standard Java assignable matches priority over extended bsh type		matches.	*/"
// XXX: This should not be hardcoded
// INTERVAL OPERATOR: //  {x} | {x,} | {x,y}  (RE_INTERVALS && RE_NO_BK_BRACES) //  \{x\} | \{x,\} | \{x,y\} (RE_INTERVALS && !RE_NO_BK_BRACES) // // OPEN QUESTION:  //  what is proper interpretation of '{' at start of string?
// XXX: does this really belong here?
// We do need to save every possible point, but the number of clone() // invocations here is really a killer for performance on non-stingy // repeat operators.  I'm open to suggestions...
"/*		Note: this should really just throw NoSuchFieldException... need		to change related signatures and code.	*/"
// Split the main.methods into constructors and regular method lists
// need to add static block here
"/** * An output stream that compresses into the BZip2 format (without the file * header chars) into another stream. TODO: Update to BZip2 1.0.1 * * @author <a href=""mailto:keiron@aftexsw.com"">Keiron Liddle</a> */"
"/**    * Parse the XML declaration.    * <pre>    * [25] XMLDecl ::= '&lt;?xml' VersionInfo EncodingDecl? SDDecl? S? '?&gt;'    * [26] VersionInfo ::= S 'version' Eq ('""1.0""' | ""'1.0'"")    * [33] SDDecl ::= S 'standalone' Eq ""'"" ('yes' | 'no') ""'""    *               | S 'standalone' Eq '""' (""yes"" | ""no"") '""'    * [78] EncodingDecl ::= S 'encoding' Eq QEncoding    * </pre>    * <p>([80] to [82] are also significant.)    * <p>(The <code>&lt;?xml</code> and whitespace have already been read.)    * <p>TODO: validate value of standalone.    * @see #parseTextDecl    * @see #checkEncoding    */"
// implement the recursion for getClassImpl()
// Need some format checking here
// Need to calculate this... just fudging here for now.
// TODO: Also check REG_ANCHORINDEX vs. anchor
// skip header bytes // maybe should check if they're valid or not?
"/*		Debug utils are static so that they are reachable by code that doesn't		necessarily have an interpreter reference (e.g. tracing in utils).		In the future we may want to allow debug/trace to be turned on on		a per interpreter basis, in which case we'll need to use the parent 		reference in some way to determine the scope of the command that 		turns it on or off.	*/"
"/**    * Parse an element-content model.    * [42] elements ::= (choice | seq) ('?' | '*' | '+')?    * [44] cps ::= S? %cp S?    * [45] choice ::= '(' S? %ctokplus (S? '|' S? %ctoks)* S? ')'    * [46] ctokplus ::= cps ('|' cps)+    * [47] ctoks ::= cps ('|' cps)*    * [48] seq ::= '(' S? %stoks (S? ',' S? %stoks)* S? ')'    * [49] stoks ::= cps (',' cps)*    * *NOTE: the opening '(' and S have already been read.    * *TODO: go over parameter entity boundaries more carefully.    */"
// this convention may change...
"/**    * Parse the attribute type.    * [54] AttType ::= StringType | TokenizedType | EnumeratedType    * [55] StringType ::= 'CDATA'    * [56] TokenizedType ::= 'ID' | 'IDREF' | 'IDREFS' | 'ENTITY' | 'ENTITIES' |    *                        'NMTOKEN' | 'NMTOKENS'    * [57] EnumeratedType ::= NotationType | Enumeration    * *TODO: validate the type!!    */"
