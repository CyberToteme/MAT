// use COUNT as the default.  This mimics the old behavior, although // NONE might be a better option moving forward in the case of callable
//perhaps not really necessary...
// todo : what else to do here?
//TODO: disable batch loading if lockMode > READ?
//TODO: to handle concurrent writes correctly, the client should pass in a Lock
// turn hibernate.c3p0.* into c3p0.*, so c3p0 // gets a chance to see all hibernate.c3p0.*
//note there is a wierd implementation in the client side
// todo: this was added to support initializing an entity's EntityEntry snapshot during reattach; // this should be refactored to instead expose a method to assemble a EntityEntry based on this // state for return.
// Do we need to drop constraints before dropping tables in this dialect?
"/**     * FIXME Per the RegionFactory class Javadoc, this constructor version     * should not be necessary.     *      * @param props The configuration properties     */"
// Does this dialect support check constraints?
// this is called by SessionFactory irregardless; we just disregard here; // could also add a check to SessionFactory to only conditionally call start
// Does this dialect support the UNIQUE column syntax?
// this is done here 'cos we might only know the type here (ugly!) // TODO: improve this a lot:
// Does this dialect support the FOR UPDATE syntax?
// todo : what is the implication of this?
// todo : YUCK!!!
// todo : again, how *should* this work for non-pojo entities?
// Does this dialect support FOR UPDATE OF, allowing particular rows to be locked?
//TODO: really bad, evil hack to fix!!!
//aliasRefNode.resolve( false, false, aliasRefNode.getText() ); //TODO: is it kosher to do it here? //TODO: is it kosher to do it here?
//TODO: better to degrade to lazy="false" if uninstrumented
// Does this dialect support the Oracle-style FOR UPDATE NOWAIT syntax?
//Icky workaround for MySQL bug:
// we have to set up the table later!! yuck
//TODO: Somehow add the newly created foreign keys to the internal collection
// This inner class implements a case statement....perhaps im being a bit over-clever here
//TODO: merge into one method!
// TODO: this is a bit of copy/paste from IndexedCollection.createPrimaryKey()
// TODO: what type?
//TODO: inefficient
//FIXME: get the PersistentClass
// todo : we can remove this once the deprecated ctor can be made private...
//TODO: this is too conservative; if all preceding joins were  //      also inner joins, we could use an inner join here
//TODO: redesign how PropertyAccessors are acquired...
// TODO : not so sure this is needed...
//create an index on the key columns??
"/* TODO: joinKeyColumnName & foreignKeyColumnName should be called either here or at a			 * slightly higer level in the stack (to get all the information we need)			 * Right now HbmBinder does not support the			 */"
//TODO: improve this hack!
//TODO: bad implementation, cos it depends upon ordering of mapping doc //      fixing this requires that Collection/PersistentClass gain access //      to the Mappings reference from Configuration (or the filterDefinitions //      map directly) sometime during Configuration.buildSessionFactory //      (after all the types/filter-defs are known and before building //      persisters).
//use of trim() here is ugly?
//TODO: ideally we need the construction of PropertyAccessor to take the following: //      1) EntityMode //      2) EntityMode-specific data (i.e., the classname for pojo entities) //      3) Property-specific data based on the EntityMode (i.e., property-name or dom4j-node-name) // The easiest way, with the introduction of the new runtime-metamodel classes, would be the // the following predicates: //      1) PropertyAccessorFactory.getPropertyAccessor() takes references to both a //          org.hibernate.metadata.EntityModeMetadata and org.hibernate.metadata.Property //      2) What is now termed a "PropertyAccessor" stores any values needed from those two //          pieces of information //      3) Code can then simply call PropertyAccess.getGetter() with no parameters; likewise with //          PropertyAccessor.getSetter()
// can happen because of the multiple ways Cache.remove() // can be invoked :(
//ick!
// TODO: this is very suboptimal for some subclasses (namely components), // since it does not take advantage of two-phase-load
//TODO: should this be Session.instantiate(Persister, ...)?
//TODO: suck this into initLaziness!
// 'hibernate.temp.use_jdbc_metadata_defaults' is a temporary magic value. // The need for it is intended to be alleviated with future developement, thus it is // not defined as an Environment constant... // // it is used to control whether we should consult the JDBC metadata to determine // certain Settings default values; it is useful to *not* do this when the database // may not be available (mainly in tools usage).
//TODO: is this right??
//ie. the subquery! yuck!
//use of a stringbuffer to workaround a JDK bug
//TODO: copy/paste from recreate()
//workaround, for backward compatibility of sets with no //not-null columns, assume all columns are used in the //row locator SQL
// todo : this eventually needs to be removed
// todo : remove
//just to help out during the load (ugly, i know)
// hack/workaround as sqlquery impl depend on having a key.
//TODO: handle the case of a foreign key to something other than the pk
//TODO: assumes all collections disassemble to an array!
// todo : would love to have this work on a notification basis //    where the successful binding of an entity/subclass would //    emit a notification which the extendsQueue entries could //    react to...
// TODO: is it really neceassry to provide Configuration to CollectionPersisters ? Should it not be enough with associated class ? // or why does EntityPersister's not get access to configuration ? // // The only reason I could see that Configuration gets passed to collection persisters // is so that they can look up the dom4j node name of the entity element in case // no explicit node name was applied at the collection element level.  Are you kidding me? // Trivial to fix then.  Just store and expose the node name on the entity persister // (which the collection persister looks up anyway via other means...).
//TODO: deprecated, remove eventually
//TODO possibly relax that
// TODO : this is a bit dodgy, come up with a better way to check this (plus see above comment)
//use a degenerated strategy for backward compatibility
//TODO: this is temporary in that the end result will probably not take a Property reference per-se.
// todo : better to handle dynamic filters through implicit DynamicFilterParameterSpecification // see the discussion there in DynamicFilterParameterSpecification's javadocs as to why // it is currently not done that way.
// get the right object from the list ... would it be easier to just call getEntity() ??
// TODO: should "record" how many properties we have reffered to - and if we  //       don't get'em'all we throw an exception! Way better than trial and error ;)
//TODO: this dependency is kinda Bad
//TODO: get SQL rendering out of this package!
// why does this matter?
// important, to account for newly saved entities in query // todo : some kind of check for new status...
//TODO: can we *always* use the "null property" approach for everything?
// does this need holdlock also? : return tableName + " with (updlock, rowlock, holdlock)";
//for sets, we should end the collection load after resolving //the entities, since we might call hashCode() on the elements //TODO: or we could do this polymorphically, and have two //      different operations implemented differently for arrays
// todo : remove this and just have subclasses use Isolater/IsolatedWork directly...
// sql-server, at least needed this dropped after use; strange!
// is it necessary to register %exact since it can only appear in a where clause?
//for arrays, we should end the collection load before resolving //the entities, since the actual array instances are not instantiated //during loading //TODO: or we could do this polymorphically, and have two //      different operations implemented differently for arrays
// Does this dialect support the ALTER TABLE syntax?
// This next bit is to allow for both unsaved-value="negative" // and for "older" behavior where version number did not get // seeded if it was already set in the object // TODO: shift it into unsaved-value strategy
//TODO: reenable if we also fix the above todo
// orphans should not be deleted during copy??
// orphans should not be deleted during merge??
//TODO: suck this logic into the collection!
// todo : we can actually just determine this from the incoming EntityEntry-s
//TODO: this bit actually has to be called after all cascades! //      but since identity insert is called *synchronously*, //      instead of asynchronously as other actions, it isn't
// this class has no proxies (so do a shortcut)
//TODO: Should this be an InitializeEntityEventListener??? (watch out for performance!)
// todo : need map? the prob is a proper key, right?
//TODO: better to pass the id in as an argument?
//do we even really need this? the update will fail anyway....
//TODO: would it be better to do a refresh from db?
"/**	 * This form used from annotations (?).  Essentially the same as the above using a	 * resultset-mapping reference, but without cacheMode, readOnly, and comment.	 *	 * FIXME: annotations do not use it, so it can be remove from my POV	 * @deprecated	 *	 *	 * @param query The sql query string	 * @param resultSetRef The result-set-mapping name	 * @param querySpaces Any specified query spaces (used for auto-flushing)	 * @param cacheable Whether the query results are cacheable	 * @param cacheRegion If cacheable, the region into which to store the results	 * @param timeout A JDBC-level timeout to be applied	 * @param fetchSize A JDBC-level fetch-size to be applied	 * @param flushMode The flush mode to use for this query	 * @param parameterTypes parameter type map	 * @param callable Does the query string represent a callable object (i.e., proc)	 */"
//TODO: ugly here:
//TODO: not quite sure about the full implications of this!
// this only works because collection entries are kept in a sequenced // map by persistence context (maybe we should do like entities and // keep a separate sequences set...) //TODO: calling entrySet on an IdentityMap is SLOW!!
// todo : i'd much rather have this done from #endLoadingCollection(CollectionPersister,LoadingCollectionEntry)...
// todo : hack!!! // NOTE : here we cleanup the load context when we have no more local // LCE entries.  This "works" for the time being because really // only the collection load contexts are implemented.  Long term, // this cleanup should become part of the "close result set" // processing from the (sandbox/jdbc) jdbc-container code.
// todo : add the notion of enabled filters to the CacheKey to differentiate filtered collections from non-filtered; //      but CacheKey is currently used for both collections and entities; would ideally need to define two seperate ones; //      currently this works in conjuction with the check on //      DefaultInitializeCollectionEventHandler.initializeCollectionFromCache() (which makes sure to not read from //      cache with enabled filters). // EARLY EXIT!!!!!
//PostLoad is needed for EJB3 //TODO: reuse the PostLoadEvent...
// todo : should we check the current isolation mode explicitly?
// brand new collection //TODO: or an array!! we can't lock objects with arrays now??
// TODO: iteratively get transient entities and retry merge until one of the following conditions: //       1) transientCopyCache.size() == 0 //       2) transientCopyCache.size() is not decreasing and copyCache.size() is not increasing // TODO: find out if retrying can add entities to copyCache (don't think it can...) // For now, just retry once; throw TransientObjectException if there are still any transient entities
// null or brand new collection // this will also (inefficiently) handle arrays, which have // no snapshot, so we can't do any better
// TODO : perhaps we should additionally require that the incoming entity // version be equivalent to the defined unsaved-value?
"/** * Provides query splitting main.methods, which were originally in QueryTranslator. * <br> * TODO: This will need to be refactored at some point. * * @author josh */"
// TODO : most of below was taken verbatim from DotNode; should either delegate this logic or super-type it
// todo : currently expects that the individual with expressions apply to the same sql table join. //      This may not be the case for joined-subclass where the property values //      might be coming from different tables in the joined hierarchy.  At some //      point we should expand this to support that capability.  However, that has //      some difficulties: //          1) the biggest is how to handle ORs when the individual comparisons are //              linked to different sql joins. //          2) here we would need to track each comparison individually, along with //              the join alias to which it applies and then pass that information //              back to the FromElement so it can pass it along to the JoinSequence
// No explicit select expression; render the id and properties // projection lists for every persister in the from clause into // a single 'token node'. //TODO: the only reason we need this stuff now is collection filters, //      we should get rid of derived select clause completely!
// TODO : better way?!?
/////////////////////////////////////////////////////////////////////// // HACK ALERT !!!!!!!!!!!!!!!!!!!!!!!!!!!! // Attempt to work around "ghost" ImpliedFromElements that occasionally // show up between the actual things being joined.  This consistently // occurs from index nodes (at least against many-to-many).  Not sure // if there are other conditions // // Essentially, look-ahead to the next FromElement that actually // writes something to the SQL
// Not possible to simply re-use the versionPropertyNode here as it causes // OOM errors due to circularity :(
// this function has a template -> restore output, apply the template and write the result out // TODO: Downcast to avoid using an interface?  Yuck.
// at some point the generate phase needs to be moved out of here, // because a single object-level DML might spawn multiple SQL DML // command executions. // // Possible to just move the sql generation for dml stuff, but for // consistency-sake probably best to just move responsiblity for // the generation phase completely into the delegates // (QueryLoader/StatementExecutor) themselves.  Also, not sure why // QueryLoader currently even has a dependency on this at all; does // it need it?  Ideally like to see the walker itself given to the delegates directly...
//TODO:this is only needed during compilation .. can we eliminate the instvar?
// TODO : absolutely no usages of this constructor form; can it go away?
//TODO: is this a bit ugly?
// even here, if only properties mapped to the "base table" are referenced // in the set and where clauses, this could be handled by the BasicDelegate. // TODO : decide if it is better performance-wise to perform that check, or to simply use the MultiTableUpdateDelegate
// TODO : remove these last two as batcher is no longer managing connections
// VERY IMPORTANT!!!! - This class needs to be free of any static references // to any CGLIB or Javassist classes.  Otherwise, users will always need both // on their classpaths no matter which (if either) they use. // // Another option here would be to remove the Hibernate.isPropertyInitialized() // method and have the users go through the SessionFactory to get this information.
// TODO : we really need to be able to deal with component paths here also; // this is difficult because the hql-sql grammar expects all those node types // to be FromReferenceNodes.  One potential fix here would be to convert the // IntoClause to just use a FromClause/FromElement combo (as a child of the // InsertStatement) and move all this logic into the InsertStatement.  That's // probably the easiest approach (read: least amount of changes to the grammar // and code), but just doesn't feel right as then an insert would contain // 2 from-clauses
// TODO : an optimization here would be to consider cascade deletes and not gen those delete statements; //      the difficulty is the ordering of the tables here vs the cascade attributes on the persisters -> //          the table info gotten here should really be self-contained (i.e., a class representation //          defining all the needed attributes), then we could then get an array of those
//TODO: switch statements are always evil! We already had bugs because  //      of forgotten token types. Use polymorphism for this!
// really there are two situations where it should be ok to allow the insertion // into properties defined on a superclass: //      1) union-subclass with an abstract root entity //      2) discrim-subclass // // #1 is handled already because of the fact that // UnionSubclassPersister alreay always returns 0 // for this call... // // we may want to disallow it for discrim-subclass just for // consistency-sake (currently does not work anyway)...
// implicit joins are always(?) ok to reuse
//TODO: used to be exprNoParens! was this needed?
// TODO : we may also want to check that the types here map to exactly one column/JDBC-type //      can't think of a situation where arithmetic expression between multi-column mappings //      makes any sense.
// we do not know either type //BLIND GUESS!
// TODO: get SQL rendering out of here, create an AST for the join expressions. // Use the SQL generator grammar to generate the SQL text for the index expression.
// We would probably refactor to have LogicParser (builds a tree of simple // expressions connected by and, or, not), ExpressionParser (translates // from OO terms like foo, foo.Bar, foo.Bar.Baz to SQL terms like // FOOS.ID, FOOS.BAR_ID, etc) and PathExpressionParser (which does much // the same thing it does now)
// short-circuit for performance...
// not absolutely necessary, but does help with aggressive release
// try block is a hack around fact that currently tuplizers are not // given the opportunity to resolve a subclass entity name.  this // allows the (we assume custom) interceptor the ability to // influence this decision if we were not able to based on the // given entityName
//TODO: this is one of the ugliest and most fragile pieces of code in Hibernate....
//TODO: implement functionality //  this might be painful to do here, as the "join post processing" for //  the subquery has already been performed (meaning that for //  theta-join dialects, the join conditions have already been moved //  over to the where clause).  A "simple" solution here might to //  perform "join post processing" once for the entire query (including //  any subqueries) at one fell swoop
//yuck!
// ignore it; the incoming property could not be found so we // cannot be sure what to do here.  At the very least, the // safest is to simply not apply any dereference toggling...
//TODO: make this a bit nicer
// yuck!
// todo : potentially look at optimizing these two arrays
//note that i parameter is now unused (delete it?)
// TODO: Figure out a better way to get the FROM elements in a proper tree structure. // If this is not the destination of a many-to-many, add it as a child of the origin.
// TODO : this constructor form is *only* used from constructor directly below us; can it go away?
// We should reengineer this class so that, rather than the current ad - // hoc linear approach to processing a stream of tokens, we instead // build up a tree of expressions.
// todo : should this get moved to PersistentContext? // logically, is PersistentContext the "thing" to which an interceptor gets attached?
// TODO: something much better - look at the type of the other expression! // TODO: Have comparisonExpression and/or arithmeticExpression rules complete the resolution of boolean nodes.
//TODO: this class does too many things! we need a different //kind of path expression parser for each of the diffferent //ways in which path expressions can occur
//TODO: optimize this better!
//TODO: should we allow suffixes on these ?
//TODO: is this really necessary????
// TODO : not sure the best way to handle this. // The non-performant way :
//TODO: is there a better way?
//The class is now way to complex!
// TODO : would be really nice to cache the spec on the query-def so as to not have to re-calc the hash; // currently not doable though because of the resultset-ref stuff...
//name from a super query (a bit inelegant that it shows up here)
//real hacky... // used to count the nesting of parentheses
//put() has nowait semantics, is this really appropriate? //note that it needs to be async replication, never local or sync
// ugly hack for cases like "elements(foo.bar.collection)" // (multi-part path expression ending in elements or indices)
// FIXME Hacky workaround to JBCACHE-1202
//TODO: COPY/PASTE FROM SessionImpl, pull up!
// todo : need to find a clean way to handle the "event source" role // a seperate classs responsible for generating/dispatching events just duplicates most of the Session main.methods... // passing around seperate reto interceptor, factory, actionQueue, and persistentContext is not manageable...
//Must be done here because of side-effect! yuck...
//We should actually rework this class to not implement Parser //and just process path expressions in the most convenient way.
// TODO : should remove this exposure //  and have all references to the session's batcher use the ConnectionManager.
// we may be screwed here since the collection action is about to execute // and we do not know the final owner key value
// Needed the "clazz_" check to work around union-subclasses // TODO : is there a way to tell whether a persister is truly discrim-column based inheritence?
//work around a bug in all known connection pools....
//TODO: reuse the PreLoadEvent
// Need a better way to define the suffixes here...
//workaround for WebLogic
//TODO: temporary
// TODO : YUCK!!!  fix after HHH-1907 is complete
// would be great to move all this below here into another method that could also be used // from the new scrolling stuff. // // Would need to change the way the max-row stuff is handled (i.e. behind an interface) so // that I could do the control breaking at the means to know when to stop
//TODO: the i==entitySpan-1 bit depends upon subclass implementation (very bad)
// some messy, complex stuff here, since createCriteria() can take an // aliased path, or a path rooted at the creating criteria instance
//TODO: add a CriteriaImplementor interface //      this class depends directly upon CriteriaImpl in the impl package...
// polymorphism not really handled completely correctly, // perhaps...well, actually its ok, assuming that the // entity name used in the lookup is the same as the // the one used here, which it will be
//This is not very nice (and quite slow):
//TODO: get SQL rendering out of here
// meant to handle dynamic instantiation queries...(Copy from QueryLoader)
// Make sure this is a defined parameter and check the incoming value type // TODO: what should be the actual exception type here?
// worrying about proxies is perhaps a little bit of overkill here...
// todo : throw exception?  maybe warn if not the same?
//TODO: make EntityPersister *not* depend on SessionFactoryImplementor //interface, if possible
// TODO : what amount of significant digits need to be supported here? //      - from the DecimalFormat docs: //          [significant digits] = [minimum integer digits] + [maximum fraction digits]
//for backward compatibility, allow a set with no not-null  //element columns, using all columns in the row locater SQL //TODO: create an implicit not null constraint on all cols?
// TODO: copy/paste from ManyToOneType
//TODO: code duplication with SingleTableEntityPersister
// todo : throw exception?
//should this interface extend PropertyMapping?
// TODO: here is why we need to make bytecode provider global :( // TODO : again, fix this after HHH-1907 is complete
//TODO: currently keeps Getters and Setters (instead of PropertyAccessors) because of the way getGetter() and getSetter() are implemented currently; yuck!
//TODO: Yuck! This is not quite good enough, it's a quick //hack around the problem of having a to-one association //that refers to an embedded component:
//TODO: implement caching?! proxies?!
// is this really necessary?
//TODO: this is a little inefficient, don't need to do a whole //      deep replaceElements() call
//TODO: this is a bit arbitrary, expose a switch to the user?
"/**	 * @return collection removal	 * FIXME: even if isInverse=""true""?	 */"
// TODO: Fix this so it will work for non-POJO entity mode
//TODO: move these to a new JoinableType abstract class, //extended by EntityType and PersistentCollectionType:
//TODO: would be nice to handle proxy classes elegantly!
//SPACES //TODO: i'm not sure, but perhaps we should exclude //      abstract denormalized tables?
//TODO: is there a more elegant way than downcasting?
//TODO: remove use of instanceof!
//TODO: perhaps this should be some other RuntimeException...
//Yuck:
//TODO: need some caching scheme? really comes down to decision  //      regarding amount of state (if any) kept on PropertyAccessors
//TODO: design new lifecycle for ProxyFactory
// todo: we should really just collect these from the various SelectExpressions, rather than regenerating here
// TODO: Should this really return null?  If not, figure out something better to do here.
// todo : should seriously consider not allowing a txn to begin from a child session //      can always route the request to the root session...
// should indicate that we are processing an INSERT/UPDATE/DELETE // query with a subquery implied via a collection property // function. Here, we need to use the table name itself as the // qualification alias. // TODO : verify this works for all databases... // TODO : is this also the case in non-"indexed" scenarios?
// TODO : this really needs to be delayed unitl after we definitively know all node types // where this is currently a problem is parameters for which where we cannot unequivocally // resolve an expected type
// TODO : make this the factory for "entity mode related" sessions; // also means making this the target of transaction-synch and the // thing that knows how to cascade things between related sessions // // At that point, perhaps this thing is a "SessionContext", and // ConnectionManager is a "JDBCContext"?  A "SessionContext" should // live in the impl package...
// create an index on the key columns??
//is this ok?
//init the table here instead of earlier, so that we can get a quoted table name //TODO: would it be better to simply pass the qualified table name, instead of //      splitting it up into schema/catalog/table names
// perhaps this should be an exception since it is only ever used // in the above method?
// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass! // was toUnqotedAliasStrings( getdiscriminatorColumnName() ) before - now tried // to remove that unqoting and missing aliases..
// Put a placeholder in entries, so we don't recurse back and try to save() the // same object again. QUESTION: should this be done before onSave() is called? // likewise, should it be done before onUpdate()?
//before cascade! //TODO: should this be Session.instantiate(Persister, ...)?
//TODO: we should throw an exception if we really *know* for sure   //      that this is a detached instance, rather than just assuming //throw new StaleObjectStateException(entityName, id);
// TODO: The order in which entities are saved may matter (e.g., a particular transient entity //       may need to be saved before other transient entities can be saved; //       Keep retrying the batch of transient entities until either: //       1) there are no transient entities left in transientCopyCache //       or 2) no transient entities were saved in the last batch // For now, just run through the transient entities and retry the merge
//TODO: if object was an uninitialized proxy, this is inefficient, //      resulting in two SQL selects
//TODO: put this stuff back in to read snapshot from //      the second-level cache (needs some extra work)
//this is kinda the best we can do...
/* trim done to workaround stupid oracle bug that cant handle whitespaces before a { in a sp */
//TODO: this needn't exclude subclasses...
//TODO: we use two visitors here, inefficient!
//TODO: does this really need to be here? //      does the collection already have //      it's own up-to-date snapshot?
// otherwise, a trim-specification and/or a trim-character // have been specified;  we need to decide which options // are present and "do the right thing" // should leading trim-characters be trimmed? // should trailing trim-characters be trimmed? // the trim-character // the trim-source
//it is possible that the tree-walking in OuterJoinLoader can get to //an association defined by a subclass, in which case the property-ref //might refer to a property defined on a subclass of the current class //in this case, the table name is not known - this temporary solution  //assumes that the property-ref refers to a property of the subclass //table that the association belongs to (a reasonable guess) //TODO: fix this, add: OuterJoinLoadable.getSubclassPropertyTableName(String propertyName)
// TODO: an alternative is to check if the owner has changed; if it hasn't then // return collection.getOwner()
//I suppose?
"// TBD should this be varbinary($1)? //		registerColumnType(Types.VARBINARY,     ""binary($1)"");"
//shortcut
//TODO: we should provide some way to get keys of collection of statistics to make it easier to retrieve from a GUI perspective
// TODO : probably better to calculate these and pass them in, as it'll be more performant
// todo : should we additionally check the current isolation mode explicitly?
//TODO: simply remove this override //      if we fix the above todos
// todo : is there really any reason to kkeep trying if this fails once?
// TODO : not sure this is correct, could not find docs on how to do this.
//HSQL has no Blob/Clob support .... but just put these here for now!
"// merges don't cascade to uninitialized collections //			//TODO: perhaps this does need to cascade after all...."
// yick!  need this for proper serialization/deserialization handling...
//TODO: should orphans really be deleted during lock???
// todo : move to StringHelper?
// Sets can be just a view of a part of another collection. // do we need to copy it to be sure it won't be changing // underneath us? // ie. this.set.addAll(set);
// TODO: It would be really, really nice to use this to also model components!
//TODO: move to .sql package!!
//TODO: look at the owning property and check that it  //      isn't lazy (by instrumentation)
// TODO : add this info to the translator and aggregate it here...
// would be better to use the element-type to determine // whether the old and the new are equal here; the problem being // we do not necessarily have access to the element type in all // cases
//TODO: code duplication with JoinedSubclassEntityPersister
//TODO: refactor to .sql package
//TODO: *two* hashmap lookups here is one too many...
//note that this method could easily be moved up to BasicEntityPersister, //if we ever needed to reuse it from other subclasses
// from the collection of associations, locate OJA for the // ManyToOne corresponding to this persister to fully // define the many-to-many; we need that OJA so that we can // use its alias here // TODO : is there a better way here?
//TODO: this class depends directly upon CriteriaImpl,  //      in the impl package ... add a CriteriaImplementor  //      interface
// Do we need to qualify index names with the schema name?
//TODO: We probably should have a StatisticsNotPublishedException, to make it clean
//yukky! Don't you have subclasses for that! //TODO race conditions can happen here
// NOTE VERY HACKISH WORKAROUND!! // TODO: Fix this so it will work for non-POJO entity mode
//TODO: need to make the majority of this functionality into a top-level support class for custom impl support
// for DOM4J "collections" only // TODO: it would be better if this was done at the higher level by Printer
//TODO: inefficient if that cache is just going to ignore the updated state!
// TODO: an alternative is to check if the owner has changed; if it hasn't then // get the ID from collection.getOwner()
//TODO:refactor + make this method private
// TODO : keep seperate notions of QT[] here for shallow/non-shallow queries...
// todo : temporary //      needed because currently persister is the one that //      creates and renders the join fragments for inheritence //      hierarchies...
// this is called by SessionFactory irregardless; we just disregard here; // could also add a check to SessionFactory to only conditionally call stop
//swaldman 2004-02-07: modify to allow null values to signify fall through to c3p0 PoolConfig defaults
// work around that crazy issue where the tree contains // "empty" FromElements (no text); afaict, this is caused // by FromElementFactory.createCollectionJoin()
//kinda ugly, but needed for collections with a "." node mapping
// TODO : would be great to have a Mapping#hasNonIdentifierPropertyNamedId method // I don't believe that Mapping#getReferencedPropertyType accounts for the identifier property; so // if it returns for a property named 'id', then we should have a non-id field named id
// entity name will not be available for non-POJO entities // TODO: cache the entity name somewhere so that it is available to this exception
//index += getPropertyColumnSpan( i ); //TODO:  this is kinda slow...
//TODO: move to .sql package, and refactor with similar things!
//TODO: I am not so sure about the exception handling in this bit!
//ugly little workaround for fact that createUniqueKeyLoaders() does not handle component properties
// append the SQL to return the generated identifier //TODO: suck into Insert
//This is really ugly, but necessary:
// todo : modify the class definition if not already transformed...
//TODO: should we use SELECT .. FOR UPDATE?
"/** Create an action that will evict collection and entity regions based on queryspaces (table names).	 *  TODO: cache the autodetected information and pass it in instead.	 **/"
//TODO: is this 100% correct?
/////////////////////////////////////////////////////////////////////////// // USED ONLY FOR REGRESSION TESTING!!!! // // todo : obviously get rid of all this junk ;) ///////////////////////////////////////////////////////////////////////////
// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass! // was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried // to remove that unqoting and missing aliases..
//TODO: move into collection type, so we can use polymorphism!
// TODO should we just collect these like with the collections above?
// todo : should really move this log statement to CollectionType, where this is used from...
//hum ... should we cascade anyway? throw an exception? fine like it is?
// todo: this might really even be moved into the cfg package and used as the basis for all things which are configurable.
//TODO: copy/paste from insertRows()
//TODO: suck into event class
//TODO: never reached, since getTypeName() actually throws an exception!
// This, is used by SessionFactoryImpl to hand to the generated SessionImpl; // was the only reason I could see that we cannot just use null as // Settings.cacheProvider
// xmlforest requires a new kind of function constructor
// TODO Is this a valid operation on a timestamps cache?
// TODO: I considered validating the presence of the TS cache here, // but decided to defer unti getQueryCacheInstance() in case the  // cache is never actually used
// TODO Why not use the timestamp in a DataVersion?
// todo : eventually merge this with TreeCache and just add optional opt-lock support there.
// work around the "feature" where tree cache is validating the // inserted node during the next transaction.  no idea...
// TODO: I considered validating TS cache config here, // but decided to defer unti getTimestampsCacheInstance() in case the  // cache is never actually used
//need to do that here rather than in the save event listener to let //the post insert events to have a id-filled entity when IDENTITY is used (EJB3)
// unhappy about this being public ... is there a better way?
// TODO : safe to interpret "map.remove(key) == null" as non-dirty?
// FIXME hack to work around fact that calling // Node added = root.addChild( fqn ); doesn't  // properly set the version on the node
// work around the "feature" where tree cache is validating the // inserted node during the next transaction. no idea...
// TODO: Replace this with a more elegant solution.
// short cut check...
//TODO: to handle concurrent writes correctly, this should return a Lock to the client
// this is ugly here, but needed because its a subquery
// TODO : will need reference to session factory to fully complete HHH-1907
// inheritance cycle detection (paranoid check)
// TODO: encapsulate the protected instance variables!
//polymorphism comment above
// add an entry for this type of entity. // we can be assured that all referenced entities have already // been processed, // so specify that this entity is with the latest batch. // doing the batch number before adding the name to the list is // a faster way to get an accurate number.
// TODO: handle TypeDefs
//TODO: get all properties, not just the fetched ones!
//TODO: native ids
// TODO: bindpropertyresults(alias, returnElem)
//TODO: handle property-ref
//TODO: validate existing of property with the chosen name. (secondpass )
//TODO: check that entry.getIdentifier().equals(requestedId)
// TODO: RESTRICT VIOLATION
//TODO: assertion only, could be optimized away
// TODO: lowercasing done here. Was done "at random" before; maybe not needed at all ?
//TODO: optimize away this lookup for entities w/o unsaved-value="undefined"
// TODO: toLowerCase was not done before. Only used in Template.
//TODO: arithmetic expressions, multiple new Foo(...)
// TODO: not visible to the user!
//TODO: proxies!
//TODO: can we limit stored procedures ?!
//TODO: formulas ?
// TODO: better error message since we actually support composites if names are explicitly listed.
//TODO: use these in main.methods above
//TODO: cache the persister, this shows up in yourkit
//TODO: add referencedClass to disambiguate to FKs on the same //      columns, pointing to different tables
//TODO: create uk loaders for component properties
// TODO : still need to make CollectionPersisters EntityMode-aware
//TODO: terrible implementation!
//TODO: eventually put this back in, once we think all is fixed //Object otherAlias = columnsUnique.put(qualifiedColumn, columnAlias);
// TODO: I don't really like this implementation; it would be better if // this was handled by searchForDirtyCollections()
// TODO: check if key contains the owner ID
//TODO: cache this in an instvar
// TODO : temporary initial step towards HHH-1907
// todo : remove this once ComponentMetamodel is complete and merged
//TODO: add owner argument!!
//TODO handle supportsNotNullUnique=false, but such a case does not exist in the wild so far
//TODO: for some dialects it would be appropriate to add the renderOrderByPropertiesSelect() to other select strings
//TODO: unnecessary for databases with ANSI-style joins
//TODO: maybe call it getRowSelection() ?
//TODO: make this handle multiple collection roles!
//TODO: include the rowids!!!!
// if we are still not resolved, we might represent a constant. //      needed to add this here because the allowance of //      naked-prop-refs in the grammar collides with the //      definition of literals/constants ("nondeterminism"). //      TODO: cleanup the grammar so that "processConstants" is always just handled from here
// TODO : or should we return 'containsTableAlias'??
/////////////////////////////////////////////////////////////////////// // TODO : look at perhaps caching this...
//TODO: avoid this for non-new instances where mightBeDirty==false
//TODO: theoretically non-threadsafe...
// todo : look at optimizing these...
// todo : cache this sql...
"/**	 * TODO: Check if Mimer SQL cannot handle the way DB2 does	 */"
//TODO: if we are using identity columns, fetch the identifier
//TODO check there is no actual definition elemnents when a ref is defined
// table=null -> an association // - fill it in later //TODO fill in the mappings for table == null
// table=null -> an association - fill // it in later //TODO fill in the mappings for table == null
// todo : add support for READ_WRITE ( + NONSTRICT_READ_WRITE ??? )
//TODO: return new Lock(ts);
// TODO : why aren't these the same?
//TODO: if we support multiple fetch groups, we would need //      to clone the set of lazy properties!
//TODO mappings.getLogicalTableName(ownerTable)
//TODO: if lock.getTimestamp().equals(ts)
//TODO: always true for now, but not if we later decide to support elements() in the from clause
// we could move this inside if we wanted to // tolerate collection initializations during // collection dirty checking:
