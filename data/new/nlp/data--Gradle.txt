SATD	 todo this should not using the default charset because its not input and might introduce flakiness 
SATD	 todo make this work with pending elements 
SATD	 the dsl for declaring plugins inject into included build todo plugins need located this builds buildsrc since 
SATD	 todo some kind context why the method was attached which plugin declared the rule todo some kind instance state for the method might the same context above 
SATD	 todo need track symbol strip tool 
SATD	 todo move baseservices once the progresslogger dependency removed 
SATD	 return dummy implementation this creating real hasher drags more services along with and hasher isnt actually needed the worker process side the moment 
SATD	 theres risk for some methods that the hash always recomputed but wont worse than before 
SATD	 this isnt quite right should close the worker classpath cache once were finished with the worker processes this may before the end this build they may used across multiple builds 
SATD	 todo need better mechanism wire tasks into lifecycle 
SATD	 todocedric this not quite right assume that are asking for specific binary then resolve the assembly instead the jar but should somehow parameterized 
SATD	 ensure that most one action that may have access the mutable state the build runs given time todo move this better home and reuse 
SATD	 todoew inject instead static use 
SATD	 todohh use managed views for this only applied when the respective language applied 
SATD	 todo there has simpler way this want create buildable filecollection based filtered view selected source directory sets 
SATD	 passing null for sha todo consider using the etag which hash the file when less than 
SATD	 todoadam need this earlier 
SATD	 todo exception when default type 
SATD	 dont force evaluation rules here let the task container what needs 
SATD	 result scalautileither right seq files that were generated left routes compilation errors todo might nice pass along these errors some way 
SATD	 todo deleteonexit wont clean nonempty directories and leaks memory for longrunning processes 
SATD	 metainfo about java component todo this some legacy stuff merged into other component interfaces 
SATD	 todo need track symbol extraction tool 
SATD	 todo this should modeled differently perhaps dependency the implementation configuration 
SATD	 this not super nice but dependencies are created through reflection for decoration and assume constructor with arguments group name version which suitable for most cases could create empty attribute set directly the but then wouldnt mutable therefore proceed with late injection the attributes 
SATD	 todoew consider whether this belongs console here 
SATD	 todo should split this that the inputs are attached object that represents the binary which then later used configure the linkassemble tasks 
SATD	 need wrap this into loop because theres always risk that the method which weakly referenced has been collected between the creation time and now 
SATD	 tododaniel should support better way multi file invocation 
SATD	 its true right now that this always coming from the testkit but might not the future 
SATD	 todo dont select again here the selection already performed select the toolchain 
SATD	 todo include link documentation giving more explanation whats going here 
SATD	 todo migrate this away from here 
SATD	 this looks ugly very ugly but that apparently what ant does itself 
SATD	 todo should incremental 
SATD	 todo this terrible 
SATD	 todo this should actually routable message with single handler but need some way correlate given request with specific response channel 
SATD	 todo this pretty nasty look avoiding using time bomb stub here 
SATD	 todorbo change the parameter type transformerstring nullable string once migrate java 
SATD	 todo make this work windows originalinclose 
SATD	 todo better exception type 
SATD	 note this would better housed scope that encapsulated the tree gradle objects 
SATD	 link that can used task input property caches the matching set files during task execution and discards the result after task execution todo disallow further changes this collection once task has started todo keep the file entries snapshot later avoid stat each file during snapshot 
SATD	 todo this class and executionplan have many the same behavior and concerns should look for way generalize this pattern 
SATD	 remove this 
SATD	 can only set once should really part the constructor can only set once should really part the constructor 
SATD	 this isnt quite right may lose precision when converting double 
SATD	 decimalformat not thread safe synchronize access the instance 
SATD	 todo wire this stuff properly 
SATD	 todoadam need cleanup completion too not used 
SATD	 todo need check for proper typecast 
SATD	 todo should use resolver that this method consistent with projecturistring 
SATD	 todo wolfs schedule fingerprinting separately can done without having the project lock 
SATD	 note dont actually remove this the deprecation here encourage people use objectfactory instead just remove the overload and the nag and leave the method here 
SATD	 todo consider issues teamcity has the concept wave messages where each threadprocess uses unique wave 
SATD	 todo reduce duplication with swift binary 
SATD	 todo move bootclasspath platform 
SATD	 todo this should modeled source set 
SATD	 todo the project model should reachable from projectstate without another lookup 
SATD	 todo locate this tool from tool provider hide main symbol 
SATD	 todo this prefix shouldnt hardcoded 
SATD	 todolptr remove projection for reference node this shouldnt needed but theres actual value referenced model report can only show the type the node this for now should use the schema instead find the type the property node instead 
SATD	 todoadam switch the logging back need make sending messages from daemon client async wrt log event generation loggerdebugignoring failure extract throwable stack trace ignored 
SATD	 todo need failure handling cannot clone repository 
SATD	 todo this should actually compare sortedset 
SATD	 todo validate that its valid model path 
SATD	 the visual tools use the path find other executables todoadam restrict this the specific path for the target tool 
SATD	 todopm move this warn level once fixed mavenpublish see gradlegradle 
SATD	 todoadam this isnt quite right think refers the first capable classloader loading the class this could different from the loader which originally loaded which could pose equality and lifecycle issues 
SATD	 todocedric this approximation when component wants compile against the assembly library not the jar then should give the stubbed classes instead the raw classes however theres such thing stubbed classes assembly for performance reasons only the classes that belong the api are stubbed would miss the classes that not belong the api this makes the usagekindapi misleading should this compile 
SATD	 immutable view the variant component todo this should replace merge into outgoingvariant 
SATD	 because its capability conflict resolution there only one candidate per module identifier can lenient wrt the version number used the descriptor which helps whenever the user used the convenience notation method 
SATD	 todo improve lookup reusing availablejavahomes testfixture for now play safe and just return false 
SATD	 todo should decorate 
SATD	 todo removing this stuff from the store should handled through some sort decoration 
SATD	 todo fix the way work out which exception important not always the most helpful 
SATD	 todo need any factories here 
SATD	 todohh this should moved back into languagenative project 
SATD	 todo make this work with pending elements 
SATD	 todo ultimately this should some kind party dependency thats visible dependency management 
SATD	 todo these should come from somewhere else probably 
SATD	 todo this should become smarter and move into the compiler infrastructure instead the task similar how the other native languages are done for now this does rudimentary incremental build analysis looking which files changed 
SATD	 minimal resolver which does not use any native services used during bootstrap only you should generally use link fileresolver instead todo share more stuff with 
SATD	 list instance needed here does not support serializing iterators directly 
SATD	 todolptr this should added only the scan plugin applied but todolptr expects added also when the build cache enabled but not the scan plugin 
SATD	 todo should set this for macos but this currently breaks xctest support for swift when swift depends libraries built gradle 
SATD	 todolptr when drop java support can switch using classloadergetname instead storing our own 
SATD	 todo provide abstraction for accessing resources within the same module mavenmetadata directory listing etc that way can avoid passing ivypatterns and artifactpatterns around everywhere 
SATD	 remove kotlin predicate after updating the wrapper 
SATD	 closes the tooling api releasing all resources blocks until completed pmay attempt expire some all daemons started this tooling api client the exact behaviour here and not guaranteed the expiration best effort only this method may return before the daemons have stoppedp pnote this not yet part the public tooling api yetp todo need model this long running operation and allow stdout stderr and progress listener supplied todo need define exceptions todo further operations are allowed after this has been called todo cancel current operations block until complete todo introduce tooling api client interface and move this method there 
SATD	 todo use something more stable than cast here 
SATD	 todo make this more intelligent matching the attributes the runtime usage the variant identities 
SATD	 workaround for backwards compatibility previously this case would unintentionally cause the method invoked the owner continue below 
SATD	 todo capitalise the target name the task name todo dont create launch target for library 
SATD	 create binaries for test suites todo this should really componentbinaries rule but this point have clue what the concrete binary type everything has duplicated specific plugins see usages for example 
SATD	 did already consider output after the previous execution 
SATD	 todo get rid this need functionalsourceset instance here and thats surprisingly difficult get 
SATD	 todo generic model related super exception 
SATD	 todo this should work for any build rather than just included build 
SATD	 workaround for 
SATD	 todo basically dont support copying custom javadoc options 
SATD	 todo this exists because detect all available native tool chains system clang gcc swiftc msvc many our old tests assume that available tool chains can compile manymost languages they not try restrict the required set tool chains the swiftc tool chain can build only swift tests that expect use the swiftc tool chain properly annotate their requirements with versionspecific requirement our multitest runner smart enough disable tests that not meet the tests requirements but since many the old tests not have requirements assume the tests require like tool chain gcc clang msvc the future want back old tests and annotate them with tool chains requirements 
SATD	 dont handle variables the moment because users didnt request yet and would probably push add support the tooling api retrieve the variable mappings 
SATD	 todo versionselector should more descriptive can directly translated 
SATD	 todolptr should contentless inputdirectory 
SATD	 todo need smarter way map usage artifact classifier 
SATD	 todo once source compatibility raised this should rewritten using the javaniofilesystem api which can deal with jars and folders the same way instead duplicating code 
SATD	 todo better exception 
SATD	 todo this method accepts closure instance parameter but does not work correctly for 
SATD	 todo find better way present this information the error message attempt mimic gradle nested exception output 
SATD	 todo should really find better solution for this maybe could use filterreader instead filterinputstream 
SATD	 not fully accurate but sensible fallback see 
SATD	 todo not sure can clean the generics here and less unchecked casting 
SATD	 todo deal with more than one header dir generated public headers 
SATD	 todo projectdependency should transformed based defaultproject and other context elsewhere 
SATD	 todo this will have changed when support setting credentials directly the authentication 
SATD	 todo this approximation know swift currently supports only bit runtimes eventually well want query for this 
SATD	 todo the async work tracker should wait for children operation finish first should not necessary call here 
SATD	 todo reduce duplication with binary 
SATD	 todo this should more specific just the tasks that create the class files 
SATD	 todo arent considering the filter 
SATD	 send endofline this workaround convince the console that the cursor the start the line avoid indenting the next line text that displayed would better for the console listen for stuff read from stdin that would also echoed the output and update its state based this 
SATD	 todo exception when type cannot created 
SATD	 todo bind with the sourcecompatibility property todo link runtime configuration 
SATD	 track this input since the scala compiler output may depend todo this should replaced property the scala toolchain soon model these 
SATD	 todolptr instead the first view property should figure out these parameters from the actual property 
SATD	 todo dsl documentation 
SATD	 todo can probably now support more versions with strictly but well need more test coverage 
SATD	 todo move this objectfactory 
SATD	 there are some exceptions attached the suite lets make sure they are reported the user this may happen for example when suite initialisation fails and tests are executed 
SATD	 todo does static library have runtime elements 
SATD	 todolptr this ignores changes projectbuilddir after model node has been created 
SATD	 todolptr remove projection for reference node this shouldnt needed but theres actual value referenced model report can only show the type the node this for now should use the schema instead find 
SATD	 todo what this errors 
SATD	 remove this 
SATD	 todo remove this special case 
SATD	 need move those implicit jvm args that contain space the gradle commandline possible note that this isnt strictly correct some system properties can only set jvm start should change the implementation deal with these properly 
SATD	 doesnt really make sense 
SATD	 typeonly model reference type ambiguous multiple model elements are available for this typen created created 
SATD	 todo exceptions thrown here should point some extensive documentation the concept class rule sources 
SATD	 this workaround until this story completed hardcoding setting the idle timeout max mins this way avoid potential runaway daemons that steal resources linux and break builds windows 
SATD	 todo move this base plugin setup the dependency the main binary this should all replaced single dependency that points some testable variants the main binary 
SATD	 todo should support this adds void propnameobject value method that simply delegates the converting setter method 
SATD	 todo send message workers change their log level rather than stopping 
SATD	 todo this should also using the decorating instantiator but cannot for backwards compatibility 
SATD	 todo visit the contents this collection instead this just super simple implementation for now 
SATD	 todo should get rid this reflection will need reimplement the parser act the metadata directly 
SATD	 todo want keep using sourcedirectoryset the new api would feel more natural dirs could added directly languagesourceset could also think about extending sourcedirectoryset 
SATD	 todolptr this should removed once binarycontainer modelmap need also implement all the interfaces the delegate type because otherwise binarycontainer wont recognize managed binaries binaryspecinternal 
SATD	 todo stream serialised value file todo handle hash collisions properly this time todo dont store null links child blocks leaf index blocks todo align block boundaries todo thread safety control todo merge small values into single data block todo discard when file corrupt todo include data directly index entry when serializer can guarantee small fixed sized data todo free list leaks disk space todo merge adjacent free blocks todo use more efficient lookup for free block with nearest size 
SATD	 this workaround for somehow the arraylist result ends being list nulls windows and ibms jdk 
SATD	 todo binaries arent input this rule theyre input the action 
SATD	 specifies how build and where place native executable file ptodohh resolve naming conflict with existing 
SATD	 this should replaced some stronger modelling and made open rather than hardcoding set source languages here 
SATD	 moved the api back into internal this isnt really correct 
SATD	 todo refactor this action out can unit tested 
SATD	 todo error there are unknowns 
SATD	 todoadam using uuid means create classloader hierarchy for each daemon process talk instead use the spec decide whether reuse classloader 
SATD	 todo should supply and check for the same parameters passed reservenewclient 
SATD	 todo should use the install task for executable 
SATD	 implement this you need specify individual toolchains via 
SATD	 todo annotate required 
SATD	 todo cannot enable this assertion because modulesource not serialized doesnt appear the deserialized form assert 
SATD	 todo excluderule value object but dont enforce immutability for defaultexcluderule strong should expose the map should provide better api for excluderule dont want use unmodifiable map soon defaultexcluderule truly immutable dont need create new instance defaultexcluderule 
SATD	 production code should handle these exceptions more gracefully 
SATD	 todo this isnt quite right 
SATD	 the isempty check not required might look innocent but guavas performance bad for empty immutable list because still creates inner class for iterator which delegates array iterator which does nothing just adding this check has significant impact because most components not declare any capability 
SATD	 todo are relying the registration having established these links should checking 
SATD	 todo add quotes both formats there will lots tests failing not sure worth 
SATD	 todoew consider whether this belongs buildprogressarea here 
SATD	 todo would better these were added via separate managed view rather than hard coded 
SATD	 shouldnt really here currently this goal used link bindallreferences which also expects the subject bound 
SATD	 this doesnt work used because the bottom the hierarchy chain the object implemented methodmissing however our normal decorated classes not this not realistic 
SATD	 todo this returns the wrong public type for domain objects created with the eager apis added directly the container this can leak internal types not currently keep track the type used when creating domain object via create the type the container when domain object added directly via add 
SATD	 todolptr what happens when the property has multiple accessors the same role but with different type 
SATD	 todo should not ignoring dependencyattribute modifications after resolve 
SATD	 todo this should container platforms 
SATD	 todo hack avoid classloading issues should use currently cant use reliably because causes cnf issues with cross version integration tests running against tooling api 
SATD	 todo else verify that the build definition the same 
SATD	 todo make this lazy 
SATD	 todo should this take object 
SATD	 used the kotlindsl base plugin todo remove this 
SATD	 todo sources not actual input binaries its input each binary 
SATD	 todo mix groovy support using bytecode decoration instead todo validate closure parameters check they are within bounds 
SATD	 todo this class attempts mimic the behavior the output mvn helpeffectivepom instead this class should walk the maven project object model instead parsing the xml 
SATD	 have name foobar and import foofoo this means foobar possibly foofoobar rather than foobar this means cut the dot foobar and foo for import 
SATD	 todo remove this once the above removed 
SATD	 this workaround for 
SATD	 todo only here because kotlin dsl uses this please remove once that fixed 
SATD	 hold the lock while creating the connection not generally good form this instance blocks other threads from creating the connection the same time 
SATD	 currently retains strong references types that are not loaded using this fine for jvm types but problem when custom classloader used which should probably deprecated instead supported 
SATD	 might fail hard here the assumption that something weird happened the daemon however since havent yet started running the build can recover just trying again 
SATD	 todo improve configuration reports 
SATD	 todo fix tests that rely this being set before process arguments like this 
SATD	 todo turn into set 
SATD	 theres potential problem here that reads from input the background this wont automatically stop when the process over therefore input not closed then this thread will run forever would better ensure that this thread stops when the process does 
SATD	 todo need better job routing messages when there are multiple endpoints this just going forward all queued messages the first waiting endpoint even there are multiple waiting work 
SATD	 create test suite component todo reuse logic from swiftplugin todo component name and extension name arent the same todo should use srcxctestswift the convention add the test suite and extension 
SATD	 not use this its here because some the services this type needs are not easily accessed certain cases and will removed some point use one the other methods instead 
SATD	 todo should validate that clazz non parameterized type 
SATD	 workaround for when the task given input file that doesnt exist 
SATD	 todo figure out how get rid origin scope snapshot outputs step 
SATD	 get rid the ivy token are not valid uri characters 
SATD	 todo remove this property once configuration can handle normal file system dependencies 
SATD	 this piece ugliness copies the jaxp xml api provider any from the system classloader heres why when looking for provider jaxp looks for service resource the context classloader which our isolated classloader our classpath above does not contain provider this returns null does contain provider jaxp extracts the classname from the service resource not found jaxp looks for service resource the system classloader this happens include all the application classes specified the classpath the application classpath does not contain provider this returns null does contain provider jaxp extracts the implementation classname from the service resource not found jaxp uses default classname jaxp attempts load the provider using the context classloader which our isolated classloader this fine the classname came from step blows the classname came from step workaround locate and make visible xml parser classes from the system classloader our isolated classloader note that practise this only triggered when running our tests 
SATD	 todo will implemented without hardcoded access for 
SATD	 todo this hardcodes the assumption compile configuration the external module instead should creating api configuration for each resolved module 
SATD	 this legacy quirk scans use this determine that progress logging indicating startfinish tasks this can removed gradle along with the concept logging category operation 
SATD	 see the comment taskcompleted above for why this here and why this problem 
SATD	 todo the special casing virtual platform should away can implement disambiguation variants for single component 
SATD	 todo this should actually extend from the api dependencies but since swift currently requires all dependencies treated like api dependencies with transitivity just use the implementation dependencies here see 
SATD	 todo replace this with jvmassembly once that type public 
SATD	 this not very nice might good enough until get rid and friends avoid traversing the graph causing the full resolveddependency graph loaded for the most typical scenario 
SATD	 not implemented not yet required please implement required 
SATD	 todo extract the nonfilesystem parts the into separate interface this isnt really tied file system watching just need another type waiter 
SATD	 todo this class sources gradle metadata files but theres corresponding for this metadata yet because this will generate empty instance either ivy maven based the repository type 
SATD	 todo this isnt correct assumes that side effect add the element 
SATD	 todo classes should little more tied the classesdirs for sourceset every plugin doesnt need this 
SATD	 this really not cool but cannot rely readattributes because will throw exception the file missing which really incredibly slow just determine file exists not 
SATD	 todo use twirl library instead 
SATD	 not use this constructor directly its only there for backwards compatibility with the nebula plugin 
SATD	 groovy does something very strange here for some reason probably because the class java wont employ any dynamism even implementing invokemethod the java level has effect 
SATD	 todo should see can back using httpclient again this implementation borrowed from the apache httpclient project 
SATD	 todo change set 
SATD	 tododaniel should support better way multi file invocation override this method have multi file invocation 
SATD	 todo refactor this task configuration extend copy task and use replace tokens 
SATD	 todoreuse refactor after removing reuse this horrendously bad need set the platform before the defaults rules nativebinaryrules assign the toolchain cant just assign the toolchain here because the initializer would closing over the toolchain which not reusable and this breaks model reuse here are just closing over the safely reusable things and then using proper dependencies for the tool chain registry unfortunately cant the create action because that would fire after defaults rules have use defaults rule assign the tool chain because needs there user mutate rules least the file locations that they can tweaked 
SATD	 check enum equality without checking loading classloader there slight risk that two versions the same enum class are compared thats why classloaders are used equality checks but checking both name and ordinal should make this very unlikely 
SATD	 todo version could different from main artifacts version 
SATD	 should really parameter the withcontent methods baked into the accessor 
SATD	 todo error messages todo display names for this container and the provider implementations 
SATD	 not subtypes dont know whether they are immutable not 
SATD	 todo this check should really done the compiler process 
SATD	 forced dependencies are only supported for enforced platforms currently hardcoded should want add this first class concept gradle metadata then should available the component variant metadata well 
SATD	 todo remove this attempt guess packaging from artifacts packaging should come from component explicitly set 
SATD	 was created during execution 
SATD	 todo deprecate and eventually prevent these mutations when already resolved 
SATD	 todo this doesnt quite guarantee immutability because the source may holding closures that are doing god knows what 
SATD	 todo get rid entirely and replace with collection link outputs 
SATD	 todo migrate this the worker api once the filesystem and fileoperations services can injected 
SATD	 todolptr have the paths the projects serve input maybe 
SATD	 this could handled just not implemented yet 
SATD	 todo wrong using the full classpath the application 
SATD	 this not very beautiful but some point will get rid favor the writable resource 
SATD	 this bit cheesy but letter classname surely means generic type and the warning will useless 
SATD	 creates instance the given task type without invoking its constructors this used recreate task instance from the instant execution cache review this 
SATD	 todo this selection should happen per target platform 
SATD	 todo resolve the javaplatform and scalaplatform from their platformresolvers rather than instantiating directly 
SATD	 todo should include some context what the rule was trying create mutate 
SATD	 todo get this from somewhere else 
SATD	 this here trigger creation the shutdowncoordinator could this nicer way 
SATD	 todopm move this when scope changed 
SATD	 todo outputeventlistener and buildstandardinput are perbuild settings down the road should refactor the code accordingly and potentially attach them 
SATD	 exposes methods for those properties whose value closure todo use composition instead inheritance 
SATD	 platform specific arguments todo need lazily configure compile task 
SATD	 this occurs while running gradle running integration tests indicative problem this occurs while running unit tests then either use the the usesnativeservices annotation 
SATD	 ugly but there are few places where need instantiate javadebugoptions and regular objectfactory service not available 
SATD	 todo adding the parent project first because the converter needs this way atm this oversimplified the converter should not depend the order reactor projects should add coverage for nested multiproject builds with multiple parents 
SATD	 theres possibility that this listener called concurrently with the build finished listener the message happens graceful expire one then theres large risk that create deadlock because were trying remove the same listener from different notifications avoid this just set the reference null which says that were taking care removing the listener 
SATD	 todo need track tool 
SATD	 this copied from ant see mentions that there bug the windows jdk impls that this valid workaround for ive been unable find definitive reference this bug the thinking that this good enough for ant its good enough for 
SATD	 todo change this only add swiftapi artifacts and instead parse modulemaps discover compile task inputs 
SATD	 rough implementation get something work 
SATD	 todo remove these special cases 
SATD	 todo this not great paradigm for creating temporary directory see for alternative 
SATD	 todo this should part the cached result 
SATD	 implementation currently dumb can made smarter 
SATD	 todorbo clarify what means and whats possible with todorbo can the return value always used resolve back the identified component how todorbo wouldnt better define proper type for projectmodel paths 
SATD	 todo this can throw npe will need identifier for variant without owning component 
SATD	 this implementation broken does not consider include and exclude patterns 
SATD	 todo lja using the root the nodestate here bit cheat investigate can track the proper nodestate 
SATD	 produces artifactidentifier for this artifact its not actually identifier just bucket attributes todoadam remove this 
SATD	 todo property order needs deterministic across jvm invocations sort the properties name 
SATD	 todo this will leave invalid types the cache when fails 
SATD	 should repositories able participate incremental the least they may able express themselves output files they might have input files and other dependencies well though inputs the credentials they need may expressed file dependencies cant think case here 
SATD	 todo have much better here 
SATD	 todo these should moved off separate type 
SATD	 todolptr this should defaults each 
SATD	 todo should refactor this general compatibility mapping solution have for model loading see class 
SATD	 this heuristic more than truth possible that the long hashs are identical and that the sizes collections are identical but its extremely unlikely never happened test cases even large dependency graph 
SATD	 failing seems that set method override doesnt work for iterables gradle assertthatcall bean list beanthingslist bean new linkedlistobject nullvalue equalto 
SATD	 todo this isnt quite right were leaking the implementation type here but for tasks this usually right 
SATD	 todo return richer data structure that provides meta data about how the source was found for use diagnostics 
SATD	 the configuration has been used resolution and error for build logic change any dependencies exclude rules parent configurations values that will affect the resolved graph 
SATD	 this method sometimes called directly not via operation executor these cases the context null 
SATD	 todolptr what with the metaclass property here 
SATD	 todo this doesnt belong here that java plugin should add extension this guy with this 
SATD	 need make this better 
SATD	 todo maybe need allow additional dirs like sourcesetoutput does esp for backwards compatibility wonder its still necessary distinguish between classes and resources dirs instead just maintaining collection dirs far generated resources are concerned might better model them additional buildable resourceset 
SATD	 workaround for bug testng apparently fixed some listener notified twice per event 
SATD	 todo this isnt correct this means that weve detected cycle while determining the execution plan but the graph walker did not find one 
SATD	 todocedric the following validation should theory happen its own rule but not possible now because theres way iterate the map subject validate rule without gradle thinking youre trying mutate 
SATD	 todo simplify this class busting into locator for legacy sdks and locators for windows kits 
SATD	 todo this all terribly lame need some proper reporting here which means implementing reporting 
SATD	 todo implement these cases 
SATD	 tododaniel swift compiler should extends from abstraction nativecompiler most applies swiftcompiler 
SATD	 todo should use target platform make this decision 
SATD	 todo there should more explicit way execute action against existing services 
SATD	 have unprocessednew selector for this module need reselect the target version 
SATD	 todo assets should probably source set too 
SATD	 use the class generator instead 
SATD	 todo implement this moving this resolver live alongside the external resolvers 
SATD	 todo this should use the same mutationvalidator infrastructure that use for other mutation types 
SATD	 todo should just cache these classloaders and ejectstop them when they are longer use 
SATD	 todo should self closed 
SATD	 todolptr should collect all source sets the project source set however this messes 
SATD	 todo only log expired workers count log their identity once they are nameabledescribable 
SATD	 todo this not nice work out better way collect the plugin requests from invoking the plugins block 
SATD	 todo this braindead way ensure that the reference projects model ready access 
SATD	 todo this not quite right given aabb the result should and but will fact and 
SATD	 the very first event starts the initializing phase todo should use determine the build start time 
SATD	 one should really avoid using this constructor totally inefficient and reserved spurious cases when the components have dots names and this can happen task name contains dots 
SATD	 todo bust this hierarchy and compose using interfaces instead 
SATD	 simulate stuck worker theres probably way inject this failure 
SATD	 todo this should outgoing variant the component under test 
SATD	 add install task todo should probably not add this for all executables 
SATD	 todolptr why dont check runningnodes here like hasnodesremaining 
SATD	 dumb terminal doesnt support ansi control codes todo remove this when use terminal rather than jansi render console 
SATD	 this workaround for several early typed operations have buildpath property the value which can only determined after the settings file for the build has loaded the workaround buffer all operation notifications memory until the root builds settings have loaded this works because all possible settings files have been evaluated the time the root one has been this not guaranteed hold into the future proper solution would change the operation detailsresults truly immutable and convey values known the time 
SATD	 amount immutable value some quantity such duration length each amount has decimal value and associated units todo need sort out scaling when dividing converting between units 
SATD	 todo move this propertyvalue instead 
WITHOUT_CLASSIFICATION	 trailing slash name indicates that entry directory 
WITHOUT_CLASSIFICATION	 allow organisation synonyms like org organization 
WITHOUT_CLASSIFICATION	 include expression ignore 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 noop 
WITHOUT_CLASSIFICATION	 node was previously traversed need remove outgoing edges 
WITHOUT_CLASSIFICATION	 simple scheme just present the public type the container 
WITHOUT_CLASSIFICATION	 nullable reference 
WITHOUT_CLASSIFICATION	 always publish 
WITHOUT_CLASSIFICATION	 maven supports wildcards exclusion rules according this should used for nontransitive dependencies 
WITHOUT_CLASSIFICATION	 returns approximation composite variant 
WITHOUT_CLASSIFICATION	 have some batched conflicts resolve the first and continue traversing the graph 
WITHOUT_CLASSIFICATION	 each build request carries its own log level and used during the execution the build see logtoclient 
WITHOUT_CLASSIFICATION	 implementation note only necessary override visit methods for ast nodes that reference statements for closureexpression rely the assumption that always references blockstatement and hence our visitblockstatement method gets called 
WITHOUT_CLASSIFICATION	 workspace scope expected persisted the project cache dir since 
WITHOUT_CLASSIFICATION	 register eagerly stop triggered when services are being stopped 
WITHOUT_CLASSIFICATION	 may have ckv should become ckv 
WITHOUT_CLASSIFICATION	 construct new compileroptions class 
WITHOUT_CLASSIFICATION	 add publictype 
WITHOUT_CLASSIFICATION	 swap the foreground and background bits 
WITHOUT_CLASSIFICATION	 configure the component 
WITHOUT_CLASSIFICATION	 this called from the download thread only forward the events when not cancelled 
WITHOUT_CLASSIFICATION	 this insanity needed for the case where someone calls someplugin that the plugin container has the instance that want but dont think cant know has been applied 
WITHOUT_CLASSIFICATION	 register the projects source set output directories 
WITHOUT_CLASSIFICATION	 scheme means someone passed relative url our context only file relative urls make sense 
WITHOUT_CLASSIFICATION	 sha not part coreservices hashingsha available hence use plain guava classes here 
WITHOUT_CLASSIFICATION	 anything other than propertyexpressions variableexpressions will stop resolving 
WITHOUT_CLASSIFICATION	 delimiter dot swap grouptoken otherwise the rest belongs qualifier 
WITHOUT_CLASSIFICATION	 generate 
WITHOUT_CLASSIFICATION	 ignore the rule expects ivy metadata and this isnt ivy module 
WITHOUT_CLASSIFICATION	 missing files can ignored 
WITHOUT_CLASSIFICATION	 matches task identifier operator expression task string operator expression map operator expression operator expression 
WITHOUT_CLASSIFICATION	 overlap cry 
WITHOUT_CLASSIFICATION	 copyprocessingspec overrides broaden return type 
WITHOUT_CLASSIFICATION	 assume individual files have dependencies 
WITHOUT_CLASSIFICATION	 for testing 
WITHOUT_CLASSIFICATION	 local component that provides jvm assembly 
WITHOUT_CLASSIFICATION	 hold other project locks that should release first 
WITHOUT_CLASSIFICATION	 retain buffer there capacity the queue otherwise discard 
WITHOUT_CLASSIFICATION	 sort source files work around 
WITHOUT_CLASSIFICATION	 macro includes were seen the include graph this file the result can reused this file seen again 
WITHOUT_CLASSIFICATION	 use injected objectfactory create server object 
WITHOUT_CLASSIFICATION	 todoadam switch the logging back loggerdebugignoring failure extract throwable cause ignored 
WITHOUT_CLASSIFICATION	 windows and are separators unix only separator 
WITHOUT_CLASSIFICATION	 discard the body when the expression not resolvable 
WITHOUT_CLASSIFICATION	 groovy this check the hierarchy needed 
WITHOUT_CLASSIFICATION	 todo add stripped symbols the installation 
WITHOUT_CLASSIFICATION	 matches task closure 
WITHOUT_CLASSIFICATION	 take snapshot while holding lock 
WITHOUT_CLASSIFICATION	 todo all this matching stuff constant for given dependencymetadata instance 
WITHOUT_CLASSIFICATION	 delegate copyspec methods rootspec 
WITHOUT_CLASSIFICATION	 matches task identifier closure 
WITHOUT_CLASSIFICATION	 only for relative positioning 
WITHOUT_CLASSIFICATION	 capture changes execution outcome 
WITHOUT_CLASSIFICATION	 mark this listener type being notified 
WITHOUT_CLASSIFICATION	 register logger support this being replaced build logic 
WITHOUT_CLASSIFICATION	 fallback failing the task case dont know anything special about the error 
WITHOUT_CLASSIFICATION	 notify caches that lock released the caches may work the cache files during this 
WITHOUT_CLASSIFICATION	 dont list versions for gradlemetadata mavenmetadataxml will checked 
WITHOUT_CLASSIFICATION	 since have and want get start with the most outer class put them together and then see that does already exist case from within are done after the first step already case for example abcdef and accessing from test aefailed abefailed abcefail abcdesuccess 
WITHOUT_CLASSIFICATION	 not supported use two spaces instead 
WITHOUT_CLASSIFICATION	 short circuit logic when only candidates 
WITHOUT_CLASSIFICATION	 similar way ivy maven may use other hosts for additional artifacts but not poms 
WITHOUT_CLASSIFICATION	 todo get normal resolving set declaring class 
WITHOUT_CLASSIFICATION	 copy case any actions mutate the store 
WITHOUT_CLASSIFICATION	 would normally log lower level than lifecycle but the ant message priority actually higher than equal the set lifecycle log level 
WITHOUT_CLASSIFICATION	 producer doesnt declare anything assume that only provides the implicit capability 
WITHOUT_CLASSIFICATION	 source dir already the start the path just use the include path 
WITHOUT_CLASSIFICATION	 configuration artifacts are determined locally 
WITHOUT_CLASSIFICATION	 can discard the state required create instance 
WITHOUT_CLASSIFICATION	 for stats dont really care about thread safety 
WITHOUT_CLASSIFICATION	 mutable 
WITHOUT_CLASSIFICATION	 parent were done 
WITHOUT_CLASSIFICATION	 skip visitor not interested 
WITHOUT_CLASSIFICATION	 complete cancelling key 
WITHOUT_CLASSIFICATION	 noinspection 
WITHOUT_CLASSIFICATION	 library albeit only for selected classes that run high risk being statically referenced from transform 
WITHOUT_CLASSIFICATION	 generate public type getter return field 
WITHOUT_CLASSIFICATION	 generate private dynamicobject dynamicobjecthelper 
WITHOUT_CLASSIFICATION	 always treat nonempty 
WITHOUT_CLASSIFICATION	 the type the property node instead 
WITHOUT_CLASSIFICATION	 the failure handler rethrows exception then execution other nodes aborted continue will collect failures 
WITHOUT_CLASSIFICATION	 exclude rules for dependency specified gradle dsl 
WITHOUT_CLASSIFICATION	 create processor that processes events its own thread 
WITHOUT_CLASSIFICATION	 only consider one candidate because means that theres ambiguity the version number 
WITHOUT_CLASSIFICATION	 not required but guavas performance bad for empty immutable list 
WITHOUT_CLASSIFICATION	 unsupported this transformer 
WITHOUT_CLASSIFICATION	 always schedule the generation task after the clean task 
WITHOUT_CLASSIFICATION	 theres more than one module merge them into module set 
WITHOUT_CLASSIFICATION	 some impls support this but not 
WITHOUT_CLASSIFICATION	 any the child strategies dont expire the daemon the daemon will not expire otherwise the daemon will expire and aggregate the reasons together 
WITHOUT_CLASSIFICATION	 means the registry didnt exist yet 
WITHOUT_CLASSIFICATION	 not supported 
WITHOUT_CLASSIFICATION	 there transform for the language into one the component inputs add default source set 
WITHOUT_CLASSIFICATION	 allows individual identification for debugging 
WITHOUT_CLASSIFICATION	 only print first gradle script stack trace element 
WITHOUT_CLASSIFICATION	 finalizing here need this run after any assembling task jar link etc created todo convert this binarytasks when model nativeassembly instead wiring compile tasks directly linktask 
WITHOUT_CLASSIFICATION	 never use empty settings when the settings were explicitly set 
WITHOUT_CLASSIFICATION	 need double check that the target still has hard edges 
WITHOUT_CLASSIFICATION	 will only add dependencies the leaves there such published module 
WITHOUT_CLASSIFICATION	 dont bother searching remotely 
WITHOUT_CLASSIFICATION	 disallow classes from groovy jar that reference external classes such classes must loaded from will occur essentially this drawing line between the groovy compiler and the groovy 
WITHOUT_CLASSIFICATION	 when provider used task dependency rather than task input need unpack the value 
WITHOUT_CLASSIFICATION	 metadata builder uses mutable project state synchronize access the project state 
WITHOUT_CLASSIFICATION	 this special case for maven snapshots with gradle module metadata when need remap the file name which corresponds the unique timestamp the snapshot version for backwards compatibility 
WITHOUT_CLASSIFICATION	 part strongly connected component cycle move values root the component the root the first node the component encountered 
WITHOUT_CLASSIFICATION	 add getname 
WITHOUT_CLASSIFICATION	 remove all the classes other than the main class 
WITHOUT_CLASSIFICATION	 necessary for groovy compilation pick output regular and joint java compilation and for joint java compilation pick the output regular java compilation assumes that output regular java compilation which not under this tasks control also goes into could configure this source set level but then would end the compile class path every compile task for that source set which may not desirable 
WITHOUT_CLASSIFICATION	 call directly the delegate avoid some dynamic dispatch 
WITHOUT_CLASSIFICATION	 need sort here since the file order obtained from the filesystem can change between machines and always want have the same shaded jars 
WITHOUT_CLASSIFICATION	 check that the object has already been serialized 
WITHOUT_CLASSIFICATION	 this configuration cannot mutated but some parent configurations provide artifacts 
WITHOUT_CLASSIFICATION	 this one should away once complete the autoapply plugins 
WITHOUT_CLASSIFICATION	 note aether implicitly uses thread pool and tasks perform transfers manually propagate the current build operation ref logging correctly associated 
WITHOUT_CLASSIFICATION	 throw new viewtypeclass 
WITHOUT_CLASSIFICATION	 generate getinstantiator 
WITHOUT_CLASSIFICATION	 find the candidates with the highest base version 
WITHOUT_CLASSIFICATION	 hold the lock until actually start accepting connections for the case when stop called from another thread while are the middle here 
WITHOUT_CLASSIFICATION	 the platform itself greater than the forced version 
WITHOUT_CLASSIFICATION	 generate 
WITHOUT_CLASSIFICATION	 replace result fail warning 
WITHOUT_CLASSIFICATION	 find and remove common prefix 
WITHOUT_CLASSIFICATION	 serialize the worker implementation classpath this consumed gradleworkermain 
WITHOUT_CLASSIFICATION	 else might link which points nothing has been removed while were visiting 
WITHOUT_CLASSIFICATION	 try configure element 
WITHOUT_CLASSIFICATION	 returns whether the transformer can transform these arguments all 
WITHOUT_CLASSIFICATION	 not check for opaque properties when implementing propertymixin this expensive 
WITHOUT_CLASSIFICATION	 this does almost the same thing passing through those make some assumptions about allowed attribute value types that cant serialize everything else string instead 
WITHOUT_CLASSIFICATION	 dont adjust the column value the event unwrap want keep correctness 
WITHOUT_CLASSIFICATION	 see the grammar outofdate way its importvocab 
WITHOUT_CLASSIFICATION	 only way know determine current log level 
WITHOUT_CLASSIFICATION	 todo reuse more 
WITHOUT_CLASSIFICATION	 serialize the actual security manager type this consumed 
WITHOUT_CLASSIFICATION	 the accumulated exclusions that apply this edge based the path from the root 
WITHOUT_CLASSIFICATION	 prefix internal fields with that they dont get into the way propertymissing 
WITHOUT_CLASSIFICATION	 todo validate that the plugin accepts this kind argument 
WITHOUT_CLASSIFICATION	 must some unix variant including cygwin msys windows 
WITHOUT_CLASSIFICATION	 guard against testng calling this hook more than once with the same testclass see for details 
WITHOUT_CLASSIFICATION	 parallel configuration 
WITHOUT_CLASSIFICATION	 should not reach this point this validated the test framework implementation just propagate the failure 
WITHOUT_CLASSIFICATION	 consumer expressed preference defaults library 
WITHOUT_CLASSIFICATION	 order significant injection handler should the end 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 queue this for checking again later 
WITHOUT_CLASSIFICATION	 all these field names are really long prevent collisions with the groovy setters groovy will try set the private fields given the opportunity this makes much more difficult for this happen accidentally 
WITHOUT_CLASSIFICATION	 get any errors from the compiler result 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 try infer the effective jvm options for the currently running process only care about managed jvm args anything else unimportant the running build 
WITHOUT_CLASSIFICATION	 add the library and extension 
WITHOUT_CLASSIFICATION	 should use projectstate instead 
WITHOUT_CLASSIFICATION	 the graph contains firstlevel dependencies which have been substituted likely were going iterate dependencies instead 
WITHOUT_CLASSIFICATION	 reuse the same version last build 
WITHOUT_CLASSIFICATION	 used just test the mechanism 
WITHOUT_CLASSIFICATION	 add incoming artifact transforms 
WITHOUT_CLASSIFICATION	 this should live closer the project itself 
WITHOUT_CLASSIFICATION	 daemon process has started yet 
WITHOUT_CLASSIFICATION	 treat everything else single file 
WITHOUT_CLASSIFICATION	 todo add deprecation warning gradle 
WITHOUT_CLASSIFICATION	 convert once order write the ivy descriptor with all configurations 
WITHOUT_CLASSIFICATION	 outputs file 
WITHOUT_CLASSIFICATION	 build tasks without project reference 
WITHOUT_CLASSIFICATION	 xctest executable sync the binary the builtproductsdir otherwise xcode wont find any tests 
WITHOUT_CLASSIFICATION	 supplied java location 
WITHOUT_CLASSIFICATION	 cant discover the version from the normal metadata make some assumptions 
WITHOUT_CLASSIFICATION	 create tasks for solutions projects and filters 
WITHOUT_CLASSIFICATION	 this loop builds name from right left each name part separated 
WITHOUT_CLASSIFICATION	 args 
WITHOUT_CLASSIFICATION	 else continue below 
WITHOUT_CLASSIFICATION	 rename linuxmainswift mainswift the entry point correctly detected swiftc 
WITHOUT_CLASSIFICATION	 class results may created earlier where dont yet have access the start time 
WITHOUT_CLASSIFICATION	 add the end the queue that traverse the graph breadthwise order pick many conflicts possible before attempting resolve them 
WITHOUT_CLASSIFICATION	 use the index here can apply any filters the realized element 
WITHOUT_CLASSIFICATION	 this work has done before classes are loaded otherwise there are risks that the permgen space full before create the reflection methods 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 parallel safe version 
WITHOUT_CLASSIFICATION	 visit the method call because one the args may input method call 
WITHOUT_CLASSIFICATION	 cant close replaced loaders immediately because their classes may used during shutdown after the return the reload call that caused the loader swapped out have way knowing when the loader actually done with use the request after the request that triggered the reload the trigger point close the replaced loader 
WITHOUT_CLASSIFICATION	 matches task methodcall operator expression 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 case the output event arrives after completion the test and need have matching descriptor inform the user which test this output belongs will use the current parent 
WITHOUT_CLASSIFICATION	 generate documentation 
WITHOUT_CLASSIFICATION	 this hidden property that may useful track down issues remove when ntlm auth solid 
WITHOUT_CLASSIFICATION	 should not happen when reading from stringreader 
WITHOUT_CLASSIFICATION	 generate private metaclass metaclass 
WITHOUT_CLASSIFICATION	 reach this point means have dependency which doesnt belong the resolution result which can mean two things 
WITHOUT_CLASSIFICATION	 wrap the processor actor make threadsafe 
WITHOUT_CLASSIFICATION	 from this point down logging sent back the client 
WITHOUT_CLASSIFICATION	 java source files are supported too therefore should care about the relative path 
WITHOUT_CLASSIFICATION	 show any contextual cause recursively 
WITHOUT_CLASSIFICATION	 use arbitrary ordering when the artifacts have the same public attributes 
WITHOUT_CLASSIFICATION	 other home dir cached and not use clean 
WITHOUT_CLASSIFICATION	 were making assumption here that the targets plugin registry backed classloaderscope because are only buildgradle files right now this holds 
WITHOUT_CLASSIFICATION	 build configuration for gradleworkermain 
WITHOUT_CLASSIFICATION	 start logging now that the logging manager connected 
WITHOUT_CLASSIFICATION	 first try resolve the artifacts locally before going remote 
WITHOUT_CLASSIFICATION	 add the front the queue flush out configurations that are longer required 
WITHOUT_CLASSIFICATION	 controls when disable reading default authentication credentials should used tests only 
WITHOUT_CLASSIFICATION	 the jansiforce property set then force output 
WITHOUT_CLASSIFICATION	 using the test sources feature introduced eclipse photon 
WITHOUT_CLASSIFICATION	 flaky 
WITHOUT_CLASSIFICATION	 mix some groovy dsl support should decorate instead 
WITHOUT_CLASSIFICATION	 dont care 
WITHOUT_CLASSIFICATION	 service calls have effect need register them 
WITHOUT_CLASSIFICATION	 just serialize string best can 
WITHOUT_CLASSIFICATION	 create visual studio project extensions 
WITHOUT_CLASSIFICATION	 see 
WITHOUT_CLASSIFICATION	 run the build and get the build outcomes model 
WITHOUT_CLASSIFICATION	 done 
WITHOUT_CLASSIFICATION	 reach into meta class avoid lookup 
WITHOUT_CLASSIFICATION	 windows least will sometimes throw odd exceptions like the file gets deleted while the watch being set 
WITHOUT_CLASSIFICATION	 verify that the parsed descriptor the correct parent module 
WITHOUT_CLASSIFICATION	 need attach failures unattached dependencies too case node wasnt selected all but still want see error message for 
WITHOUT_CLASSIFICATION	 for now only create test suites for static library variants 
WITHOUT_CLASSIFICATION	 well get this when try look programfilesdir bit 
WITHOUT_CLASSIFICATION	 serialize configuration for the worker process stdin 
WITHOUT_CLASSIFICATION	 nonjavadoc see 
WITHOUT_CLASSIFICATION	 only use this for top level init scripts 
WITHOUT_CLASSIFICATION	 never date dont understand the data structures 
WITHOUT_CLASSIFICATION	 todo combine these with mutationguard 
WITHOUT_CLASSIFICATION	 setup the default configurations used when mapping resolved versions 
WITHOUT_CLASSIFICATION	 very dumb strategy for invalidating cache 
WITHOUT_CLASSIFICATION	 there chance could not attach target configurations previously 
WITHOUT_CLASSIFICATION	 add the gradle api filter between the user classloader and the worker infrastructure classloader 
WITHOUT_CLASSIFICATION	 need consistent index here 
WITHOUT_CLASSIFICATION	 object converted floatclass false 
WITHOUT_CLASSIFICATION	 read body 
WITHOUT_CLASSIFICATION	 mixed case 
WITHOUT_CLASSIFICATION	 always expand empty node 
WITHOUT_CLASSIFICATION	 dependency artifact will defined the descriptor specified classifier nondefault type attribute 
WITHOUT_CLASSIFICATION	 stream has been closed dont bother reading anything else 
WITHOUT_CLASSIFICATION	 only care about http hosts right now 
WITHOUT_CLASSIFICATION	 call return new implclassparam 
WITHOUT_CLASSIFICATION	 listen for the end configuration the root project the root build and discard buffered notifications listeners have yet appeared this avoids buffering until the end the build when listener comes 
WITHOUT_CLASSIFICATION	 assume that test has renamed itself this can actually happen 
WITHOUT_CLASSIFICATION	 expire recently unused daemons when memory pressure high 
WITHOUT_CLASSIFICATION	 findbugs cannot handle missing directories 
WITHOUT_CLASSIFICATION	 only count noncreate events since creation also causes modification event unless the event for directory 
WITHOUT_CLASSIFICATION	 retain strong reference 
WITHOUT_CLASSIFICATION	 augment the environment for the execution 
WITHOUT_CLASSIFICATION	 transient dont serialize all the views that happen have been visited recreate them when visited via the deserialized view 
WITHOUT_CLASSIFICATION	 some implementation uses null represent bootstrap classloader 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 ignore currently the actions dont need run its just better they the time this node notified that the task the other build has completed its too late run the action instead the action should attached the task the other build rather than here 
WITHOUT_CLASSIFICATION	 here will distribute and only least one the distribution operations can simplified 
WITHOUT_CLASSIFICATION	 find the nearest parent that care about and use that the parent 
WITHOUT_CLASSIFICATION	 when the outputs are generated throw away all state for files that not live appendonly cache this intentionally very simple improved later 
WITHOUT_CLASSIFICATION	 and class property 
WITHOUT_CLASSIFICATION	 launchable created the provider just hand back 
WITHOUT_CLASSIFICATION	 must run each action 
WITHOUT_CLASSIFICATION	 the other better current not part result 
WITHOUT_CLASSIFICATION	 this shouldnt happen resolvers should call notfound 
WITHOUT_CLASSIFICATION	 redirect stderr stdout when both stdout and stderr are attached console assume that they are attached the same console this avoids interleaving problems when stdout and stderr end the same location 
WITHOUT_CLASSIFICATION	 gettype 
WITHOUT_CLASSIFICATION	 should get back some kind reference that can queried below instead looking the task every time 
WITHOUT_CLASSIFICATION	 this the root block can have any number children 
WITHOUT_CLASSIFICATION	 there are enough entries this block and the left sibling make blocks redistribute the entries evenly between them 
WITHOUT_CLASSIFICATION	 the deployment descriptor already exists need generate 
WITHOUT_CLASSIFICATION	 nonjavadoc see 
WITHOUT_CLASSIFICATION	 generate 
WITHOUT_CLASSIFICATION	 sanitise the exception and report 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 return the group use for the given build operation searching the build operation hierarchy for the first group 
WITHOUT_CLASSIFICATION	 split line single line goes over 
WITHOUT_CLASSIFICATION	 intentionally not the text 
WITHOUT_CLASSIFICATION	 which case output stay compatible with existing builds that scan the script for 
WITHOUT_CLASSIFICATION	 resolving project component can cause traversal other projects which point could release the project lock and allow another task run cant use cache loader here because synchronized the other task also tries resolve project component can block trying get the lock around the loader while still holding the project lock avoid this deadlock check then release the project lock only need resolve the project and ensure that only the thread holding the lock can populate the metadata for project 
WITHOUT_CLASSIFICATION	 the name type remove from the scoping only classvariable only but must removed for each parentscope too 
WITHOUT_CLASSIFICATION	 layout 
WITHOUT_CLASSIFICATION	 add any finalizers the queue 
WITHOUT_CLASSIFICATION	 know all are compatibles this only possible some disambiguation happens but not getting candidate 
WITHOUT_CLASSIFICATION	 should this null 
WITHOUT_CLASSIFICATION	 procmeminfo since linux see 
WITHOUT_CLASSIFICATION	 because the same suffix used for all decorating class generator instances share the same cache well 
WITHOUT_CLASSIFICATION	 check directory already watched windows check any parent already watched 
WITHOUT_CLASSIFICATION	 should really fail here sourcestocompile not empty transform for this source set this binary 
WITHOUT_CLASSIFICATION	 include the shortest path from each version that has direct dependency the broken dependency back the root 
WITHOUT_CLASSIFICATION	 ignore the subkey doesnt have folder and version 
WITHOUT_CLASSIFICATION	 directly printing the stream avoid log level filtering 
WITHOUT_CLASSIFICATION	 the song and dance with actionrunnable ease testing see 
WITHOUT_CLASSIFICATION	 add dependencies the start the queue 
WITHOUT_CLASSIFICATION	 end element marker 
WITHOUT_CLASSIFICATION	 when 
WITHOUT_CLASSIFICATION	 dont configure anything 
WITHOUT_CLASSIFICATION	 target arm 
WITHOUT_CLASSIFICATION	 add absent 
WITHOUT_CLASSIFICATION	 generate private conventionmapping mapping 
WITHOUT_CLASSIFICATION	 initialize matchers once and then reset them for performance 
WITHOUT_CLASSIFICATION	 project has publications simply use the project name place the dependency name 
WITHOUT_CLASSIFICATION	 only add confs they are specified they arent endelement will handle this 
WITHOUT_CLASSIFICATION	 this second check only done that can make the difference between uninitialized rule never seen before and rule which not reusable 
WITHOUT_CLASSIFICATION	 thisgetservices 
WITHOUT_CLASSIFICATION	 currently visiting the successor node were cycle 
WITHOUT_CLASSIFICATION	 for gradle distribution specific dependencies 
WITHOUT_CLASSIFICATION	 handle anyof first because dont want special case every other case 
WITHOUT_CLASSIFICATION	 adds void propnameclosure method that executes the closure 
WITHOUT_CLASSIFICATION	 stopping result doesnt really matter 
WITHOUT_CLASSIFICATION	 more information 
WITHOUT_CLASSIFICATION	 configurations are built ondemand but only once 
WITHOUT_CLASSIFICATION	 have enough local data make comparison get the remote metadata 
WITHOUT_CLASSIFICATION	 not resolve vanilla name starting with lower case letter try resolve against default import because know that the 
WITHOUT_CLASSIFICATION	 launchable synthesized the consumer unpack into set task names 
WITHOUT_CLASSIFICATION	 offset based implementation only safe certain figure because the int max value for large streamsfiles huge builds need roll the file 
WITHOUT_CLASSIFICATION	 todo deal with more than one directory 
WITHOUT_CLASSIFICATION	 private member implementation details 
WITHOUT_CLASSIFICATION	 dont inline the groovy jar the groovy tools locator searches for name 
WITHOUT_CLASSIFICATION	 todoadam switch the logging back loggerdebugignoring failure serialize throwable ignored 
WITHOUT_CLASSIFICATION	 min chunk size max size 
WITHOUT_CLASSIFICATION	 for updates private jdk caches the environment state 
WITHOUT_CLASSIFICATION	 set the system properties and use this process 
WITHOUT_CLASSIFICATION	 was updated during execution 
WITHOUT_CLASSIFICATION	 foreground daemon cannot told whats his startup options the client sits the same process will infer the jvm opts from the inputarguments 
WITHOUT_CLASSIFICATION	 round nearest second 
WITHOUT_CLASSIFICATION	 thisfield value 
WITHOUT_CLASSIFICATION	 configure the included build discover available modules 
WITHOUT_CLASSIFICATION	 initialize sslcontext 
WITHOUT_CLASSIFICATION	 flags can not set the option file add additional option files 
WITHOUT_CLASSIFICATION	 use the max heap approximation 
WITHOUT_CLASSIFICATION	 collect artifact sets list using the the set its index the list 
WITHOUT_CLASSIFICATION	 errors get the compiled source and write the destination file 
WITHOUT_CLASSIFICATION	 for now required and preferred are treated the same 
WITHOUT_CLASSIFICATION	 does not need redrawn component out bound 
WITHOUT_CLASSIFICATION	 prevent construction 
WITHOUT_CLASSIFICATION	 the removal the method will reported the removed methods will reported the added methods will reported 
WITHOUT_CLASSIFICATION	 know that defaultscript friends dont have uservisible nested types dont try look nonsensical types like 
WITHOUT_CLASSIFICATION	 dont know what the type let guava take care 
WITHOUT_CLASSIFICATION	 query the declared methods the meta class 
WITHOUT_CLASSIFICATION	 check interfaces this level first 
WITHOUT_CLASSIFICATION	 could different ids the requests they may unqualified 
WITHOUT_CLASSIFICATION	 could potentially also look whether have the details for ancestor directory tree could possibly infer that the path refers directory have details for descendant path and its not missing file 
WITHOUT_CLASSIFICATION	 set configuration named antlr for the user specify the antlr libs use case they want specific version etc 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 this will propagate through the graph and prune configurations that are longer required 
WITHOUT_CLASSIFICATION	 keying the failures only requested lose some precision edge case well lose info about different exception have different failure for the same requested version 
WITHOUT_CLASSIFICATION	 wait for open 
WITHOUT_CLASSIFICATION	 serialize the application classpath this consumed 
WITHOUT_CLASSIFICATION	 todo all methods 
WITHOUT_CLASSIFICATION	 check module node imports aliases the while loop enables check for inner classes which are not fully imported 
WITHOUT_CLASSIFICATION	 this situation occurs when there was branch defined the original dependency descriptor the dynamicid shouldnt contain branch neither 
WITHOUT_CLASSIFICATION	 todo honor changes build directory 
WITHOUT_CLASSIFICATION	 the target component exists need fallback the traditional selection process 
WITHOUT_CLASSIFICATION	 happens when dispatching taskdef via createnode 
WITHOUT_CLASSIFICATION	 sane enough 
WITHOUT_CLASSIFICATION	 retain strong references the values created for this session 
WITHOUT_CLASSIFICATION	 configure test binary compile against binary under test 
WITHOUT_CLASSIFICATION	 this task uses precompiled header 
WITHOUT_CLASSIFICATION	 only define scala sdk for module could create scalasdklibrary 
WITHOUT_CLASSIFICATION	 flushing data split across previous and current appending 
WITHOUT_CLASSIFICATION	 generate public dynamicobject getasdynamicobject 
WITHOUT_CLASSIFICATION	 todo publishing for test executable 
WITHOUT_CLASSIFICATION	 skip things that arent files 
WITHOUT_CLASSIFICATION	 next character not separator 
WITHOUT_CLASSIFICATION	 need run operation under cache lock 
WITHOUT_CLASSIFICATION	 total number garbage collection events observed the window 
WITHOUT_CLASSIFICATION	 buckets dependencies 
WITHOUT_CLASSIFICATION	 force loading check method handle supported 
WITHOUT_CLASSIFICATION	 wrap generic build failed cross version exception 
WITHOUT_CLASSIFICATION	 otherwise macro macro function call 
WITHOUT_CLASSIFICATION	 cant equal otherwise wouldnt have been collected 
WITHOUT_CLASSIFICATION	 todo reuse more buildactionsfactory 
WITHOUT_CLASSIFICATION	 configure test binary link against tested component compiled objects 
WITHOUT_CLASSIFICATION	 use writefile because the cache can internally recover from datafile corruption dont care this level its corrupt 
WITHOUT_CLASSIFICATION	 exit value unreliable for determination process failure 
WITHOUT_CLASSIFICATION	 setup the dependency the main binary this should all replaced single dependency that points some testable variants the main binary 
WITHOUT_CLASSIFICATION	 todo consider entryattributes equals hashcode and tostring 
WITHOUT_CLASSIFICATION	 invokemethodthis name args 
WITHOUT_CLASSIFICATION	 used the kotlin plugin 
WITHOUT_CLASSIFICATION	 last entry complete the result 
WITHOUT_CLASSIFICATION	 class consisting vanilla name can never static inner class because least one dot required for this example foobar foobar 
WITHOUT_CLASSIFICATION	 copy selection failure 
WITHOUT_CLASSIFICATION	 its almost always the same attribute sets which are compared order avoid lot memory allocation during computation the intersection cache the result here 
WITHOUT_CLASSIFICATION	 pullonly always comes first 
WITHOUT_CLASSIFICATION	 look for model call model with anything other than non literal closure 
WITHOUT_CLASSIFICATION	 authoritative result dont need try remote 
WITHOUT_CLASSIFICATION	 some checks upfront avoid creating the queue most cases cases want handle liststring class listclass integer extends basetype class 
WITHOUT_CLASSIFICATION	 create the listener adapters right when the are instantiated but earlier this ensures that when multiple requests are issued that are built from the same builder such requests not share any state kept the listener adapters the listener adapters perrequest caching such caching must not leak between different requests built from the same builder 
WITHOUT_CLASSIFICATION	 snapshot the state and notify the caches 
WITHOUT_CLASSIFICATION	 currently not required 
WITHOUT_CLASSIFICATION	 todo synchronization 
WITHOUT_CLASSIFICATION	 were sorting the names the configurations and later attributes make sure the output consistently the same between invocations 
WITHOUT_CLASSIFICATION	 dont forward 
WITHOUT_CLASSIFICATION	 allow only certain things from the underlying classloader 
WITHOUT_CLASSIFICATION	 dont add our last record has taskname status and this one taskname something 
WITHOUT_CLASSIFICATION	 assume that each artifact points unique file and use the relative path from the project the 
WITHOUT_CLASSIFICATION	 matches task identifier arglist task string arglist map taskidentifier arglist taskstring arglist 
WITHOUT_CLASSIFICATION	 remove license files that cause collisions between license file and license directory 
WITHOUT_CLASSIFICATION	 expiration strategies exist the daemon will not expire 
WITHOUT_CLASSIFICATION	 overwrite rather than append libraries 
WITHOUT_CLASSIFICATION	 lets see can find single variant which has exactly the requested artifacts 
WITHOUT_CLASSIFICATION	 check see there are any compatible canceled daemons and wait see one becomes idle 
WITHOUT_CLASSIFICATION	 count every event osx 
WITHOUT_CLASSIFICATION	 info about the owning task can inferred and dont provide any further info this point this largely expose timing information about executed tasks 
WITHOUT_CLASSIFICATION	 assume 
WITHOUT_CLASSIFICATION	 dont bother trying handle primitive arrays specially 
WITHOUT_CLASSIFICATION	 attempt merge with the left sibling 
WITHOUT_CLASSIFICATION	 for command file format see use platform character and line encoding 
WITHOUT_CLASSIFICATION	 this can happen windows 
WITHOUT_CLASSIFICATION	 fully visit the class hierarchy before any interfaces order meet the contract etc 
WITHOUT_CLASSIFICATION	 caches 
WITHOUT_CLASSIFICATION	 current selection for module just use the candidate 
WITHOUT_CLASSIFICATION	 running the task requires access the tasks owning project 
WITHOUT_CLASSIFICATION	 all the values are equal but store all the binaries that match that value and incrementally build list binaries which are excluded because better match 
WITHOUT_CLASSIFICATION	 store thrown exception 
WITHOUT_CLASSIFICATION	 lock demand 
WITHOUT_CLASSIFICATION	 not the same provider 
WITHOUT_CLASSIFICATION	 already completed 
WITHOUT_CLASSIFICATION	 encode ascii 
WITHOUT_CLASSIFICATION	 another process may have already copied the compiler interface jar avoid copying over same existing file avoid locking problems 
WITHOUT_CLASSIFICATION	 lock use mark contended 
WITHOUT_CLASSIFICATION	 handles both junctions and real symlinks 
WITHOUT_CLASSIFICATION	 should not happen reading from stringreader 
WITHOUT_CLASSIFICATION	 attaches the owning workerexecutor this factory 
WITHOUT_CLASSIFICATION	 same the length this minus the last element minus the dot between them 
WITHOUT_CLASSIFICATION	 keep the argument from this expression 
WITHOUT_CLASSIFICATION	 are all file snapshots after execution accounted for new entries 
WITHOUT_CLASSIFICATION	 must use string literal here otherwise using things like fooclassname will trigger unnecessary loading classes the classloader the which not what want 
WITHOUT_CLASSIFICATION	 create the tasks for each binary that registered 
WITHOUT_CLASSIFICATION	 exclude all for modules not artifacts 
WITHOUT_CLASSIFICATION	 adds void setpropnameobject value method that fails 
WITHOUT_CLASSIFICATION	 start element marker 
WITHOUT_CLASSIFICATION	 this should only used for toplevel builds 
WITHOUT_CLASSIFICATION	 else wait for the next update event 
WITHOUT_CLASSIFICATION	 dont care collect the artifacts later the correct order 
WITHOUT_CLASSIFICATION	 verify that none the listed versions match another pattern 
WITHOUT_CLASSIFICATION	 weve already validated the inputs should never get here 
WITHOUT_CLASSIFICATION	 use this thread process any work this allows work executed using the worker lease acquired this thread even the executor thread pool full workers from other threads other words ensures that all worker leases are being utilized regardless the bounds the thread pool 
WITHOUT_CLASSIFICATION	 restrict the decorations those required decorate all views reachable from this type 
WITHOUT_CLASSIFICATION	 cached resolved values 
WITHOUT_CLASSIFICATION	 not fail the build feature noncritical 
WITHOUT_CLASSIFICATION	 not remove task descriptors because they might needed describe subsequent tasks dependencies 
WITHOUT_CLASSIFICATION	 avoid clone 
WITHOUT_CLASSIFICATION	 todo take care this the selector parser 
WITHOUT_CLASSIFICATION	 gradlefileresource type mapped antfileresource 
WITHOUT_CLASSIFICATION	 javac warning ignore 
WITHOUT_CLASSIFICATION	 support for command file 
WITHOUT_CLASSIFICATION	 configure implicit variant 
WITHOUT_CLASSIFICATION	 path ancestor this 
WITHOUT_CLASSIFICATION	 copied from methodisdefault 
WITHOUT_CLASSIFICATION	 this should come from the compiler classpath only 
WITHOUT_CLASSIFICATION	 consider every node that must run before the finalizer 
WITHOUT_CLASSIFICATION	 not hold lock while removing listener the listener may still receiving events another thread and will need acquire the lock handle these events 
WITHOUT_CLASSIFICATION	 create all the pipeline eagerly soon this enabled track the state build operations all the pipelines this should instead have single stage that tracks this for all pipelines and that can replay the current state new pipelines then pipeline can added for each listener required 
WITHOUT_CLASSIFICATION	 once the node has been discovered changing the target not allowed changes the promise the node well 
WITHOUT_CLASSIFICATION	 fall back the default logic 
WITHOUT_CLASSIFICATION	 set progress operations that have been forwarded 
WITHOUT_CLASSIFICATION	 first child node 
WITHOUT_CLASSIFICATION	 this necessary prevent behavior xcode project loading 
WITHOUT_CLASSIFICATION	 generate 
WITHOUT_CLASSIFICATION	 transform closure 
WITHOUT_CLASSIFICATION	 should instead forward these the tasks validation context 
WITHOUT_CLASSIFICATION	 mutable property 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 end tag marker 
WITHOUT_CLASSIFICATION	 have read some data let readers know 
WITHOUT_CLASSIFICATION	 adds void propnameclosure method that throws mme avoid attempts convert closure something else 
WITHOUT_CLASSIFICATION	 nexus uses sha etags with constant prefix 
WITHOUT_CLASSIFICATION	 part cycle use the minimum component the root the cycle 
WITHOUT_CLASSIFICATION	 look for realized object 
WITHOUT_CLASSIFICATION	 string 
WITHOUT_CLASSIFICATION	 also releases any locks 
WITHOUT_CLASSIFICATION	 not already known attempt resolve the parent 
WITHOUT_CLASSIFICATION	 the first argument not really used but very useful diagnosing running jps 
WITHOUT_CLASSIFICATION	 when root suite completed stop redirecting 
WITHOUT_CLASSIFICATION	 let the delegate resolver select among them 
WITHOUT_CLASSIFICATION	 setting time because need api jars identical independently the timestamps class files 
WITHOUT_CLASSIFICATION	 for storing field 
WITHOUT_CLASSIFICATION	 property readable and all getters and setters are abstract 
WITHOUT_CLASSIFICATION	 wait for work submitted the queue empty and our worker count under max workers this attempts keep max workers threads alive once theyve been started 
WITHOUT_CLASSIFICATION	 ignore the decorated service 
WITHOUT_CLASSIFICATION	 add create task 
WITHOUT_CLASSIFICATION	 directory has something already 
WITHOUT_CLASSIFICATION	 source file has not changed and include files 
WITHOUT_CLASSIFICATION	 shallow render any constraint edges and not mark the node visited 
WITHOUT_CLASSIFICATION	 assert the exit value signals success 
WITHOUT_CLASSIFICATION	 should protected but use the class generator forces public 
WITHOUT_CLASSIFICATION	 turn off request logging this can end logging oauth tokens which should not ever build log 
WITHOUT_CLASSIFICATION	 ignore some broken samples before the given date 
WITHOUT_CLASSIFICATION	 generate new 
WITHOUT_CLASSIFICATION	 both these values are effectively part cross gradle version contract not change them 
WITHOUT_CLASSIFICATION	 todo use ivyartifact here 
WITHOUT_CLASSIFICATION	 not part strongly connected component the root strongly connected component 
WITHOUT_CLASSIFICATION	 modifies place 
WITHOUT_CLASSIFICATION	 copy the snapshots whose values are the same then snapshot remaining values 
WITHOUT_CLASSIFICATION	 serialize the incoming class and parameters necessary 
WITHOUT_CLASSIFICATION	 null type undefined 
WITHOUT_CLASSIFICATION	 only characters matches above 
WITHOUT_CLASSIFICATION	 checks whether the plugin marker artifact exists the backing artifacts repositories 
WITHOUT_CLASSIFICATION	 this exception means that want try again 
WITHOUT_CLASSIFICATION	 probe for artifact with classifier 
WITHOUT_CLASSIFICATION	 note biginteger and bigdecimal are also imported default 
WITHOUT_CLASSIFICATION	 softwaremodel 
WITHOUT_CLASSIFICATION	 this point must have annotations this private getter 
WITHOUT_CLASSIFICATION	 create sourcefile object represent empty extern 
WITHOUT_CLASSIFICATION	 tdliterallink tddescriptiontd 
WITHOUT_CLASSIFICATION	 any windows gcc compatible implementation mingw cygwin 
WITHOUT_CLASSIFICATION	 mlml have position sensitive arguments must appear before and must appear before the source file 
WITHOUT_CLASSIFICATION	 extract the files that were generated 
WITHOUT_CLASSIFICATION	 first scan for annotation and short circuit transformation not present 
WITHOUT_CLASSIFICATION	 asking isresolved here allows check primitive type name like int was used make such case have nothing left 
WITHOUT_CLASSIFICATION	 according absolute positioning 
WITHOUT_CLASSIFICATION	 make the argument serializers available work implementations can register their own serializers 
WITHOUT_CLASSIFICATION	 not sure under what scenario any this would occur but theres sense collecting the descriptor does 
WITHOUT_CLASSIFICATION	 rethrow 
WITHOUT_CLASSIFICATION	 can only determine two daemonstopevent point the same daemon know the pids 
WITHOUT_CLASSIFICATION	 use ideamodule reference project 
WITHOUT_CLASSIFICATION	 literal followed least one 
WITHOUT_CLASSIFICATION	 lifecycle messages 
WITHOUT_CLASSIFICATION	 weve freed memory invalidate the current memory snapshot 
WITHOUT_CLASSIFICATION	 consumer didnt express any preference everything fits 
WITHOUT_CLASSIFICATION	 traverse graph 
WITHOUT_CLASSIFICATION	 enabled caching task type annotated with cacheabletask 
WITHOUT_CLASSIFICATION	 wrap build failure cancelled cross version exception 
WITHOUT_CLASSIFICATION	 alternatively could return would differ the following ways live not sure want live here autowiring probably want autowiring here 
WITHOUT_CLASSIFICATION	 run the rules and try find something again 
WITHOUT_CLASSIFICATION	 invalid paths fall through here 
WITHOUT_CLASSIFICATION	 todo set acl here necessary 
WITHOUT_CLASSIFICATION	 map from progress operation seen event progress operation that should forwarded 
WITHOUT_CLASSIFICATION	 just case have bug related logging printing some exit info directly file 
WITHOUT_CLASSIFICATION	 register the defined substitutions for included build 
WITHOUT_CLASSIFICATION	 only need decorate when this callback delayed 
WITHOUT_CLASSIFICATION	 the task status line may appear twice once for the execution once for the uptodateskippedetc dont add the task list this update previously added task 
WITHOUT_CLASSIFICATION	 all tasks have the same value 
WITHOUT_CLASSIFICATION	 create the domain object 
WITHOUT_CLASSIFICATION	 calculate how many rows the status area overlap with the text area 
WITHOUT_CLASSIFICATION	 objectlike macro 
WITHOUT_CLASSIFICATION	 set worker classloader 
WITHOUT_CLASSIFICATION	 sometask foobar 
WITHOUT_CLASSIFICATION	 watch for the client disconnecting before call stop 
WITHOUT_CLASSIFICATION	 separator 
WITHOUT_CLASSIFICATION	 projectstatewrapper might contain the configured eclipse project name 
WITHOUT_CLASSIFICATION	 weve seen the replacement register new conflict and return 
WITHOUT_CLASSIFICATION	 add new labels the unused queue 
WITHOUT_CLASSIFICATION	 this final use link provide the dependencies instead 
WITHOUT_CLASSIFICATION	 noinspection unchecked 
WITHOUT_CLASSIFICATION	 todo add test name the report formatteroff 
WITHOUT_CLASSIFICATION	 triggering file resolve 
WITHOUT_CLASSIFICATION	 only input for other task instances 
WITHOUT_CLASSIFICATION	 wrap span work around css problem 
WITHOUT_CLASSIFICATION	 collect map from component its owning component this might better move the component some publications model 
WITHOUT_CLASSIFICATION	 can use arg without conversion 
WITHOUT_CLASSIFICATION	 super class not the classpath unable scan parent class 
WITHOUT_CLASSIFICATION	 get the next page the next iteration this loop 
WITHOUT_CLASSIFICATION	 have already visited this node skip 
WITHOUT_CLASSIFICATION	 the class property stops resolving dynamic property names too 
WITHOUT_CLASSIFICATION	 missing 
WITHOUT_CLASSIFICATION	 match recording optimized for the general case single match 
WITHOUT_CLASSIFICATION	 this happens when jna not the path this happens when the stdout being redirected file 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 add adapter for each newly added target 
WITHOUT_CLASSIFICATION	 groovy manipulates the jvm let gstring extend string whenever have set map containing strings might also contain gstrings this breaks deserialization the client this method forces gstring string conversion 
WITHOUT_CLASSIFICATION	 only write have results otherwise truncate 
WITHOUT_CLASSIFICATION	 todo synchronization 
WITHOUT_CLASSIFICATION	 could retrieve annotations construction time and hold references them but unfortunately ibm jdk strong references are held from annotation instance class which used have reflect 
WITHOUT_CLASSIFICATION	 restore the existing object being deserialized 
WITHOUT_CLASSIFICATION	 handle decoding underflow multibyte unicode character buffer chunk boundary 
WITHOUT_CLASSIFICATION	 either cached its changed see can find something local with the same checksum 
WITHOUT_CLASSIFICATION	 need make sure the variants consider provide the implicit capability 
WITHOUT_CLASSIFICATION	 filecollection files assertthatcall bean beanfiles bean files nullvalue sameinstancefiles 
WITHOUT_CLASSIFICATION	 not reprocess 
WITHOUT_CLASSIFICATION	 relink produce another object file hide main symbol 
WITHOUT_CLASSIFICATION	 intentionally not createmethod this should not exposed service 
WITHOUT_CLASSIFICATION	 track any progress operation that either cant display due label shortage child progress operation already been displayed 
WITHOUT_CLASSIFICATION	 assume wide this minimize wrapping console where dont know the width mintty its not intended correct solution simply work around 
WITHOUT_CLASSIFICATION	 noinspection 
WITHOUT_CLASSIFICATION	 not looking match 
WITHOUT_CLASSIFICATION	 doesnt exist either side nothing compare 
WITHOUT_CLASSIFICATION	 remove srcdir from sourceset 
WITHOUT_CLASSIFICATION	 ignore artifact transforms 
WITHOUT_CLASSIFICATION	 constraint only consider explicit exclusions declared for this constraint 
WITHOUT_CLASSIFICATION	 check next level interfaces 
WITHOUT_CLASSIFICATION	 this expensive calculate cache the result 
WITHOUT_CLASSIFICATION	 ignore anonymous classes 
WITHOUT_CLASSIFICATION	 standalone test suite 
WITHOUT_CLASSIFICATION	 when build output area not visible position the cursor the end the output area 
WITHOUT_CLASSIFICATION	 try resolve public static inner class name 
WITHOUT_CLASSIFICATION	 fallback take the name from the projectstate 
WITHOUT_CLASSIFICATION	 log the error but analyze the remaining interfaces could for example run into 
WITHOUT_CLASSIFICATION	 synthesize start event 
WITHOUT_CLASSIFICATION	 querying runtime for each invocation 
WITHOUT_CLASSIFICATION	 eventually add blank line before section 
WITHOUT_CLASSIFICATION	 else assume can write anything that exists and not directory 
WITHOUT_CLASSIFICATION	 called from generated code failure convert the supplied value for property the property type 
WITHOUT_CLASSIFICATION	 systemnanotime can backwards under some circumstances this max call ensures that dont return negative durations 
WITHOUT_CLASSIFICATION	 some poms depend themselves dont add this dependency ivy doesnt allow this 
WITHOUT_CLASSIFICATION	 reconsider type visibility 
WITHOUT_CLASSIFICATION	 this cant called just include because has the same erasure 
WITHOUT_CLASSIFICATION	 setpropertythis name value 
WITHOUT_CLASSIFICATION	 one the scala plugins applied but scalaruntime extension missing the scalaplatform undefined cant create scala sdk without either one 
WITHOUT_CLASSIFICATION	 rewording exception message get rid the fqcn contains 
WITHOUT_CLASSIFICATION	 generate value 
WITHOUT_CLASSIFICATION	 attributes 
WITHOUT_CLASSIFICATION	 assertthatcall bean beanthings bean nullvalue equalto 
WITHOUT_CLASSIFICATION	 todolptr this should like finalize void binary 
WITHOUT_CLASSIFICATION	 okay have redundant generated isgetters 
WITHOUT_CLASSIFICATION	 this inner class hides the fact that the actual deduplication algorithm stateful 
WITHOUT_CLASSIFICATION	 were spinning thread work avoid blocking the connection this means that the daemon potentially can multiple things but only allows single build time 
WITHOUT_CLASSIFICATION	 look into the module node there class with that name 
WITHOUT_CLASSIFICATION	 type more complicated need check everything 
WITHOUT_CLASSIFICATION	 register least the project builddir directory deleted 
WITHOUT_CLASSIFICATION	 todo use circular buffers avoid copying todo share single initializer with multichannelqueue 
WITHOUT_CLASSIFICATION	 nothing default 
WITHOUT_CLASSIFICATION	 kotlin boolean accessor methods where the name the getter starts with and the name the setter starts with set are represented properties which have the same name the getter method boolean properties are visible with prefix kotlin this code assumes all configurable boolean property getters follow the prefix convention 
WITHOUT_CLASSIFICATION	 replaces the currently visited expression with the specified expression 
WITHOUT_CLASSIFICATION	 currently only look script code could extend this build script classes 
WITHOUT_CLASSIFICATION	 ensure resource transport protocol authentication types and credentials are all compatible 
WITHOUT_CLASSIFICATION	 rule 
WITHOUT_CLASSIFICATION	 replace only the classname part with find inner class the case that the package really class handled elsewhere 
WITHOUT_CLASSIFICATION	 always abort execution for execution failure opposed node failure 
WITHOUT_CLASSIFICATION	 box value 
WITHOUT_CLASSIFICATION	 back being pending dependency clear remaining incoming edges they must all from constraints 
WITHOUT_CLASSIFICATION	 notify upwards currently existing descendant spec hierarchy 
WITHOUT_CLASSIFICATION	 for maven dont really know optional dependency required for runtime compile use the safest compile 
WITHOUT_CLASSIFICATION	 when only get here when link couldnt followed 
WITHOUT_CLASSIFICATION	 modifies args place 
WITHOUT_CLASSIFICATION	 construct project tasks 
WITHOUT_CLASSIFICATION	 locked the same process treat locked another process 
WITHOUT_CLASSIFICATION	 endjupiterexample 
WITHOUT_CLASSIFICATION	 absolutely need avoid polluting the project with classinfo from our classloader this class must not call any dynamic groovy code this means must what follows using good old java reflection 
WITHOUT_CLASSIFICATION	 gcc windows requires the path set 
WITHOUT_CLASSIFICATION	 jarname format 
WITHOUT_CLASSIFICATION	 continue 
WITHOUT_CLASSIFICATION	 disable command line file for now because some custom assemblers dont understand the same arguments gcc 
WITHOUT_CLASSIFICATION	 particular this about gstrings 
WITHOUT_CLASSIFICATION	 should retain this the metadata rather than calculate each invocation 
WITHOUT_CLASSIFICATION	 collect this early the process current directory can change during embedded test execution 
WITHOUT_CLASSIFICATION	 task properties 
WITHOUT_CLASSIFICATION	 can try sending something the daemon and try out really dead use jps hes really dead should deregister not already deregistered the daemon not dead might continue receiving from him and try find the bug messaging infrastructure 
WITHOUT_CLASSIFICATION	 crash 
WITHOUT_CLASSIFICATION	 generate getconvention 
WITHOUT_CLASSIFICATION	 node and any subclass resolving will then take place elsewhere 
WITHOUT_CLASSIFICATION	 set the context classloader the bootstrap classloader work around how jaxp locates implementation classes this should ensure that the jaxp classes provided the jvm are used rather than some other implementation 
WITHOUT_CLASSIFICATION	 delete the coverage file before the task executes dont append leftover file from the last execution this makes the task cacheable even multiple jvms write same destination file when executing tests parallel the jacoco agent supports writing parallel the same file see 
WITHOUT_CLASSIFICATION	 the manifest this jar file and has manifest null otherwise 
WITHOUT_CLASSIFICATION	 either resolvable expression nonempty unresolvable expression collect ignore includes with value 
WITHOUT_CLASSIFICATION	 deployments are considered outofdate until initial execution with file watching 
WITHOUT_CLASSIFICATION	 when the component defines precompiled header need check the precompiled header the first header the source file for source files that not include the precompiled header the first file emit warning for source files that include the precompiled header mark them source file for pch the native compiler then adds the appropriate compiler arguments for those source files that can use pch 
WITHOUT_CLASSIFICATION	 object name 
WITHOUT_CLASSIFICATION	 body expression with one more arguments 
WITHOUT_CLASSIFICATION	 always publish process info for multirequest workers 
WITHOUT_CLASSIFICATION	 the platform doesnt exist were building lenient one 
WITHOUT_CLASSIFICATION	 dont bother resolving local components asynchronously 
WITHOUT_CLASSIFICATION	 report generated ignore 
WITHOUT_CLASSIFICATION	 authoritative result means dont remote search 
WITHOUT_CLASSIFICATION	 dynamic constraints defined dynamicid equals revid 
WITHOUT_CLASSIFICATION	 write rich content stdout and plain content stderr 
WITHOUT_CLASSIFICATION	 build may have failed before getting projectsloaded 
WITHOUT_CLASSIFICATION	 create test lifecycle task 
WITHOUT_CLASSIFICATION	 ensure binding validation has been done this should happen elsewhere 
WITHOUT_CLASSIFICATION	 invoked groovy 
WITHOUT_CLASSIFICATION	 idea doesnt like the result filetouri use the absolute path instead 
WITHOUT_CLASSIFICATION	 version isnt used except human looking the output jps 
WITHOUT_CLASSIFICATION	 tool chains can build for this platform assemble description why 
WITHOUT_CLASSIFICATION	 need use the deprecated constructor compatible with certain previous versions the zinc compiler 
WITHOUT_CLASSIFICATION	 need compile all secondary routes fooroutes before primary routes 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 not our name mangling find inner class the type because this case are resolving the name different place already 
WITHOUT_CLASSIFICATION	 pallows the container configured creating missing objects they are referencedp ptodo example usagep param configureclosure the closure configure this container with return this 
WITHOUT_CLASSIFICATION	 ends with 
WITHOUT_CLASSIFICATION	 this agent should loaded via the custom system classloader 
WITHOUT_CLASSIFICATION	 update the cache entry the index this resets the age the cached entry zero 
WITHOUT_CLASSIFICATION	 should excluded 
WITHOUT_CLASSIFICATION	 still updated with reason when version remains the same 
WITHOUT_CLASSIFICATION	 check for duplicate entries java and resources 
WITHOUT_CLASSIFICATION	 use throwable record the location where suffix was registered allow diagnostics when collision found this may have performance implications however the assumption that class generators are global scoped objects that are created once and very small numbers 
WITHOUT_CLASSIFICATION	 strategy mutations will not require reresolve 
WITHOUT_CLASSIFICATION	 maven local 
WITHOUT_CLASSIFICATION	 adds void propnameclosure method that delegates model state 
WITHOUT_CLASSIFICATION	 print something verify after task execution 
WITHOUT_CLASSIFICATION	 this used only retain strong references the values 
WITHOUT_CLASSIFICATION	 windows needs additional backslash jar urls 
WITHOUT_CLASSIFICATION	 add line before the first question that has been asked the user this makes the assumption that all questions happen together which for now would better allow this handler ask the output renderers show blank line before the prompt not already present 
WITHOUT_CLASSIFICATION	 should not happen 
WITHOUT_CLASSIFICATION	 versions before would throw away the cause there was also regression 
WITHOUT_CLASSIFICATION	 this cannot because need iterate reverse which requires atomically getting iterator and the size moreover iterate this list far more often that mutate making albeit home grown copyonwrite strategy more appealing 
WITHOUT_CLASSIFICATION	 more unused label try resize 
WITHOUT_CLASSIFICATION	 some poms depend themselves through their parent pom dont add this dependency since ivy doesnt allow this example 
WITHOUT_CLASSIFICATION	 assuming the message has correct format not bullet proof but seems work for now 
WITHOUT_CLASSIFICATION	 nested instance 
WITHOUT_CLASSIFICATION	 use the origin file when can satisfy the basename requirements 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 must not use interrupt because would automatically close the connection sending data from interrupted thread automatically closes the connection 
WITHOUT_CLASSIFICATION	 eagerly calculate the file this will used dependency some task this avoid having lock the project when consuming task another project runs 
WITHOUT_CLASSIFICATION	 legacy mode for internal apis 
WITHOUT_CLASSIFICATION	 clear previous traversal state any 
WITHOUT_CLASSIFICATION	 notify threads that may waiting this task complete this required because although all builds may share the same coordination service the something may have changed event that fired when task this build completes happens before the state tracked here updated and the worker threads the consuming build may think the task has not completed and back sleep waiting for some other event happen which may not signalling again here means that all worker threads all builds will woken which can expensive would much better avoid duplicating the task state here and instead have the task executors communicate directly with each other possibly via some abstraction that represents the task outcome 
WITHOUT_CLASSIFICATION	 dont want support flag true syntax 
WITHOUT_CLASSIFICATION	 execute the health check that should send out daemonexpiration event the daemon unhealthy 
WITHOUT_CLASSIFICATION	 this artifact asked for particular dependency 
WITHOUT_CLASSIFICATION	 origins have stored until the end the build 
WITHOUT_CLASSIFICATION	 parking space for the write cursor 
WITHOUT_CLASSIFICATION	 caller must holding lock 
WITHOUT_CLASSIFICATION	 dont close 
WITHOUT_CLASSIFICATION	 skipped versions were not used release 
WITHOUT_CLASSIFICATION	 fallback classloaders lookup 
WITHOUT_CLASSIFICATION	 argument quoting must encoded must encoded pathological case must encoded but other than that must not quoted other characters including will not quoted use state machine rather than regexps 
WITHOUT_CLASSIFICATION	 test vanilla name current class name 
WITHOUT_CLASSIFICATION	 revisit all dependencies and possibly change the classpath order 
WITHOUT_CLASSIFICATION	 any node that the preceding task must run after also preceding node 
WITHOUT_CLASSIFICATION	 return var 
WITHOUT_CLASSIFICATION	 never date 
WITHOUT_CLASSIFICATION	 line gap between the text area and the status area 
WITHOUT_CLASSIFICATION	 expand the thread pool until hit max workers 
WITHOUT_CLASSIFICATION	 otherwise keep lock open 
WITHOUT_CLASSIFICATION	 because zerror 
WITHOUT_CLASSIFICATION	 work backwards from highest version return the first candidate with qualified version and release status candidate with unqualified version 
WITHOUT_CLASSIFICATION	 externals are mapped linked resources just need name the resource without full path non unique folder names are naively deduped adding parent filename prefix till unique since this seems like rare edge case this simple approach should enough 
WITHOUT_CLASSIFICATION	 use the abi the hash 
WITHOUT_CLASSIFICATION	 need defer loading zincsbtscala classes until are running the compiler daemon and have them the class path 
WITHOUT_CLASSIFICATION	 generate superpropnamev 
WITHOUT_CLASSIFICATION	 this point need the component metadata because may declare attributes that are needed for matching component metadata may not necessarily hit the network there custom component metadata supplier 
WITHOUT_CLASSIFICATION	 generate private boolean flagname 
WITHOUT_CLASSIFICATION	 expire when daemon registry becomes unreachable for some reason 
WITHOUT_CLASSIFICATION	 tdlink tddescriptiontd 
WITHOUT_CLASSIFICATION	 the new value better fit than the old one 
WITHOUT_CLASSIFICATION	 single leaf node child and total text not too long collapse 
WITHOUT_CLASSIFICATION	 define classes variant use for compilation 
WITHOUT_CLASSIFICATION	 edge states are deduplicated this performance optimization 
WITHOUT_CLASSIFICATION	 only remove edges that come from different node than the source the dependency going back pending the edges from the from will removed first 
WITHOUT_CLASSIFICATION	 coercion expensive process cache the result coercing other attribute types can afford using hashmap here because attributes are interned and their lifetime doesnt exceed build 
WITHOUT_CLASSIFICATION	 detach the process from the parent terminalconsole 
WITHOUT_CLASSIFICATION	 this the first time weve seen the module register with conflict resolver 
WITHOUT_CLASSIFICATION	 todo whenever allow user services injected this would have know from which classloader need load the service 
WITHOUT_CLASSIFICATION	 source file has not been compiled before its include file graph has changed some way calculate the include file graph for the source file and mark for recompilation 
WITHOUT_CLASSIFICATION	 gradle core plus worker implementation classes 
WITHOUT_CLASSIFICATION	 todo does static library really have any runtime elements 
WITHOUT_CLASSIFICATION	 todo check that this configurations have attributes 
WITHOUT_CLASSIFICATION	 prefer direct transformation over indirect transformation 
WITHOUT_CLASSIFICATION	 classes resources requested some jars found lets prefer these 
WITHOUT_CLASSIFICATION	 check type factory extends elementtype 
WITHOUT_CLASSIFICATION	 the default name for model the name the java interface 
WITHOUT_CLASSIFICATION	 compile the javascript file with the options weve created 
WITHOUT_CLASSIFICATION	 should never attempt join strings you see this theres problem 
WITHOUT_CLASSIFICATION	 create new group for tasks configure project 
WITHOUT_CLASSIFICATION	 weve never resolved must resolve 
WITHOUT_CLASSIFICATION	 linux assume swift installed into optswift 
WITHOUT_CLASSIFICATION	 this already throws when creating apielements eager have clear error message 
WITHOUT_CLASSIFICATION	 more lines that look like stack trace elements 
WITHOUT_CLASSIFICATION	 for example skipped foobarbaz uptodate but not 
WITHOUT_CLASSIFICATION	 maintain hierarchy all progress operations progress heads this forest not just tree 
WITHOUT_CLASSIFICATION	 already have hard dependency this optional dependency not pending 
WITHOUT_CLASSIFICATION	 the client has not set location for sourceoutput javac outputs those files the classoutput directory clean that instead 
WITHOUT_CLASSIFICATION	 literal followed matches above 
WITHOUT_CLASSIFICATION	 this may thrown the caller this method later time 
WITHOUT_CLASSIFICATION	 exclude rules 
WITHOUT_CLASSIFICATION	 the maximum number times retry request when responds with http error 
WITHOUT_CLASSIFICATION	 most outer class now element 
WITHOUT_CLASSIFICATION	 works java 
WITHOUT_CLASSIFICATION	 first need populate the default variant version mapping strategy with the default values provided plugins 
WITHOUT_CLASSIFICATION	 any available tool chain 
WITHOUT_CLASSIFICATION	 lock held while creating classloader nothing else can happen while this running 
WITHOUT_CLASSIFICATION	 treat all models returned the action part the same object graph 
WITHOUT_CLASSIFICATION	 dont use its rarely supported like windows 
WITHOUT_CLASSIFICATION	 the wrapper uses the file identify distributions that are safe use delete anything from the distribution before deleting the file the wrapper will attempt use the distribution asis and fail strange and unrecoverable ways 
WITHOUT_CLASSIFICATION	 may have ckv should become ckv 
WITHOUT_CLASSIFICATION	 new module check for conflict with capabilities and module replacements 
WITHOUT_CLASSIFICATION	 attributes 
WITHOUT_CLASSIFICATION	 return silently when directory doesnt exist 
WITHOUT_CLASSIFICATION	 leaks into the public api this component 
WITHOUT_CLASSIFICATION	 thisinstantiator 
WITHOUT_CLASSIFICATION	 log configuration 
WITHOUT_CLASSIFICATION	 isolate parameters this thread prior starting work separate thread 
WITHOUT_CLASSIFICATION	 not holding the cache lock can stop now 
WITHOUT_CLASSIFICATION	 these are used discard references tasks they can garbage collected 
WITHOUT_CLASSIFICATION	 generate inputreferences method 
WITHOUT_CLASSIFICATION	 special handling for artifacts declared for optional dependencies 
WITHOUT_CLASSIFICATION	 the following only needs done serially preserve ordering dependencies the graph have visited the edges but still didnt add the result the queue doing from resolve threads would result nonreproducible graphs where edges could added different order avoid this the addition new edges done serially 
WITHOUT_CLASSIFICATION	 only false declared outputs and taskuptodatewhen spec force true for incremental tasks 
WITHOUT_CLASSIFICATION	 local component cannot have attributes for now however variants the component itself may 
WITHOUT_CLASSIFICATION	 todo put this somewhere else 
WITHOUT_CLASSIFICATION	 making the daemon infrastructure log with debug this only for the infrastructure 
WITHOUT_CLASSIFICATION	 tasks are ignored providers launchables not null 
WITHOUT_CLASSIFICATION	 replace wildcard with 
WITHOUT_CLASSIFICATION	 now our processing using the antlr preprocessor results whenever possible 
WITHOUT_CLASSIFICATION	 note beforeevaluate and afterevaluate ops not throw instead mark state failed 
WITHOUT_CLASSIFICATION	 optimizes comparisons making sure that the elements the pair are sorted hashcode ascending 
WITHOUT_CLASSIFICATION	 return null remove the statement 
WITHOUT_CLASSIFICATION	 reached the end input worker has crashed exited 
WITHOUT_CLASSIFICATION	 ignore this progress operation and map any reference its parent whatever its parent mapped 
WITHOUT_CLASSIFICATION	 this code path will always noop following the changes however this code will have remain forever while the other one should removed some point gradle 
WITHOUT_CLASSIFICATION	 protects the following state 
WITHOUT_CLASSIFICATION	 still starting 
WITHOUT_CLASSIFICATION	 show the direct cause the last contextual cause only 
WITHOUT_CLASSIFICATION	 populates descriptors last descriptor wins for given architecture 
WITHOUT_CLASSIFICATION	 have cached version but might out date tell the upstreams revalidate too 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 determine the package name 
WITHOUT_CLASSIFICATION	 force the user home services stopped first the dependencies between the user home services and the global services are not preserved currently 
WITHOUT_CLASSIFICATION	 todo not reference mutable state 
WITHOUT_CLASSIFICATION	 this stage strictly implies requires 
WITHOUT_CLASSIFICATION	 invert the map file extension uti pairs uti file extension pairs 
WITHOUT_CLASSIFICATION	 primitive type 
WITHOUT_CLASSIFICATION	 could this java which would easier however twirl only has java interface version used java here then gradles twirlcompiler would need support both scalamethod for twirl and javas method for twirl method definition 
WITHOUT_CLASSIFICATION	 clean comments and new lines 
WITHOUT_CLASSIFICATION	 private classloader 
WITHOUT_CLASSIFICATION	 managed internal views are allowed not implemented the default implementation 
WITHOUT_CLASSIFICATION	 equality has been tested before know groups are different 
WITHOUT_CLASSIFICATION	 checking there type variable resolve since resolving the type variable via typetoken quite expensive 
WITHOUT_CLASSIFICATION	 found only one project dependency return otherwise call the next resolver 
WITHOUT_CLASSIFICATION	 invoke the typed setter 
WITHOUT_CLASSIFICATION	 all requests completed write response 
WITHOUT_CLASSIFICATION	 dont render empty requested reason 
WITHOUT_CLASSIFICATION	 guessing right side part mapping 
WITHOUT_CLASSIFICATION	 assume infrastructure problem 
WITHOUT_CLASSIFICATION	 thismetaclass value 
WITHOUT_CLASSIFICATION	 remove kotlin dsl and kotlin jars 
WITHOUT_CLASSIFICATION	 maybe matched through coercion 
WITHOUT_CLASSIFICATION	 start the download another thread and wait for the result 
WITHOUT_CLASSIFICATION	 discarded from stream 
WITHOUT_CLASSIFICATION	 make sure file order always consistent 
WITHOUT_CLASSIFICATION	 previous resolve failed point reresolving 
WITHOUT_CLASSIFICATION	 are pretending that dont have sourcepath the compiler will look the classpath for sources since dont want bring any sources implicitly from the classpath have ignore source files found the classpath 
WITHOUT_CLASSIFICATION	 dependencies deduplication 
WITHOUT_CLASSIFICATION	 have for example class name are class and there nested class want able access that class directly becomes valid name 
WITHOUT_CLASSIFICATION	 were writing copies the resource one relocated the other not order support with both absolute and relative paths 
WITHOUT_CLASSIFICATION	 cannot visit local artifacts until transform has been executed 
WITHOUT_CLASSIFICATION	 note the order which the build phase are added important 
WITHOUT_CLASSIFICATION	 the status attribute mandatory its missing need add 
WITHOUT_CLASSIFICATION	 stop cancelling before sending endofinput 
WITHOUT_CLASSIFICATION	 generate private type propertyfieldname 
WITHOUT_CLASSIFICATION	 handler detect gradle metadata redirects 
WITHOUT_CLASSIFICATION	 task not required skip 
WITHOUT_CLASSIFICATION	 note use nonblocking there reliable way when using blocking shutdown reads while keeping writes active for example socketshutdowninput does not work windows 
WITHOUT_CLASSIFICATION	 they change continuity the ids will broken 
WITHOUT_CLASSIFICATION	 zero more characters followed least one 
WITHOUT_CLASSIFICATION	 can only have attributes have the factory then need copy 
WITHOUT_CLASSIFICATION	 dont care about producing nodes that havent finished yet 
WITHOUT_CLASSIFICATION	 the eclipse workspace contains projects from root and included builds check projects from all builds that models built for included builds not consider projects from parent builds external 
WITHOUT_CLASSIFICATION	 broken version 
WITHOUT_CLASSIFICATION	 mode infos available fall back defaults 
WITHOUT_CLASSIFICATION	 start tag marker 
WITHOUT_CLASSIFICATION	 add groovyant bring groovydoc for groovy 
WITHOUT_CLASSIFICATION	 hard dependency queue pending dependency case see hard dependency later 
WITHOUT_CLASSIFICATION	 todo assumes theres single main swift component 
WITHOUT_CLASSIFICATION	 the ansi escapes 
WITHOUT_CLASSIFICATION	 possible that multiple threads will execute this branch concurrently when the type missing however the contract for get below will ensure that only one thread will actually generate the implementation class 
WITHOUT_CLASSIFICATION	 index the artifact set the the artifact set 
WITHOUT_CLASSIFICATION	 version not found this base path 
WITHOUT_CLASSIFICATION	 note windows uses path but allows asking for path and path set within builder object for some things such try path first and then revert default path null 
WITHOUT_CLASSIFICATION	 use java serialization for everything else 
WITHOUT_CLASSIFICATION	 save the processed metadata for next time 
WITHOUT_CLASSIFICATION	 todolptr should nested with console inside 
WITHOUT_CLASSIFICATION	 need add missing files source roots since the package name for deleted files provided also need determined 
WITHOUT_CLASSIFICATION	 ignore classes method bodies 
WITHOUT_CLASSIFICATION	 there are only enough entries make block move the entries the right sibling into this block and discard this block might also need merge the parent 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 path either delimited 
WITHOUT_CLASSIFICATION	 get here have idea how much memory the worker using 
WITHOUT_CLASSIFICATION	 work around some bugs inputskip 
WITHOUT_CLASSIFICATION	 the ansi escapes for piping into ansi color aware commands less 
WITHOUT_CLASSIFICATION	 remove build listener 
WITHOUT_CLASSIFICATION	 core javadoc options 
WITHOUT_CLASSIFICATION	 need make sure remove duplicates cant just compose iterators from source collections 
WITHOUT_CLASSIFICATION	 the provider compatible type and the element was either already realized are removing provider the element 
WITHOUT_CLASSIFICATION	 and now lets make sure not have another version that virtual platform missing its metadata 
WITHOUT_CLASSIFICATION	 current model 
WITHOUT_CLASSIFICATION	 add package there none yet and the module has one but not add that the type the code haspackagename will return true has dots but since the prefix may have them and the code there does ignore that 
WITHOUT_CLASSIFICATION	 patternfilterable overrides broaden return type 
WITHOUT_CLASSIFICATION	 generate factory class 
WITHOUT_CLASSIFICATION	 javalangobject found which not test class 
WITHOUT_CLASSIFICATION	 there are pending dependencies that share target with any these outgoing edges then reset the state the node that owns those dependencies this way all edges the node will reprocessed 
WITHOUT_CLASSIFICATION	 the regular typed setter 
WITHOUT_CLASSIFICATION	 inject 
WITHOUT_CLASSIFICATION	 axe everything after the expected exception 
WITHOUT_CLASSIFICATION	 use classpath manifest jar circumvent too long command line issues windows cap classpath huge here because its the test runtime classpath 
WITHOUT_CLASSIFICATION	 api first 
WITHOUT_CLASSIFICATION	 stderr gradle redirected stdout xcodebuild tool work around consider xcodebuild stdout and stderr the error output only xcodebuild failed most likely due gradle 
WITHOUT_CLASSIFICATION	 treat all errors warnings for backwards compatibility 
WITHOUT_CLASSIFICATION	 taghostandpath 
WITHOUT_CLASSIFICATION	 just the minimal stuff necessary for the worker infrastructure 
WITHOUT_CLASSIFICATION	 unclear what the best thing here would 
WITHOUT_CLASSIFICATION	 todo wolfs move these identifiers the actual strategy classes when they live snapshots 
WITHOUT_CLASSIFICATION	 may may not mutable unpack the state 
WITHOUT_CLASSIFICATION	 host target 
WITHOUT_CLASSIFICATION	 previously traversed but new constraints longer pending partial traversing 
WITHOUT_CLASSIFICATION	 endsample 
WITHOUT_CLASSIFICATION	 moduleworkingdir doesnt seem work correctly and moduledir seems see 
WITHOUT_CLASSIFICATION	 note order crucial here nodes are traversed through these states the order defined below 
WITHOUT_CLASSIFICATION	 ignore 
WITHOUT_CLASSIFICATION	 verbose output written stderr for some reason 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 these errors happen the jni lib not available for your platform but since are ansi friendly platform assume the user the console 
WITHOUT_CLASSIFICATION	 order avoid tracking the set enqueued nodes 
WITHOUT_CLASSIFICATION	 assume generated file collections have build dependencies 
WITHOUT_CLASSIFICATION	 always need the files need run the transform order calculate the output artifacts 
WITHOUT_CLASSIFICATION	 for each candidate node add the preceding nodes 
WITHOUT_CLASSIFICATION	 add tasks build various kinds components 
WITHOUT_CLASSIFICATION	 dont need these things theyre provided the runtime 
WITHOUT_CLASSIFICATION	 loop over all listed versions sorted latest first 
WITHOUT_CLASSIFICATION	 method that returns boolean not getter according javabeans but include for compatibility with groovy 
WITHOUT_CLASSIFICATION	 the following code was patched according the following 
WITHOUT_CLASSIFICATION	 reach this point means the node selection was restarted but effectively has the same incoming edges before can return the result computed last time 
WITHOUT_CLASSIFICATION	 create test suite test task 
WITHOUT_CLASSIFICATION	 protects the following fields 
WITHOUT_CLASSIFICATION	 this happens when the connection between the worker and the build daemon closed for some reason possibly because the build daemon died unexpectedly 
WITHOUT_CLASSIFICATION	 not valid signature 
WITHOUT_CLASSIFICATION	 remember module was annotated 
WITHOUT_CLASSIFICATION	 property requires jaxp java 
WITHOUT_CLASSIFICATION	 capture nonfile input changes 
WITHOUT_CLASSIFICATION	 add the items this page results the list well return 
WITHOUT_CLASSIFICATION	 this will cause problems windows the path the gradle executable that used has space the users dir cusersluke daley this fundamentally windows issue you cant have arguments with spaces them the path the batch script has space could work around this setting dgradleuserhome but gradle which affects milestone means that that problematic well for now just dont support running the int tests from path with space windows when stop testing against should change use the system property 
WITHOUT_CLASSIFICATION	 todo should iterate over each candidate until successfully copy into the cache 
WITHOUT_CLASSIFICATION	 todo replace with native test task 
WITHOUT_CLASSIFICATION	 must close each input first 
WITHOUT_CLASSIFICATION	 bit bit 
WITHOUT_CLASSIFICATION	 prevent file system change events when generated content 
WITHOUT_CLASSIFICATION	 there are left candidate not bother checking other attributes 
WITHOUT_CLASSIFICATION	 partial match 
WITHOUT_CLASSIFICATION	 todolptr this should added only the scan plugin applied but expects added also when the build cache enabled but not the scan plugin 
WITHOUT_CLASSIFICATION	 based 
WITHOUT_CLASSIFICATION	 noop 
WITHOUT_CLASSIFICATION	 pathtype 
WITHOUT_CLASSIFICATION	 find the status line for the previous record this task 
WITHOUT_CLASSIFICATION	 inherit implementation dependencies 
WITHOUT_CLASSIFICATION	 register the domain object 
WITHOUT_CLASSIFICATION	 temporary classpath implementation for new jvm component model 
WITHOUT_CLASSIFICATION	 special case build successful when there result object send 
WITHOUT_CLASSIFICATION	 note the jdk code create sslcontexts relies the values the given system properties prevent concurrent changes system properties from interfering with this need synchronize accessmodifications system properties this best effort since cant prevent user code from modifying system properties willynilly the most critical system property javahome changing this property while trying create sslcontext can cause many strange problems 
WITHOUT_CLASSIFICATION	 append full stack trace 
WITHOUT_CLASSIFICATION	 tagcustomtaskclass 
WITHOUT_CLASSIFICATION	 use the file from the cache when does not 
WITHOUT_CLASSIFICATION	 see the grammar outofdate way its supergrammars gleaned from parsing the grammar file 
WITHOUT_CLASSIFICATION	 this performance optimization most modules not declare capabilities instead systematically registering implicit capability for each module that see only consider modules which declare capabilities they then try find module which provides the same capability that module has been found then register otherwise have nothing this avoids most registrations 
WITHOUT_CLASSIFICATION	 use dummy security manager which hacks the application classpath into the system classloader 
WITHOUT_CLASSIFICATION	 generate thisservices 
WITHOUT_CLASSIFICATION	 reference this class 
WITHOUT_CLASSIFICATION	 checks its derived platform 
WITHOUT_CLASSIFICATION	 discard actions after execution 
WITHOUT_CLASSIFICATION	 set explicit build file required 
WITHOUT_CLASSIFICATION	 gradles log levels correspond slfj log levels implemented these levels are mapped corresponding the mapping implemented the slfjbridgehandler which installed this logging system 
WITHOUT_CLASSIFICATION	 not the first the path needs the path variable updated 
WITHOUT_CLASSIFICATION	 ivy can resolve files from multiple hosts need look all the possible urls used the ivy resolver identify all the repositories 
WITHOUT_CLASSIFICATION	 when age verified since the start this build assume the metadata hasnt changed 
WITHOUT_CLASSIFICATION	 keep this expression 
WITHOUT_CLASSIFICATION	 retrieve content from url and write output 
WITHOUT_CLASSIFICATION	 default eclipse jre paths 
WITHOUT_CLASSIFICATION	 callable extends string 
WITHOUT_CLASSIFICATION	 consider variant aware components with buildable binaries nonbuildables 
WITHOUT_CLASSIFICATION	 the default 
WITHOUT_CLASSIFICATION	 only use this for top level project scripts 
WITHOUT_CLASSIFICATION	 any available visual studio 
WITHOUT_CLASSIFICATION	 todo make plan executor respond changes parallelism configuration 
WITHOUT_CLASSIFICATION	 todo change the default location for these reports follow the convention defined 
WITHOUT_CLASSIFICATION	 nothing 
WITHOUT_CLASSIFICATION	 application classloader inspect class collect the classpath for 
WITHOUT_CLASSIFICATION	 not include moduleinfo files they would represent bundled dependency module instead gradle itself 
WITHOUT_CLASSIFICATION	 might leave that decide its good idea for extra safety net 
WITHOUT_CLASSIFICATION	 user scope expected persisted the global cache since 
WITHOUT_CLASSIFICATION	 the matching very simple the moment but should solve majority cases operates using stringcontains and tests either requested selected module 
WITHOUT_CLASSIFICATION	 move default values into body closure they can use inputslvar 
WITHOUT_CLASSIFICATION	 check that given daemon still exists registry daemon registry could removed and recreated between checks 
WITHOUT_CLASSIFICATION	 could make resolvedependencies cache its result for later use generateideamodule 
WITHOUT_CLASSIFICATION	 need validate that the selected configuration still matches the consumer attributes note that this validation only occurs when null otherwise would select with attribute matching 
WITHOUT_CLASSIFICATION	 rename project dependencies 
WITHOUT_CLASSIFICATION	 convert swiftlike macros map like nativecompilespec expects 
WITHOUT_CLASSIFICATION	 todohh 
WITHOUT_CLASSIFICATION	 will create ivyxml even for maven publishing long true 
WITHOUT_CLASSIFICATION	 the directory now empty delete 
WITHOUT_CLASSIFICATION	 take deep copy the compilerargs because the following methods mutate 
WITHOUT_CLASSIFICATION	 note might make sense respect percompiletask log level 
WITHOUT_CLASSIFICATION	 prefer bit tools when building bit 
WITHOUT_CLASSIFICATION	 separating whitespace between the define and the name 
WITHOUT_CLASSIFICATION	 dont decorate everything buildlistener just 
WITHOUT_CLASSIFICATION	 dont have this right now simulate reaching the tree 
WITHOUT_CLASSIFICATION	 nothing 
WITHOUT_CLASSIFICATION	 can get duplicate start events 
WITHOUT_CLASSIFICATION	 copy builtondemand state 
WITHOUT_CLASSIFICATION	 lower equal priority but higher version keep higher scope and exclusions 
WITHOUT_CLASSIFICATION	 any available visual studio 
WITHOUT_CLASSIFICATION	 check module static imports for static inner classes 
WITHOUT_CLASSIFICATION	 because need the attributes computes lazily too because component metadata rules 
WITHOUT_CLASSIFICATION	 type extends 
WITHOUT_CLASSIFICATION	 generate new getconvention 
WITHOUT_CLASSIFICATION	 only download parallel there more than component download 
WITHOUT_CLASSIFICATION	 otherwise just reuse previous result 
WITHOUT_CLASSIFICATION	 rethrow the first failure 
WITHOUT_CLASSIFICATION	 this does not change 
WITHOUT_CLASSIFICATION	 rare occasions exitvalue when the process expected fail and the error output indicates failure 
WITHOUT_CLASSIFICATION	 create antlrtask for this sourceset following the gradle 
WITHOUT_CLASSIFICATION	 track all unused labels display future progress operation 
WITHOUT_CLASSIFICATION	 include binary when the target project not included the workspace 
WITHOUT_CLASSIFICATION	 collect changes that would trigger rebuild 
WITHOUT_CLASSIFICATION	 there cause its invalid name exception 
WITHOUT_CLASSIFICATION	 todo add 
WITHOUT_CLASSIFICATION	 already started 
WITHOUT_CLASSIFICATION	 start task execution necessary this required for building plugin artifacts since these are built ondemand prior the regular start signal for included builds 
WITHOUT_CLASSIFICATION	 only expand the thread pool there work the queue know that work about submitted force true 
WITHOUT_CLASSIFICATION	 from this point down the daemon busy 
WITHOUT_CLASSIFICATION	 callables 
WITHOUT_CLASSIFICATION	 new module replacement module weve seen already register conflict and return 
WITHOUT_CLASSIFICATION	 builds old model resolved dependency graph based the result events 
WITHOUT_CLASSIFICATION	 any available swift compiler 
WITHOUT_CLASSIFICATION	 have not visited this node yet push its successors onto the queue front this node and visit them 
WITHOUT_CLASSIFICATION	 this special case for backwards compatibility possible have cycle where the root component depends library which transitively depends different version the root module this case effectively allow modules have the same capability filter the nodes coming from transitive dependencies 
WITHOUT_CLASSIFICATION	 any the input values are not available for this selection ignore the rule 
WITHOUT_CLASSIFICATION	 throw new viewtypeclass 
WITHOUT_CLASSIFICATION	 add description only the first module 
WITHOUT_CLASSIFICATION	 order significant 
WITHOUT_CLASSIFICATION	 when writing file into the filestore marker file with this suffix written alongside then removed after the write this used detect partially written files due serious crash and silently clean them 
WITHOUT_CLASSIFICATION	 any available visual studio 
WITHOUT_CLASSIFICATION	 the file names passed are canonicalised the jvm when creates the system classloader and the file names are lost they happen refer links for example into the gradle artifact cache try reconstitute the file names from the system classpath 
WITHOUT_CLASSIFICATION	 can null tests resolvestate cannot mocked can null tests componentstate cannot mocked 
WITHOUT_CLASSIFICATION	 generate args 
WITHOUT_CLASSIFICATION	 only use for system javagroovy classes arbitrary use the build classpath will result classjar leaks 
WITHOUT_CLASSIFICATION	 snapshot poms use snapshot instead the timestamp version validate against the expected 
WITHOUT_CLASSIFICATION	 need resolve type parameters the method from the same class 
WITHOUT_CLASSIFICATION	 any available visual studio 
WITHOUT_CLASSIFICATION	 throw away all state between builds 
WITHOUT_CLASSIFICATION	 note this here override the default groovy collectionfindall method 
WITHOUT_CLASSIFICATION	 not yet implemented 
WITHOUT_CLASSIFICATION	 collect only the shortest paths 
WITHOUT_CLASSIFICATION	 this configuration child toadd need add 
WITHOUT_CLASSIFICATION	 reached the end input worker has exited without failing 
WITHOUT_CLASSIFICATION	 dont evaluate children see know its without validating 
WITHOUT_CLASSIFICATION	 collect any container level add actions then add the object specific action 
WITHOUT_CLASSIFICATION	 should ask the annotation handler figure this out instead 
WITHOUT_CLASSIFICATION	 transient fields 
WITHOUT_CLASSIFICATION	 have alter the type the artifact match what published 
WITHOUT_CLASSIFICATION	 cannot configure slfj logger this will happen tests are executed with custom classloader using tests are run with modulepath effectively hiding gradle classes 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 any available visual studio 
WITHOUT_CLASSIFICATION	 then 
WITHOUT_CLASSIFICATION	 search the standard installation locations 
WITHOUT_CLASSIFICATION	 not consider injecting constructors public api 
WITHOUT_CLASSIFICATION	 for now requires implies prefers and strictly implies requires only publish the defining constraint 
WITHOUT_CLASSIFICATION	 clear the users environment 
WITHOUT_CLASSIFICATION	 order optimised for humans looking the log 
WITHOUT_CLASSIFICATION	 where the transform class loaded from 
WITHOUT_CLASSIFICATION	 for test suites including suitelike custom runners the test suite class matches the filter run the entire suite instead filtering away its contents 
WITHOUT_CLASSIFICATION	 not holding the cache lock flush done notify flush thread and continue 
WITHOUT_CLASSIFICATION	 attribute name 
WITHOUT_CLASSIFICATION	 include file graph for this source file has not changed skip this file 
WITHOUT_CLASSIFICATION	 when deriving variants for the java ecosystem actually have components mixed together the library and the platform and theres way figure out what was the intent when was published derive variants but also need use generic javaapi and javaruntime attributes instead more precise javaapijars and javaruntimejars because the platform aspect which arent jars but something using javaapijars for the library part and javaapi for the platform would lead selection the platform when dont want them other words single component cannot mix precise usages with more generic ones 
WITHOUT_CLASSIFICATION	 there are only enough entries make block move the entries the left sibling into this block and discard the left sibling might also need merge the parent 
WITHOUT_CLASSIFICATION	 jgit properties work from their relocated locations and conflict they are left place 
WITHOUT_CLASSIFICATION	 attempt determine whether the compiler the correct implementation 
WITHOUT_CLASSIFICATION	 dont know about this kind archive task 
WITHOUT_CLASSIFICATION	 compile all secondary routes files first 
WITHOUT_CLASSIFICATION	 read configuration from stdin 
WITHOUT_CLASSIFICATION	 since need access the method and that its weakly referenced always need double check that hasnt been collected 
WITHOUT_CLASSIFICATION	 found the first project dependency 
WITHOUT_CLASSIFICATION	 the java plugin applied want express that the compile and runtime variants are mapped some attributes which can used the version mapping strategy this only required for pom publication because the variants have implicit attributes that want explicit for matching 
WITHOUT_CLASSIFICATION	 fail fast this should not happen 
WITHOUT_CLASSIFICATION	 only unpack one level providers since providerprovider not supported dont need two levels laziness 
WITHOUT_CLASSIFICATION	 must prepare bind inputs first 
WITHOUT_CLASSIFICATION	 one more followed one more nonwildcard matches above 
WITHOUT_CLASSIFICATION	 already handled elsewhere 
WITHOUT_CLASSIFICATION	 close all streams and redirect 
WITHOUT_CLASSIFICATION	 theres more than group merge them into group set 
WITHOUT_CLASSIFICATION	 keeps the class set analysis the given javacompile task 
WITHOUT_CLASSIFICATION	 this test class should loaded via the custom system classloader 
WITHOUT_CLASSIFICATION	 thisgetclass 
WITHOUT_CLASSIFICATION	 implementation classpath has been provided just use the application classloader 
WITHOUT_CLASSIFICATION	 read entire response 
WITHOUT_CLASSIFICATION	 didnt find node path 
WITHOUT_CLASSIFICATION	 already invoking method the mixin 
WITHOUT_CLASSIFICATION	 compare static selectors semantically 
WITHOUT_CLASSIFICATION	 remove compile and ast types from the groovy loader 
WITHOUT_CLASSIFICATION	 now handle dirs 
WITHOUT_CLASSIFICATION	 have visited all this nodes successors 
WITHOUT_CLASSIFICATION	 kotlin passes these types for its own basic types 
WITHOUT_CLASSIFICATION	 subclass hook allowing fake the context for testing 
WITHOUT_CLASSIFICATION	 enhance already reported failures 
WITHOUT_CLASSIFICATION	 checks candidate project dependent the origin project with given configuration 
WITHOUT_CLASSIFICATION	 will removed 
WITHOUT_CLASSIFICATION	 replacement candidates are the only important candidates 
WITHOUT_CLASSIFICATION	 only cache the result parsing the maven settings files but allow this value updated inflight via system properties this allows the local maven repo overridden when publishing maven see 
WITHOUT_CLASSIFICATION	 fact check here for 
WITHOUT_CLASSIFICATION	 inject missing interfaces support the usage plugins compiled with older gradle versions normal gradle build does this adding the the class loader hierarchy test run which essentially plain java application the classpath flattened and injected into the system class loader and there exists gradle class loader hierarchy the running test see implementation and gradleworkermain thus inject the missing interfaces directly into the system class loader used load all classes the test 
WITHOUT_CLASSIFICATION	 need lock the cache order write the module metadata store 
WITHOUT_CLASSIFICATION	 put var foo the stack push the constant class onto the stack push int interpreted true false onto the stack 
WITHOUT_CLASSIFICATION	 optimization first check the method name among the candidates before construct equivalence wrapper 
WITHOUT_CLASSIFICATION	 need perform the actual resolve 
WITHOUT_CLASSIFICATION	 else unchanged check next file 
WITHOUT_CLASSIFICATION	 fall back standard out 
WITHOUT_CLASSIFICATION	 token concatenation only allowed inside define body arbitrary tokens wont resolve include path treat both these cases unresolvable include directive 
WITHOUT_CLASSIFICATION	 track currently associated label with its progress operation 
WITHOUT_CLASSIFICATION	 couldnt find registration for the given type 
WITHOUT_CLASSIFICATION	 creating before locking have create the most flexible setup 
WITHOUT_CLASSIFICATION	 try reconstruct the exception 
WITHOUT_CLASSIFICATION	 attempt merge with the right sibling 
WITHOUT_CLASSIFICATION	 have exclusive lock whether asked for not 
WITHOUT_CLASSIFICATION	 already the front not the front need recreate 
WITHOUT_CLASSIFICATION	 copy configuration from parent descriptor 
WITHOUT_CLASSIFICATION	 setter methods for the above assume weve defined them 
WITHOUT_CLASSIFICATION	 list modules based metadata files but only wont check for mavenmetadata which preferred 
WITHOUT_CLASSIFICATION	 used integration tests 
WITHOUT_CLASSIFICATION	 endcustomtaskclass 
WITHOUT_CLASSIFICATION	 note there deliberately internal synchronizing caching this level class generation should performed behind managedproxyfactory 
WITHOUT_CLASSIFICATION	 should use instantiatorfactory instead pick some validation but this currently somewhat expensive 
WITHOUT_CLASSIFICATION	 todo add other build like files buildgradlekts settingsgradlekts other gradle gradleproperties 
WITHOUT_CLASSIFICATION	 something else may have removed 
WITHOUT_CLASSIFICATION	 changed since last execution possibly another task 
WITHOUT_CLASSIFICATION	 this can happen when method fails which this method depends 
WITHOUT_CLASSIFICATION	 dynamicobjecthelper init return dynamicobjecthelper 
WITHOUT_CLASSIFICATION	 transforms not require project state 
WITHOUT_CLASSIFICATION	 the only reason for this unit test verify that being thrown when many patterns are passed getpatternsmatcher see 
WITHOUT_CLASSIFICATION	 todo intset 
WITHOUT_CLASSIFICATION	 generate public conventionmapping 
WITHOUT_CLASSIFICATION	 make sure can store order well have surprises deserialization 
WITHOUT_CLASSIFICATION	 inputslvar inputsfield 
WITHOUT_CLASSIFICATION	 default packages not contain classes like these 
WITHOUT_CLASSIFICATION	 include the display name anyway 
WITHOUT_CLASSIFICATION	 endcustomtaskclass 
WITHOUT_CLASSIFICATION	 its important that not block waiting for the lock while holding the project mutation lock doing can lead deadlocks 
WITHOUT_CLASSIFICATION	 ignored class ignore the event dont get testignored events for each method have generate them our own 
WITHOUT_CLASSIFICATION	 package private accessor used for performance reasons 
WITHOUT_CLASSIFICATION	 filecollection isa iterable buildable and check before checking for these things 
WITHOUT_CLASSIFICATION	 there least one candidate which does not provide this attribute 
WITHOUT_CLASSIFICATION	 matches task 
WITHOUT_CLASSIFICATION	 todo validations method synthetic bridge methods varargs abstract native 
WITHOUT_CLASSIFICATION	 non leading 
WITHOUT_CLASSIFICATION	 already seen this class skip 
WITHOUT_CLASSIFICATION	 iterate over unicode characters 
WITHOUT_CLASSIFICATION	 get the metadata first see its there 
WITHOUT_CLASSIFICATION	 should use some variation defaultclassmap below associate values with classes currently retain strong reference each value for one session after the classloader for the entrys key discarded which unnecessary because wont attempt locate the entry again once the classloader has been discarded 
WITHOUT_CLASSIFICATION	 when the artifacts declared component are modified for publishing then the maven publication longer represents the underlying java component instead publishing incorrect metadata fail any attempt publish the module metadata the long term will likely prevent any modification artifacts added from component instead will make easier modify the components produced project allowing the published metadata accurately reflect the local component metadata 
WITHOUT_CLASSIFICATION	 sourceset has access configurations where could ask for lenient view this means have deal with possible dependency resolution issues here catch and log the exceptions here that the eclipse model can generated even there are unresolvable dependencies defined the configuration can probably better inspecting the runtime classpath and finding out which configurations are part and only traversing any extra file collections manually 
WITHOUT_CLASSIFICATION	 remove the daemon starting message 
WITHOUT_CLASSIFICATION	 need take copy prevent 
WITHOUT_CLASSIFICATION	 ignore overrides object and groovyobject methods 
WITHOUT_CLASSIFICATION	 this default ever changed ensure the documentation pathsensitive updated well this guide 
WITHOUT_CLASSIFICATION	 index the artifact set the the artifact set but reversed when sort order dependency first 
WITHOUT_CLASSIFICATION	 important return must closed when done with 
WITHOUT_CLASSIFICATION	 check jar exists 
WITHOUT_CLASSIFICATION	 add all included builds from the commandline 
WITHOUT_CLASSIFICATION	 absolute coordinate system 
WITHOUT_CLASSIFICATION	 done writing data release any resources 
WITHOUT_CLASSIFICATION	 assume all the other compilers are they happen installed 
WITHOUT_CLASSIFICATION	 the public result for the configuration has been calculated error change anything that would change the dependencies artifacts 
WITHOUT_CLASSIFICATION	 jvm args that must used for the build jvm 
WITHOUT_CLASSIFICATION	 generate args instanceof object args new object args 
WITHOUT_CLASSIFICATION	 tag name 
WITHOUT_CLASSIFICATION	 generate public metaclass getmetaclass 
WITHOUT_CLASSIFICATION	 this should pass the time 
WITHOUT_CLASSIFICATION	 generate public convention getconvention return 
WITHOUT_CLASSIFICATION	 callable extends 
WITHOUT_CLASSIFICATION	 reuse parent label possible 
WITHOUT_CLASSIFICATION	 need ensure that the conflict orderly injected the list conflicts brand new conflict goes the end find any matching conflict have hook with 
WITHOUT_CLASSIFICATION	 any swift compiler 
WITHOUT_CLASSIFICATION	 nothing since the only side effect that wouldnt able log the plugin descriptor file name shouldnt reasonable scenario where this occurs since these descriptors should generated from real files 
WITHOUT_CLASSIFICATION	 there known last descriptor associate with the root test suite 
WITHOUT_CLASSIFICATION	 this internal option its used options the backdoor switch used set described comment helper this option was introduced jdk and controls compilers name tables should reused without this option being set they are stored static list using soft references which can lead memory pressure and performance deterioration when using the daemon especially when using small heap and building large project due bug instances sharednametable are actually ever reused has been fixed for jdk and should consider not using this option with jdk not using will quite probably improve the performance compilation using this option leads significant performance improvements when using daemon and compiling java sources with jdk and jdk 
WITHOUT_CLASSIFICATION	 cleanup 
WITHOUT_CLASSIFICATION	 there nothing done 
WITHOUT_CLASSIFICATION	 note used generated subtypes 
WITHOUT_CLASSIFICATION	 invalid lock state need real resolution gather locking failures 
WITHOUT_CLASSIFICATION	 apply strategies for all variants 
WITHOUT_CLASSIFICATION	 not single candidate 
WITHOUT_CLASSIFICATION	 exclude the dependencies already provided scalacontainer prevents problems with eclipse scala plugin 
WITHOUT_CLASSIFICATION	 sibling node 
WITHOUT_CLASSIFICATION	 when the state changes shouldrun the dependencies need reprocessed since they also may required now 
WITHOUT_CLASSIFICATION	 node must the predecessor state before calculating dependencies 
WITHOUT_CLASSIFICATION	 note populates the generationplans map 
WITHOUT_CLASSIFICATION	 path prefix 
WITHOUT_CLASSIFICATION	 since use the main source set need make sure the compile classpath and runtime classpath are properly configured 
WITHOUT_CLASSIFICATION	 add files static archive creating required dont write message standard error when creating archive create object file index equivalent running ranlib 
WITHOUT_CLASSIFICATION	 trailing slash name indicates entry directory 
WITHOUT_CLASSIFICATION	 exclude tasks from buildsrc 
WITHOUT_CLASSIFICATION	 initialize and collect any new outgoing edges this node 
WITHOUT_CLASSIFICATION	 dont need anything 
WITHOUT_CLASSIFICATION	 select the first variant 
WITHOUT_CLASSIFICATION	 already hold the project lock for this project 
WITHOUT_CLASSIFICATION	 initial state only path and some projections are known here all projections are defined private data has been created initial rules discovered default values have been applied 
WITHOUT_CLASSIFICATION	 the worker has not reported memory usage yet for some reason does not support 
WITHOUT_CLASSIFICATION	 for example hey skipped foobarbaz uptodate but not foo 
WITHOUT_CLASSIFICATION	 without the parent hangs without receiving the message above flushing does not help 
WITHOUT_CLASSIFICATION	 save name before redirect 
WITHOUT_CLASSIFICATION	 wrap the result processor chain blocking actor make the whole thing threadsafe 
WITHOUT_CLASSIFICATION	 httpclient used parameter public method 
WITHOUT_CLASSIFICATION	 path descendant this 
WITHOUT_CLASSIFICATION	 overrides the global currently need have the parent parameter 
WITHOUT_CLASSIFICATION	 resolve the dependency graph 
WITHOUT_CLASSIFICATION	 have matching component that was rejected these are handled later the resolution process after conflict resolution not failure this stage 
WITHOUT_CLASSIFICATION	 dont serialize the causes well serialize them separately later 
WITHOUT_CLASSIFICATION	 variants 
WITHOUT_CLASSIFICATION	 nothing found second pass 
WITHOUT_CLASSIFICATION	 autoapplied plugins available 
WITHOUT_CLASSIFICATION	 ignore the node the other builds execution graph takes care this 
WITHOUT_CLASSIFICATION	 only there are conf defined sub elements 
WITHOUT_CLASSIFICATION	 new top level node implicitly finish the previous node 
WITHOUT_CLASSIFICATION	 use eclipseproject reference project 
WITHOUT_CLASSIFICATION	 when running test daemon executer the input buffered until newline char received 
WITHOUT_CLASSIFICATION	 could better job figuring this out 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 theory dont need the synchronized here but lets safer the beginning 
WITHOUT_CLASSIFICATION	 maven repos are handled mavenplugin 
WITHOUT_CLASSIFICATION	 ignore inner classes 
WITHOUT_CLASSIFICATION	 avoid iterating candidates theres requested attribute 
WITHOUT_CLASSIFICATION	 fail fast 
WITHOUT_CLASSIFICATION	 run any actions addmodify dependencies 
WITHOUT_CLASSIFICATION	 keep until the listener created 
WITHOUT_CLASSIFICATION	 need wrap all dependencies force them 
WITHOUT_CLASSIFICATION	 configures the project and all its subprojects including task discovery and binding model rules 
WITHOUT_CLASSIFICATION	 since java version should instead however keep backward compatibility change from 
WITHOUT_CLASSIFICATION	 that dont miss out default tasks 
WITHOUT_CLASSIFICATION	 macos assume colocated xcode installed into optxcode and default location need search for clang differently macos because need know the xcode version for support 
WITHOUT_CLASSIFICATION	 clean the interrupted status because some test class processors work here junitplatform 
WITHOUT_CLASSIFICATION	 iterate from the inner most the outer and check for classes this check will ignore class property for example integerclass will propertyexpression with the classexpression integer objectexpression 
WITHOUT_CLASSIFICATION	 there setter for this property 
WITHOUT_CLASSIFICATION	 know that were running singlethreaded here can use lenient project locking 
WITHOUT_CLASSIFICATION	 use static private methods because privateprotected methods are disallowed managed types 
WITHOUT_CLASSIFICATION	 path iterable but dont want unpack 
WITHOUT_CLASSIFICATION	 source file has changed 
WITHOUT_CLASSIFICATION	 skip prebuilt libraries 
WITHOUT_CLASSIFICATION	 methods 
WITHOUT_CLASSIFICATION	 not attached console 
WITHOUT_CLASSIFICATION	 broke out the comparison because there was difference can reuse the snapshot the new element 
WITHOUT_CLASSIFICATION	 else throw away 
WITHOUT_CLASSIFICATION	 any the ansi sequences 
WITHOUT_CLASSIFICATION	 modelregistry methods 
WITHOUT_CLASSIFICATION	 add assemble task for each binary and also wire the development binary the assemble task 
WITHOUT_CLASSIFICATION	 configure verbosely only arguments not specify any log level 
WITHOUT_CLASSIFICATION	 the selector failed the module has been deselected not attach 
WITHOUT_CLASSIFICATION	 see 
WITHOUT_CLASSIFICATION	 always assume candidate from lock will satisfy the latest version selector 
WITHOUT_CLASSIFICATION	 map the arguments the argument from this expression 
WITHOUT_CLASSIFICATION	 mix groovy dsl 
WITHOUT_CLASSIFICATION	 class root package should not happen 
WITHOUT_CLASSIFICATION	 with lower case letter anymore 
WITHOUT_CLASSIFICATION	 this published artifact 
WITHOUT_CLASSIFICATION	 cancel opwrite selection 
WITHOUT_CLASSIFICATION	 user likely doesnt care about daemons that stopped long time ago 
WITHOUT_CLASSIFICATION	 mappings between public and impl types the list mappings grows should move data structure 
WITHOUT_CLASSIFICATION	 remove the handler 
WITHOUT_CLASSIFICATION	 precompute the hashcode its going used anyway and this object used key several hash maps 
WITHOUT_CLASSIFICATION	 any available gcc implementation including mingw cygwin but not clang 
WITHOUT_CLASSIFICATION	 note this may temporary measure while existing infrastructure being ported managed model elements 
WITHOUT_CLASSIFICATION	 invoke the setter method pick type coercion 
WITHOUT_CLASSIFICATION	 end 
WITHOUT_CLASSIFICATION	 know its archive but not what kind archive know its artifact but thats all know for sure 
WITHOUT_CLASSIFICATION	 adding optional dependency see already have hard dependency the same module 
WITHOUT_CLASSIFICATION	 generate public returntype settertype returntype supersetterv prop true return 
WITHOUT_CLASSIFICATION	 rewrite the method call match closure which what the delegate will 
WITHOUT_CLASSIFICATION	 filter imported classes which are not available yet 
WITHOUT_CLASSIFICATION	 this method returns the dependencies buckets projects first then modules then files because thats what used since would better return the dependencies the same order they come from the resolver but well need change all the tests for that defer that until later 
WITHOUT_CLASSIFICATION	 must higher than this scope needs cache repository services 
WITHOUT_CLASSIFICATION	 guard against edge cases junit classes with custom runners that report the class ignored after reporting started 
WITHOUT_CLASSIFICATION	 default xcode installation 
WITHOUT_CLASSIFICATION	 another thread holds the lock release the project lock and wait for the other thread finish 
WITHOUT_CLASSIFICATION	 transitive dependency 
WITHOUT_CLASSIFICATION	 all dependencies visited 
WITHOUT_CLASSIFICATION	 limit the inner class lookups here using this way only the name will change the packageprefix will not included the lookup the case where the packageprefix really class handled elsewhere warning this code does not expect class that has static inner class defaultimports 
WITHOUT_CLASSIFICATION	 started update the log level 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 not number abd 
WITHOUT_CLASSIFICATION	 same value 
WITHOUT_CLASSIFICATION	 else ignore abstract methods nonabstract classes some other tooling the groovy compiler has decided this 
WITHOUT_CLASSIFICATION	 add the source the source set the include paths resolve any headers that may source directories 
WITHOUT_CLASSIFICATION	 have visited all consumers visit this node 
WITHOUT_CLASSIFICATION	 check custom packaging 
WITHOUT_CLASSIFICATION	 library executable 
WITHOUT_CLASSIFICATION	 matches task arg taskarg 
WITHOUT_CLASSIFICATION	 end the stream 
WITHOUT_CLASSIFICATION	 thrown when jna cannot initialize the native stuff 
WITHOUT_CLASSIFICATION	 throws 
WITHOUT_CLASSIFICATION	 check type extends factory extends elementtype 
WITHOUT_CLASSIFICATION	 could support unfiltered directoryfiletree here cacheable root but because outputdirectory also doesnt support choose not 
WITHOUT_CLASSIFICATION	 these are here just that projectinternal can implement fileoperations work around 
WITHOUT_CLASSIFICATION	 this substitution effectively force 
WITHOUT_CLASSIFICATION	 without this http client prohibits multiple redirects the same location within the same context 
WITHOUT_CLASSIFICATION	 not provided older client versions 
WITHOUT_CLASSIFICATION	 todo locking around this state 
WITHOUT_CLASSIFICATION	 look for parameter substitutions 
WITHOUT_CLASSIFICATION	 getpropertythis name 
WITHOUT_CLASSIFICATION	 eventually convert manifest content utf before handing javautiljarmanifest 
WITHOUT_CLASSIFICATION	 resolve now 
WITHOUT_CLASSIFICATION	 the name the test class 
WITHOUT_CLASSIFICATION	 annotation processor detected need force java stub generation the can process annotations groovy classes are forcing stub generation tricking the groovy compiler into thinking there are java files compile all java files are just passed the compile method the javacompiler and arent processed internally the groovy compiler since were maintaining our own list java files independent whats passed the groovy compiler adding nonexistent java file the sources wont cause any issues 
WITHOUT_CLASSIFICATION	 pass compile everything except buildscript pluginrepositories and plugin requests then run 
WITHOUT_CLASSIFICATION	 update timestamp that working directory not garbage collected 
WITHOUT_CLASSIFICATION	 find first position where values are different 
WITHOUT_CLASSIFICATION	 keep the ordering had earlier gradle versions 
WITHOUT_CLASSIFICATION	 all localcached options failed get directly 
WITHOUT_CLASSIFICATION	 should use stronger modelling for this and make the set tools open rather than hardcoding here 
WITHOUT_CLASSIFICATION	 remove pdb file present 
WITHOUT_CLASSIFICATION	 todo enable this default when toolversion its stable enough 
WITHOUT_CLASSIFICATION	 target module can change this called the result module replacement conflict 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 for project dependencies deduplication ignore scope purpose ignore version because maven doesnt support dependencies with different versions different scopes ignore exclusions because dont know how choosemerge them consequence that use the highest version and the exclusions highest priority dependency when deduplicating use maven dependency management key discriminator 
WITHOUT_CLASSIFICATION	 import checks that stack not empty 
WITHOUT_CLASSIFICATION	 write plain content stdout and rich content stderr 
WITHOUT_CLASSIFICATION	 allow the publication participate incremental build 
WITHOUT_CLASSIFICATION	 nonnull when the result visiting this file can reused 
WITHOUT_CLASSIFICATION	 determine the actual sources cleancompile 
WITHOUT_CLASSIFICATION	 register fact that antlr should run before compiling 
WITHOUT_CLASSIFICATION	 read and verify count 
WITHOUT_CLASSIFICATION	 have cmap should become map 
WITHOUT_CLASSIFICATION	 these versions couldnt handle milestone patches 
WITHOUT_CLASSIFICATION	 only when this node has transitive incoming edge 
WITHOUT_CLASSIFICATION	 todo given that all the closures are from the same file should the relativising once that would entail adding location information the model outer closure 
WITHOUT_CLASSIFICATION	 avoiding implement costly visitor and potentially missing edge cases 
WITHOUT_CLASSIFICATION	 default assume your unix tty can handle ansi codes just wrap that when get closed reset the 
WITHOUT_CLASSIFICATION	 else ignore 
WITHOUT_CLASSIFICATION	 calculated demand 
WITHOUT_CLASSIFICATION	 the operation hasnt finished normally because shortcut error close without cache key 
WITHOUT_CLASSIFICATION	 isopen was added gradle for default true 
WITHOUT_CLASSIFICATION	 used only defaultconf not used for 
WITHOUT_CLASSIFICATION	 context the app under test 
WITHOUT_CLASSIFICATION	 dont anything here older consumers call this method when the project connection closed but then later attempt reuse the connection 
WITHOUT_CLASSIFICATION	 generate 
WITHOUT_CLASSIFICATION	 strategy changes parent configuration not affect this configuration any its children any way 
WITHOUT_CLASSIFICATION	 use the jars when nothing has been requested 
WITHOUT_CLASSIFICATION	 create our own metainf which runs after mainspecs files 
WITHOUT_CLASSIFICATION	 unrecognized expression extra stuff after the expression possibly another expression 
WITHOUT_CLASSIFICATION	 check each unique edge the include file graph 
WITHOUT_CLASSIFICATION	 then use attribute specific mapping 
WITHOUT_CLASSIFICATION	 toadd child implies this configuration 
WITHOUT_CLASSIFICATION	 elements that may may not interesting only for build dependency calculation 
WITHOUT_CLASSIFICATION	 readonly nested property with managed type 
WITHOUT_CLASSIFICATION	 currently only track the major version 
WITHOUT_CLASSIFICATION	 convert the file urls cached jar files 
WITHOUT_CLASSIFICATION	 using transforming classloader only required for older buggy groovy versions 
WITHOUT_CLASSIFICATION	 calling overloaded method with extra behavior 
WITHOUT_CLASSIFICATION	 theres ambiguity but may have several variants matching the requested capabilities here were going check the candidates theres single one strictly matching the requested capabilities 
WITHOUT_CLASSIFICATION	 add these separate specs they are not affected the changes the main spec 
WITHOUT_CLASSIFICATION	 path within its build including project path path within the build tree including project path path the owning build 
WITHOUT_CLASSIFICATION	 compatible daemons available start new daemon 
WITHOUT_CLASSIFICATION	 probably facing jdk 
WITHOUT_CLASSIFICATION	 generate 
WITHOUT_CLASSIFICATION	 badly formed arguments 
WITHOUT_CLASSIFICATION	 new value 
WITHOUT_CLASSIFICATION	 look for provider with that name 
WITHOUT_CLASSIFICATION	 list modules based metadata files artifact version not considered 
WITHOUT_CLASSIFICATION	 this safety net its unsure whether this can happen because its likely certain that for specific module resolve state all selectors are the same type 
WITHOUT_CLASSIFICATION	 conflict resolution choose the best out current selection and candidate 
WITHOUT_CLASSIFICATION	 remove slfj error out like class path contains multiple slfj bindings see 
WITHOUT_CLASSIFICATION	 that the state node when was selected but the selection violates constraint reject strictly 
WITHOUT_CLASSIFICATION	 assuming that the diagnostics were printed out the last line its not bulletproof but seems doing fine 
WITHOUT_CLASSIFICATION	 versions before would log configure successful for modelaction execution but build failed for tasktest execution 
WITHOUT_CLASSIFICATION	 any line except the bottom most one new line simply move the cursor the next row note the next row has lower index 
WITHOUT_CLASSIFICATION	 visit the edges after sorting the components consumerfirst order 
WITHOUT_CLASSIFICATION	 not include implicit builds workspace 
WITHOUT_CLASSIFICATION	 choose explicit variant 
WITHOUT_CLASSIFICATION	 preserve logging headers for progress operations started outside the build operation executor was done gradle 
WITHOUT_CLASSIFICATION	 exclusions optimizations 
WITHOUT_CLASSIFICATION	 use linkedlist for reasons set proved have significant negative impact performance and list will see lot removals which arraylist isnt very well suited for 
WITHOUT_CLASSIFICATION	 only keep track removed options that were present the command line 
WITHOUT_CLASSIFICATION	 something happened but dont know what 
WITHOUT_CLASSIFICATION	 cannot clean progress markers progress files here because the file system visitor stuff cant handle the file system mutating while visiting 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 use gradleproject reference project 
WITHOUT_CLASSIFICATION	 check see there are any compatible idle daemons 
WITHOUT_CLASSIFICATION	 maven adds inherited dependencies last 
WITHOUT_CLASSIFICATION	 system class skip 
WITHOUT_CLASSIFICATION	 never swallow javalangerror 
WITHOUT_CLASSIFICATION	 remove the expiring daemon message 
WITHOUT_CLASSIFICATION	 make sure that map only contains booleantrue and booleanfalse values and other boolean instances this necessary because the compile spec doesnt preserve but creates new instances 
WITHOUT_CLASSIFICATION	 the contract usecache means have provide some basic synchronization 
WITHOUT_CLASSIFICATION	 this means that the signature was not required and couldnt generate the signature most likely projectrequired false and there signatory just noop 
WITHOUT_CLASSIFICATION	 parsing state 
WITHOUT_CLASSIFICATION	 first step find entry with the explicit inputs the cache 
WITHOUT_CLASSIFICATION	 try deserialize the original exception 
WITHOUT_CLASSIFICATION	 special case some common combinations names and paths 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 with multiple unclassified artifacts choose the one with extension matching pom packaging 
WITHOUT_CLASSIFICATION	 disallow instance fields this doesnt guarantee that the object immutable just makes less likely might tighten this constraint also disallow any code immutable types that reaches out static state 
WITHOUT_CLASSIFICATION	 restore only there was save operation first 
WITHOUT_CLASSIFICATION	 nothing found locally try remote search for all resolve states that were not yet searched remotely 
WITHOUT_CLASSIFICATION	 empty path might match when more elements added 
WITHOUT_CLASSIFICATION	 implements methodmixin not attempt locate opaque method this expensive 
WITHOUT_CLASSIFICATION	 get only the first element here nothing else but collection forces use iterator 
WITHOUT_CLASSIFICATION	 add constructor 
WITHOUT_CLASSIFICATION	 the changes about the interfaces methods will reported already 
WITHOUT_CLASSIFICATION	 dont really need launch the daemon acquire information needed for buildenvironment 
WITHOUT_CLASSIFICATION	 order for the groovy stubs have annotation processors invoked against them they must compiled source classes compiled result being the sourcepath not have the annotation processor run against them 
WITHOUT_CLASSIFICATION	 provide implicit empty argument 
WITHOUT_CLASSIFICATION	 create build configuration the project level from all targets build configuration 
WITHOUT_CLASSIFICATION	 when implementing propertymixin not check for opaque properties this can expensive 
WITHOUT_CLASSIFICATION	 all them were rejected 
WITHOUT_CLASSIFICATION	 object methodmissingstring name object args 
WITHOUT_CLASSIFICATION	 not jar not test 
WITHOUT_CLASSIFICATION	 redraw every entry this area 
WITHOUT_CLASSIFICATION	 this fine just ignore 
WITHOUT_CLASSIFICATION	 todo some representation state the inputs 
WITHOUT_CLASSIFICATION	 prefer use the actual memory usage reported the worker 
WITHOUT_CLASSIFICATION	 order use newer version jna the resources must not available the old location 
WITHOUT_CLASSIFICATION	 exit early are reusing the create actions from the provider 
WITHOUT_CLASSIFICATION	 this shouldnt the case however start and complete events are filtered the prior stage when the logging level lifecycle should instead move the filtering after this stage 
WITHOUT_CLASSIFICATION	 allow currently executing and enforced tasks complete but skip everything else 
WITHOUT_CLASSIFICATION	 generate 
WITHOUT_CLASSIFICATION	 target 
WITHOUT_CLASSIFICATION	 generate object unpackstate state new objectsize statex propfield return state 
WITHOUT_CLASSIFICATION	 callable 
WITHOUT_CLASSIFICATION	 after redirecting need add the new std outerr the renderer singleton 
WITHOUT_CLASSIFICATION	 mark the connection has being handled 
WITHOUT_CLASSIFICATION	 remove classes from core gradle api 
WITHOUT_CLASSIFICATION	 matches task methodcall 
WITHOUT_CLASSIFICATION	 largest free block too small 
WITHOUT_CLASSIFICATION	 this potential nested rule visit method parameters 
WITHOUT_CLASSIFICATION	 generated script class name must unique take advantage this avoid delegation 
WITHOUT_CLASSIFICATION	 count from left screen left most count from bottom screen bottom most from bottom 
WITHOUT_CLASSIFICATION	 need update pending count outside withlocks that dont have race condition where the pending count but child worker lease still held when the parent lease released 
WITHOUT_CLASSIFICATION	 must classrule use the rules class name instead 
WITHOUT_CLASSIFICATION	 default push the local cache 
WITHOUT_CLASSIFICATION	 copied from 
WITHOUT_CLASSIFICATION	 will flush any unterminated lines out synchronously 
WITHOUT_CLASSIFICATION	 default mapping found for this configuration map configuration itself 
WITHOUT_CLASSIFICATION	 check there are any transitive incoming edges all dont traverse not 
WITHOUT_CLASSIFICATION	 thead tdblocktd tddescriptiontd thead 
WITHOUT_CLASSIFICATION	 were asking for runtime variant prefer jars first 
WITHOUT_CLASSIFICATION	 gradlebuild tasks operate with their own build session and tree scope therefore they have their own this prevents them from reusing the build cache configuration defined the root there way detect that gradle instance represents gradlebuild invocation there were that would better heuristic than this 
WITHOUT_CLASSIFICATION	 generate new object args 
WITHOUT_CLASSIFICATION	 logging exception here only needed because default gradle does not show the stack trace 
WITHOUT_CLASSIFICATION	 add attributes applied given the extension 
WITHOUT_CLASSIFICATION	 were asking for api variant prefer jars first for runtime 
WITHOUT_CLASSIFICATION	 nothing 
WITHOUT_CLASSIFICATION	 always append new line eof 
WITHOUT_CLASSIFICATION	 stop super and this 
WITHOUT_CLASSIFICATION	 dont generate method its not part the view schema 
WITHOUT_CLASSIFICATION	 have through uriish and back deal with differences between how java file and git implement file uris 
WITHOUT_CLASSIFICATION	 only check for the last byte multibyte line separator besides this always check for 
WITHOUT_CLASSIFICATION	 nonheap spaces are not garbage collected 
WITHOUT_CLASSIFICATION	 capture all output lazily until two new lines and endoftask designation 
WITHOUT_CLASSIFICATION	 order make sure that the cacheentry not collected while the cached class loader still use need keep strong reference onto 
WITHOUT_CLASSIFICATION	 generate new thisservices 
WITHOUT_CLASSIFICATION	 assume ejb the most common kind ear deployment 
WITHOUT_CLASSIFICATION	 automatically substitute all available modules 
WITHOUT_CLASSIFICATION	 force back configure that task graph will get reevaluated 
WITHOUT_CLASSIFICATION	 avoids creation empty hashset 
WITHOUT_CLASSIFICATION	 full match 
WITHOUT_CLASSIFICATION	 copy one one until the underflow has been resolved 
WITHOUT_CLASSIFICATION	 order important 
WITHOUT_CLASSIFICATION	 static alias only for inner classes and must end chain 
WITHOUT_CLASSIFICATION	 task has already been run this can happen when the owning build used both configuration time and execution time this should move earlier task scheduling that worker thread does not even bother trying run this task 
WITHOUT_CLASSIFICATION	 disallow workinprogress take more than half the console display the screen size unknown allow lines 
WITHOUT_CLASSIFICATION	 repositories 
WITHOUT_CLASSIFICATION	 badly form args list 
WITHOUT_CLASSIFICATION	 default not push the remote cache 
WITHOUT_CLASSIFICATION	 for dependency from another build this build dont make the artifact buildable making these artifacts buildable leads poor error reporting due direct task dependency cycle losing the intervening build dependencies 
WITHOUT_CLASSIFICATION	 this mimics the behavior the ant javac task and therefore antjavacompiler which silently excludes files not ending java 
WITHOUT_CLASSIFICATION	 handle trivial cases with elements both current and previous 
WITHOUT_CLASSIFICATION	 latest only given priority its require 
WITHOUT_CLASSIFICATION	 should run after edges only exist between tasks this cast safe 
WITHOUT_CLASSIFICATION	 called from transformed dsl rules 
WITHOUT_CLASSIFICATION	 noinspection 
WITHOUT_CLASSIFICATION	 there was breaking change after 
WITHOUT_CLASSIFICATION	 use the loaded settings includes the target project based build file project dir current dir 
WITHOUT_CLASSIFICATION	 prefer having javac validate the location over calling first 
WITHOUT_CLASSIFICATION	 thissuper 
WITHOUT_CLASSIFICATION	 create client that will match based the daemon startup parameters 
WITHOUT_CLASSIFICATION	 case one wants synchronize this method bear mind that blocking cannot share the same lock others 
WITHOUT_CLASSIFICATION	 write header 
WITHOUT_CLASSIFICATION	 implementation provided decoration 
WITHOUT_CLASSIFICATION	 should never happen 
WITHOUT_CLASSIFICATION	 network authentication required 
WITHOUT_CLASSIFICATION	 determine the net exclusion for this node inspecting all transitive incoming edges 
WITHOUT_CLASSIFICATION	 failure 
WITHOUT_CLASSIFICATION	 can detect that stdout not tty then setup 
WITHOUT_CLASSIFICATION	 the semantics this method are that the given action should notified the daemon going terminated the end this build not generic outlet for expiry events ideally the value given would describe the problem and not phrased terms why are shutting down but this practical compromise born out piggy backing the expiration listener mechanism implement 
WITHOUT_CLASSIFICATION	 callablestring 
WITHOUT_CLASSIFICATION	 same serialized content value has not changed 
WITHOUT_CLASSIFICATION	 output events 
WITHOUT_CLASSIFICATION	 generate static class generatedfrom 
WITHOUT_CLASSIFICATION	 the hfs file system stores file names decomposed form dont use precomposed characters macos way too few things normalise text correctly 
WITHOUT_CLASSIFICATION	 skip the utf bom 
WITHOUT_CLASSIFICATION	 scan parent class 
WITHOUT_CLASSIFICATION	 temporarily want allow skipping the publication gradle module metadata 
WITHOUT_CLASSIFICATION	 old versions dont send type 
WITHOUT_CLASSIFICATION	 quote probably not perfect todo identify nonworking cases failfast them 
WITHOUT_CLASSIFICATION	 copysourcespec overrides broaden return type 
WITHOUT_CLASSIFICATION	 this will the left most property 
WITHOUT_CLASSIFICATION	 local anonymous class private inner class ignore the reference 
WITHOUT_CLASSIFICATION	 alternate appending packages beginning and end until reach max length 
WITHOUT_CLASSIFICATION	 but all resolved 
WITHOUT_CLASSIFICATION	 jdk does not have days hours minutes normalizing millis 
WITHOUT_CLASSIFICATION	 failure select the target from this component given the dependency attributesmetadata 
WITHOUT_CLASSIFICATION	 all items are complete not release project lock and simply collect failures 
WITHOUT_CLASSIFICATION	 serialize configuration daemon via the process stdin 
WITHOUT_CLASSIFICATION	 adding small set with duplicates 
WITHOUT_CLASSIFICATION	 only need hide main only support short named symbols here 
WITHOUT_CLASSIFICATION	 todo duplicated 
WITHOUT_CLASSIFICATION	 write body 
WITHOUT_CLASSIFICATION	 stop periodic checks 
WITHOUT_CLASSIFICATION	 wire the antlr configuration into all antlr tasks 
WITHOUT_CLASSIFICATION	 task created provider that does not understand launchables 
WITHOUT_CLASSIFICATION	 make sure tree removed exists already 
WITHOUT_CLASSIFICATION	 how and what have parse 
WITHOUT_CLASSIFICATION	 the identity check intentional here not replace with equals 
WITHOUT_CLASSIFICATION	 generate setterv 
WITHOUT_CLASSIFICATION	 that means the current class not innerclassnode 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 only use this for top level settings scripts 
WITHOUT_CLASSIFICATION	 protocolversion lockid type 
WITHOUT_CLASSIFICATION	 special case for events defined prior 
WITHOUT_CLASSIFICATION	 element name 
WITHOUT_CLASSIFICATION	 else already visited 
WITHOUT_CLASSIFICATION	 boolean 
WITHOUT_CLASSIFICATION	 use preemptive authorisation other authorisation has been established 
WITHOUT_CLASSIFICATION	 dont rename other types dependencies 
WITHOUT_CLASSIFICATION	 the isgetter ignored can skip favor the getgetter 
WITHOUT_CLASSIFICATION	 the return type doesnt use generics then its faster just rely the type name directly 
WITHOUT_CLASSIFICATION	 defer creation failures list assume dispatch will succeed 
WITHOUT_CLASSIFICATION	 when groovy coerces closure into sam type then creates proxy which backed the closure want track the implementation the closure since the class name and classloader the proxy will not change 
WITHOUT_CLASSIFICATION	 virtual platforms require their constraints recomputed each time each module addition can cause shift versions 
WITHOUT_CLASSIFICATION	 supports building bit binaries 
WITHOUT_CLASSIFICATION	 remove the daemon will shut down message 
WITHOUT_CLASSIFICATION	 here try avoid using the reg exp backed pattern step expensive terms performance and heap usage there are several special cases handle here literal literal literal literal literal everything else uses reg exp 
WITHOUT_CLASSIFICATION	 failed instantiate blockjunitrunner try deprecated junitrunner for junit 
WITHOUT_CLASSIFICATION	 are the first name part this the right most part this part lower case then not need class check other parts the property expression will tested different method call this method foobarbar can still resolved the class foobar and the static field bar 
WITHOUT_CLASSIFICATION	 ordinary groovy gradle script kotlin gradle script 
WITHOUT_CLASSIFICATION	 the map store minimally populated that contains just the description and the path replace the stored the map iff come across task with the same name whose path has smaller ordering this way for each task selector its description will the one from the selected task with the smallest path 
WITHOUT_CLASSIFICATION	 the enqueue and dequeue methods are used for performance reasons 
WITHOUT_CLASSIFICATION	 remaining methods are here make sure didnt forget anything 
WITHOUT_CLASSIFICATION	 internal counter used track the number outgoing edges that use this selector since module resolve state tracks all selectors for this module when considering selectors that need used when choosing version must only consider the ones which currently have outgoing edges pointing them not then means the module was 
WITHOUT_CLASSIFICATION	 skip processing any operations that both start and complete the queue 
WITHOUT_CLASSIFICATION	 todo change this that extract all the information compile time the moment use the transform validaterestrict the syntax transform rules into something more robust foobarbaz into configurefoobarbaz dynamic propertymissing nonsense hoist out input references into annotation rule closure classes make available this means actually have execute the code block order find the rule information within this also problematic because means have serialize this information into some form that fits into annotations later will extract all the upfront information need know during compile time this will mean that only need execute the rules themselves and not any code actually register the rules 
WITHOUT_CLASSIFICATION	 converts the binaries project library into regular binary instances 
WITHOUT_CLASSIFICATION	 there are only fewer known subtypes render them single column 
WITHOUT_CLASSIFICATION	 not sure this required its the parent already 
WITHOUT_CLASSIFICATION	 worker didnt crash 
WITHOUT_CLASSIFICATION	 classloader scope will handled the cache class will released when the classloader 
WITHOUT_CLASSIFICATION	 deserialize the old value and use the equals implementation this will removed some point 
WITHOUT_CLASSIFICATION	 time interval between the first event the window and the last 
WITHOUT_CLASSIFICATION	 copy case any actions mutate the store linked list because the underlying store may preserve order make best effort not create intermediate collection this container empty 
WITHOUT_CLASSIFICATION	 check classloaders 
WITHOUT_CLASSIFICATION	 flush and clean 
WITHOUT_CLASSIFICATION	 apache commons 
WITHOUT_CLASSIFICATION	 needed use inside lambda below 
WITHOUT_CLASSIFICATION	 pad 
WITHOUT_CLASSIFICATION	 macos looks like test case started linux looks like test case started 
WITHOUT_CLASSIFICATION	 only initialize name child node the schema has such managed property this not the case for managed subtype unmanaged type that implements named 
WITHOUT_CLASSIFICATION	 for all commons attributes make sure they are compatible with each other 
WITHOUT_CLASSIFICATION	 any progressoperation the parent chain has message the operation considered renderable 
WITHOUT_CLASSIFICATION	 configures the project discovers tasks and binds model rules 
WITHOUT_CLASSIFICATION	 html does not like name 
WITHOUT_CLASSIFICATION	 missing parameter name 
WITHOUT_CLASSIFICATION	 visit the selectors 
WITHOUT_CLASSIFICATION	 fallback old behavior always loading the resource 
WITHOUT_CLASSIFICATION	 not quite immutable see immutablepatternset 
WITHOUT_CLASSIFICATION	 should never get here the last strategy should catch all 
WITHOUT_CLASSIFICATION	 add jvm args that were explicitly requested 
WITHOUT_CLASSIFICATION	 before there was scan there was dscan dscantrue dscanyes 
WITHOUT_CLASSIFICATION	 already seen this classloader 
WITHOUT_CLASSIFICATION	 some capabilities are explicitly required other words were not necessarily looking for the default capability need filter the configurations 
WITHOUT_CLASSIFICATION	 there are still more than one candidate but this time know only subset strictly matches the required attributes perform another round selection the remaining candidates 
WITHOUT_CLASSIFICATION	 there has been event 
WITHOUT_CLASSIFICATION	 statements statements that have effect 
WITHOUT_CLASSIFICATION	 noinspection 
WITHOUT_CLASSIFICATION	 installation can located 
WITHOUT_CLASSIFICATION	 matches task arg 
WITHOUT_CLASSIFICATION	 defaults 
WITHOUT_CLASSIFICATION	 xml declarations must located first position first line 
WITHOUT_CLASSIFICATION	 dont progress logging for downloading 
WITHOUT_CLASSIFICATION	 filter unexisting files findbugs cant handle them 
WITHOUT_CLASSIFICATION	 cbzipinputstream expects the opening skipped 
WITHOUT_CLASSIFICATION	 try simplify 
WITHOUT_CLASSIFICATION	 need lock other processes out here because garbage collection can under way another process 
WITHOUT_CLASSIFICATION	 were making assumption that all pre elements contain java code this should mostly true isnt true then the syntax highlighting wont spoil the view too much anyway 
WITHOUT_CLASSIFICATION	 validate that the targetplatform valid 
WITHOUT_CLASSIFICATION	 universal crt required only for 
WITHOUT_CLASSIFICATION	 generate public boolean haspropertystring name return 
WITHOUT_CLASSIFICATION	 checkstyleon 
WITHOUT_CLASSIFICATION	 avoid using reflect since that leads class loading exceptions 
WITHOUT_CLASSIFICATION	 skip over stack trace 
WITHOUT_CLASSIFICATION	 thead tdmethodtd tddescriptiontd thead 
WITHOUT_CLASSIFICATION	 return 
WITHOUT_CLASSIFICATION	 when age verified since the start this build assume listing hasnt changed 
WITHOUT_CLASSIFICATION	 emulate secondary inputs single property for now 
WITHOUT_CLASSIFICATION	 todo push all this stuff down the tool chain and let create the specific platform and provider 
WITHOUT_CLASSIFICATION	 add boolean immutable return true 
WITHOUT_CLASSIFICATION	 dont know about this type 
WITHOUT_CLASSIFICATION	 add the block linenumber argument call pluginsint linenumber closure pluginsblock 
WITHOUT_CLASSIFICATION	 check the params passed the build factory 
WITHOUT_CLASSIFICATION	 failed another thread 
WITHOUT_CLASSIFICATION	 called when some other problem occurs 
WITHOUT_CLASSIFICATION	 project involved need aware 
WITHOUT_CLASSIFICATION	 store this because localedefault mutable and want the unchanged default are assuming this class will initialized before any code has chance change the default 
WITHOUT_CLASSIFICATION	 only fire once 
WITHOUT_CLASSIFICATION	 not leaf node move entry from leaf node then possibly merge the leaf node 
WITHOUT_CLASSIFICATION	 the configuration can still mutated need create composite 
WITHOUT_CLASSIFICATION	 disabled before release due not wanting validate task names which may contain invalid chars least not yet 
WITHOUT_CLASSIFICATION	 last group what ever left take that replace all characters that are not alphanum 
WITHOUT_CLASSIFICATION	 else the provider incompatible type maybe have domain object collection provider fallthrough 
WITHOUT_CLASSIFICATION	 todo default branch can different from just master 
WITHOUT_CLASSIFICATION	 only create intermediate collection theres something copy 
WITHOUT_CLASSIFICATION	 convert the utf manifest bytes the requested content charset 
WITHOUT_CLASSIFICATION	 same above have wrapped closure closurebackedaction want 
WITHOUT_CLASSIFICATION	 theres explicit dependency from consuming node destroyer then accept that the will the user 
WITHOUT_CLASSIFICATION	 check that groovy visible 
WITHOUT_CLASSIFICATION	 but visible the surrounding class imported and the inner class publicprotected static 
WITHOUT_CLASSIFICATION	 wire the task into the library model 
WITHOUT_CLASSIFICATION	 set the context classloader the bootstrap classloader work around the way that jaxp locates implementation classes this should ensure that the jaxp classes provided the jvm are used rather than some other implementation 
WITHOUT_CLASSIFICATION	 matches task expression operator expression 
WITHOUT_CLASSIFICATION	 todo removing debug from variant name keep parity with previous gradle version tooling models 
WITHOUT_CLASSIFICATION	 use random prefix avoid reusing test directories 
WITHOUT_CLASSIFICATION	 fast path for two 
WITHOUT_CLASSIFICATION	 ignore deal with this problem later 
WITHOUT_CLASSIFICATION	 looks the correct project registry for this binary 
WITHOUT_CLASSIFICATION	 have visited this nodes dependencies add the graph 
WITHOUT_CLASSIFICATION	 same size and differences 
WITHOUT_CLASSIFICATION	 textarea status line but nothing was written this means new line was just written while wait for additional text assume this row doesnt count overlapping and use status line the opposite case want scroll the progress area one more line this avoid having one 
WITHOUT_CLASSIFICATION	 add artifact format implicit attribute when all artifacts have the same format 
WITHOUT_CLASSIFICATION	 todo extract common stuff from this and modelset and reuse 
WITHOUT_CLASSIFICATION	 allow null valid input the default disallow null pwhen this enabled all converters must null safe todo attach the null safety each converter and infer whether null valid input not 
WITHOUT_CLASSIFICATION	 longer supported later versions visual studio 
WITHOUT_CLASSIFICATION	 todo this belongs with the var data structure 
WITHOUT_CLASSIFICATION	 dependencies 
WITHOUT_CLASSIFICATION	 see jls binary compatibility 
WITHOUT_CLASSIFICATION	 this could probably more efficient 
WITHOUT_CLASSIFICATION	 else ignore 
WITHOUT_CLASSIFICATION	 not already known attempt selfclose the parent 
WITHOUT_CLASSIFICATION	 todo introduce new var data structure that allows these conventions configured explicitly 
WITHOUT_CLASSIFICATION	 calculate the actual type 
WITHOUT_CLASSIFICATION	 clear environment variables that might effect clexe linkexe 
WITHOUT_CLASSIFICATION	 save the existing object being deserialized 
WITHOUT_CLASSIFICATION	 does nothing 
WITHOUT_CLASSIFICATION	 its possible that receive output for suite here this case will create the test result for suite that normally would not created feels like this scenario should modelled more explicitly 
WITHOUT_CLASSIFICATION	 check the normal metadata first 
WITHOUT_CLASSIFICATION	 mark this version rejected 
WITHOUT_CLASSIFICATION	 lets override this that delegate isnt created autowiring time which would mean every build 
WITHOUT_CLASSIFICATION	 was previously traversed and change the set modules that are linked outgoing edges dont need traverse again but hang the new filter since may change the set excluded artifacts 
WITHOUT_CLASSIFICATION	 jansi required log errors when generating groovydoc 
WITHOUT_CLASSIFICATION	 for now just collect this another dependency todo collect this information and merge the metadata from the other module 
WITHOUT_CLASSIFICATION	 shortcircuit selector merging for single selector without prefer 
WITHOUT_CLASSIFICATION	 note the intention here work towards not having create new objects meet the notification object interfaces instead the base types like should implement them natively however this will require restructuring this type and associated things such operationstartevent this will happen later 
WITHOUT_CLASSIFICATION	 might able use cachedlocally available version 
WITHOUT_CLASSIFICATION	 todo combine with 
WITHOUT_CLASSIFICATION	 read shared packages 
WITHOUT_CLASSIFICATION	 not forward events for rendering when there are listeners receive 
WITHOUT_CLASSIFICATION	 ignore some broken samples 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 when test completed should redirect output for the parent that log events emitted during aftersuite afterclass are processed 
WITHOUT_CLASSIFICATION	 add more data patterns the default configuration work around 
WITHOUT_CLASSIFICATION	 build strongly typed mergeable exclude spec for each supplied rule 
WITHOUT_CLASSIFICATION	 otherwise already have result reuse 
WITHOUT_CLASSIFICATION	 end path might match when more elements added 
WITHOUT_CLASSIFICATION	 all the interfaces that decorate have void methods noinspection constantconditions 
WITHOUT_CLASSIFICATION	 toodlptr should just relative path 
WITHOUT_CLASSIFICATION	 first match just record the value cant use null the candidate value may null 
WITHOUT_CLASSIFICATION	 todo the scope information superseded test attributes can delete the corresponding code bits once make sure that the majority buildship users use test sources 
WITHOUT_CLASSIFICATION	 this configurations version conflict not traverse none the incoming edges are transitive remove previous state and not traverse not traversed before simply add all selected outgoing edges either hard pending edges traversed before net exclusions for this node have not changed ignore net exclusions for this node not changed remove previous state and traverse outgoing edges again 
WITHOUT_CLASSIFICATION	 selected for the configuration 
WITHOUT_CLASSIFICATION	 forward output immediately when the focus this operation group 
WITHOUT_CLASSIFICATION	 note that compileclasspath here approximation and must fixed before deincubating see 
WITHOUT_CLASSIFICATION	 this means the client has not reported memory usage yet 
WITHOUT_CLASSIFICATION	 first let antlr preprocess the grammars 
WITHOUT_CLASSIFICATION	 note currently extract this information from the execution plan because its buried under functions filter this could detangledsimplified introducing analog this too drastic change for the stage the release cycle were exposing this information was necessary therefore the minimal change solution was implemented 
WITHOUT_CLASSIFICATION	 when cancelled try stop the download thread but dont attempt wait for complete could possibly loop here for while trying force the thread exit 
WITHOUT_CLASSIFICATION	 possibly inner class 
WITHOUT_CLASSIFICATION	 file loop exceptions are ignored when encounter loop via symbolic links continue include all the other files apart from the loop this way include each file only once 
WITHOUT_CLASSIFICATION	 when dependency resolution has failed dont want the build operation listeners fail well because the failed method will have been called with the user facing error such error may still lead valid dependency graph 
WITHOUT_CLASSIFICATION	 recreate the invoker when deserialized rather than serialize all its state 
WITHOUT_CLASSIFICATION	 method was only introduced groovy 
WITHOUT_CLASSIFICATION	 generate initobject state 
WITHOUT_CLASSIFICATION	 make convention mapping work least for main and for jvmargs 
WITHOUT_CLASSIFICATION	 found more than one 
WITHOUT_CLASSIFICATION	 rely the default linkage for providing the headers 
WITHOUT_CLASSIFICATION	 unrecognized extension 
WITHOUT_CLASSIFICATION	 the customrunner class will fail this test this class initialized before its run method triggered 
WITHOUT_CLASSIFICATION	 cannot yet publish module metadata without component 
WITHOUT_CLASSIFICATION	 inprocess groovy compilation throws from another classloader hence testing class name equality todopm prefer class over class name for equality check once using workerexecutor for inprocess groovy compilation 
WITHOUT_CLASSIFICATION	 todo not hold lock while computing value 
WITHOUT_CLASSIFICATION	 generate int getfactoryid return factoryidfield 
WITHOUT_CLASSIFICATION	 using the caches for these connections leaves the jar files open dont use the cache that the jar file closed when the stream closed below there are other options for solving this that may more performant however class inspected this way once and the result reused this approach probably fine 
WITHOUT_CLASSIFICATION	 for guessing right side part mapping 
WITHOUT_CLASSIFICATION	 update any previously known files with bogus timestamp force rebuild 
WITHOUT_CLASSIFICATION	 case getting here not checks for partial matches with imported classes the already constructed 
WITHOUT_CLASSIFICATION	 see for examples 
WITHOUT_CLASSIFICATION	 the compilation will generate the new mapping file only merge old mappings into new mapping incremental recompilation 
WITHOUT_CLASSIFICATION	 should using configureutil with delegatefirst strategy however for backwards compatibility need use ownerfirst 
WITHOUT_CLASSIFICATION	 todo calculate this list classes dynamically 
WITHOUT_CLASSIFICATION	 collect incremental input changes 
WITHOUT_CLASSIFICATION	 for groovy need call 
WITHOUT_CLASSIFICATION	 any configuring event received from nested buildsrc builds before the root build starts configuring ignored 
WITHOUT_CLASSIFICATION	 optional 
WITHOUT_CLASSIFICATION	 first try determine the artifacts inmemory using the metadata dont use the cache this case 
WITHOUT_CLASSIFICATION	 experimentation shows the following excluded modules are inherited from parent poms either the following true the exclusions element missing the exclusions element 
WITHOUT_CLASSIFICATION	 chuck away the implicit target has already been executed 
WITHOUT_CLASSIFICATION	 construct build invocations from task selectors and project tasks 
WITHOUT_CLASSIFICATION	 val leftresult resultleft val errorseq leftget convert errorseq java types 
WITHOUT_CLASSIFICATION	 configure the binaries 
WITHOUT_CLASSIFICATION	 for legacy software model behaviour which assume that any kind runtime can built when any compiler available 
WITHOUT_CLASSIFICATION	 ensure that deploy jars are not also added into lib folder allows the user get transitive dependencies for bean artifact adding both earlib and deploy but only having the file once the ear 
WITHOUT_CLASSIFICATION	 versions before would unpack the exception and throw part losing some context 
WITHOUT_CLASSIFICATION	 maps from interned absolute path for file metadata for the file 
WITHOUT_CLASSIFICATION	 dont traverse path back root when there nothing that can possibly match 
WITHOUT_CLASSIFICATION	 find failure section 
WITHOUT_CLASSIFICATION	 for example when using local access resolve something remote 
WITHOUT_CLASSIFICATION	 have isgetter well getgetter 
WITHOUT_CLASSIFICATION	 there are enough entries this block and the right sibling make blocks redistribute the entries evenly between them 
WITHOUT_CLASSIFICATION	 capture the relative file 
WITHOUT_CLASSIFICATION	 its already osgi compliant dont touch 
WITHOUT_CLASSIFICATION	 already visited this node 
WITHOUT_CLASSIFICATION	 collect map from component coordinates this might better move the component some publications model 
WITHOUT_CLASSIFICATION	 for each module participating the conflict deselect the currently selection and remove all outgoing edges from the version 
WITHOUT_CLASSIFICATION	 nothing accessible always date 
WITHOUT_CLASSIFICATION	 this not the root block must have children minindexchildnodes 
WITHOUT_CLASSIFICATION	 compile all main routes files last 
WITHOUT_CLASSIFICATION	 this necessary that the watcher indicates its not running the runnable gets cancelled 
WITHOUT_CLASSIFICATION	 use caller classloader 
WITHOUT_CLASSIFICATION	 here need check that applying the new resolution filter would actually exclude exactly the same dependencies the previous visit important that this not heuristic used because the filters are equivalent would 
WITHOUT_CLASSIFICATION	 iterate through each page results and add them our results list 
WITHOUT_CLASSIFICATION	 note that the sourceset the sourceset this precompiled header will used with its not input sourceset the compile task 
WITHOUT_CLASSIFICATION	 stop very slow clean later 
WITHOUT_CLASSIFICATION	 maximum pool size fixed should only need get from the first event 
WITHOUT_CLASSIFICATION	 tasks specified then the default tasks will executed work around this assign new empty task for execution 
WITHOUT_CLASSIFICATION	 see the comment for link above 
WITHOUT_CLASSIFICATION	 the unlock was confirmed are waiting 
WITHOUT_CLASSIFICATION	 first try determine the artifacts locally before going remote 
WITHOUT_CLASSIFICATION	 case more descendants are added downward hierarchy make sure theyll notify 
WITHOUT_CLASSIFICATION	 implementation based spocks stacktracefilter class 
WITHOUT_CLASSIFICATION	 compiler complain about 
WITHOUT_CLASSIFICATION	 need override error message hardcoded constructor public type resolveexception 
WITHOUT_CLASSIFICATION	 msvc doesnt allow space between and the file name 
WITHOUT_CLASSIFICATION	 this point know that have match for pname this may mean that namepnamelength static inner class for this the rest the name does not need any dots its name either completely inner static class not since not want have useless lookups create the name completely and use prevent lookups against the package 
WITHOUT_CLASSIFICATION	 buildlistener 
WITHOUT_CLASSIFICATION	 clean the interrupted status 
WITHOUT_CLASSIFICATION	 work around for not being able skip the task when input file does not exist 
WITHOUT_CLASSIFICATION	 reserve for null added later 
WITHOUT_CLASSIFICATION	 add factory method 
WITHOUT_CLASSIFICATION	 nothing just return the highest version 
WITHOUT_CLASSIFICATION	 add getfactoryid 
WITHOUT_CLASSIFICATION	 todo register these mappings somewhere 
WITHOUT_CLASSIFICATION	 ast transforms need their own class loader that shares compiler classes with the compiler itself 
WITHOUT_CLASSIFICATION	 replace absent provider with null this required for allowing optional provider properties all code which unpacks providers calls providerget and would fail optional provider passed returning null from callable ignored and propertyvalue callable 
WITHOUT_CLASSIFICATION	 defer creation and resolution configuration until required shortcircuit when script does not require classpath 
WITHOUT_CLASSIFICATION	 fall back serialization 
WITHOUT_CLASSIFICATION	 stdout and stderr are attached the console 
WITHOUT_CLASSIFICATION	 equal values are compatible 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 zero more characters followed literal followed least one 
WITHOUT_CLASSIFICATION	 classpath change 
WITHOUT_CLASSIFICATION	 use directinstantiator here avoid setting the instantiation infrastructure early 
WITHOUT_CLASSIFICATION	 versions before would sometimes add some additional build cancelled exceptions 
WITHOUT_CLASSIFICATION	 references some fixed value expression return after macro expanding 
WITHOUT_CLASSIFICATION	 swift tests will always have toolchain requirement for swiftc 
WITHOUT_CLASSIFICATION	 else leading this 
WITHOUT_CLASSIFICATION	 dont have mutable access the project throw deprecation warning and then continue with lenient locking prevent deadlocks usermanaged threads 
WITHOUT_CLASSIFICATION	 dont really need handle this 
WITHOUT_CLASSIFICATION	 btw the ibm vmwinxp also has some issues detecting closed streams the child but handle this problem differently 
WITHOUT_CLASSIFICATION	 lists all the values revision token listed given url lister 
WITHOUT_CLASSIFICATION	 todo also close console when replaced 
WITHOUT_CLASSIFICATION	 sequence tokens that look like function call argument list should support arbitrary token sequence 
WITHOUT_CLASSIFICATION	 todo decide want push the gate concept into tapi other entry points currently gate only used continuous build and can only controlled from within the build 
WITHOUT_CLASSIFICATION	 parammdjava mdbc shajava shabc blakebbc 
WITHOUT_CLASSIFICATION	 visit the nodes prior visiting the edges 
WITHOUT_CLASSIFICATION	 everything else treat generic operation 
WITHOUT_CLASSIFICATION	 native services 
WITHOUT_CLASSIFICATION	 skip content download 
WITHOUT_CLASSIFICATION	 generate makerule method 
WITHOUT_CLASSIFICATION	 noinspection 
WITHOUT_CLASSIFICATION	 need delete the previous archive otherwise stale object files will remain 
WITHOUT_CLASSIFICATION	 only set the taskoperation the parent the tooling api consumer listening task progress events 
WITHOUT_CLASSIFICATION	 targetjdk does not include and use same fallback pmd 
WITHOUT_CLASSIFICATION	 buffer has been fully read start the beginning 
WITHOUT_CLASSIFICATION	 exactly visual studio 
WITHOUT_CLASSIFICATION	 note this listener manager scoped the root gradle object 
WITHOUT_CLASSIFICATION	 default for everything else 
WITHOUT_CLASSIFICATION	 ignore the tag section the comment 
WITHOUT_CLASSIFICATION	 matches task identifier arglist operator expression map arglist operator expression 
WITHOUT_CLASSIFICATION	 performs fast analysis classes referenced bytecode method bodies 
WITHOUT_CLASSIFICATION	 have caching options just get the thing directly 
WITHOUT_CLASSIFICATION	 anything left over only exists the new list 
WITHOUT_CLASSIFICATION	 add the configurations from this temporary parser this module descriptor 
WITHOUT_CLASSIFICATION	 old scala plugin does not specify scalaplatform 
WITHOUT_CLASSIFICATION	 the fingerprint hashes for nonregular files are slightly different the snapshot hashes only need compare them for regular files 
WITHOUT_CLASSIFICATION	 implementation provided pluginuse module 
WITHOUT_CLASSIFICATION	 implementation generated 
WITHOUT_CLASSIFICATION	 just returns the original object 
WITHOUT_CLASSIFICATION	 iterate over the metadata sources see they can provide the version list 
WITHOUT_CLASSIFICATION	 identifier allow anything except 
WITHOUT_CLASSIFICATION	 input events 
WITHOUT_CLASSIFICATION	 file did not exist before locking use some initial state 
WITHOUT_CLASSIFICATION	 start the pipeline reverse order mark daemon running start handling incoming commands start accepting incoming connections advertise presence registry 
WITHOUT_CLASSIFICATION	 corner case maven snapshot compat 
WITHOUT_CLASSIFICATION	 the collection readonly property must initialized first will never null the collection not readonly then will initialize only the collection the subject rule that say that can mutated this may look strange readwrite collection null initialize empty list but this how the specs define reawwrite collections scalar types 
WITHOUT_CLASSIFICATION	 make sure all entries are always written the same order 
WITHOUT_CLASSIFICATION	 need compute hash for constant which based the name the constant its value otherwise miss the case where class defines several constants with the same value when two values are switched nonprivate const 
WITHOUT_CLASSIFICATION	 tries minimize the number requests the resolution engine batching requests for sourcesjavadoc there still some inefficiency because the artifactcollection interface does not provide detailed failure results have fall back the more expensive resolutionresult api should fix this other ide vendors will face the same problem 
WITHOUT_CLASSIFICATION	 not sure this can happen unless error state 
WITHOUT_CLASSIFICATION	 ignore these test suites 
WITHOUT_CLASSIFICATION	 skip exact matches 
WITHOUT_CLASSIFICATION	 runtime check because method used from groovy where type bounds are not respected 
WITHOUT_CLASSIFICATION	 type payload size 
WITHOUT_CLASSIFICATION	 check that ivyxml isnt duplicated 
WITHOUT_CLASSIFICATION	 when age verified since the start this build assume still missing 
WITHOUT_CLASSIFICATION	 todo allow inputfile and skipwhenempty attached getexecutablefile 
WITHOUT_CLASSIFICATION	 save reference the dependency that was written before 
WITHOUT_CLASSIFICATION	 maybe this type belongs the same package the node that doing the static import that case the package may not have been explicitly specified try with the nodes package too still not found revert original type name 
WITHOUT_CLASSIFICATION	 not marked nullable because groovy compiler bug 
WITHOUT_CLASSIFICATION	 this happens for ibm jdk for nested interfaces see lets try return something close possible the intended value 
WITHOUT_CLASSIFICATION	 not public evaluation these specs major hot spot for large builds use array for iteration 
WITHOUT_CLASSIFICATION	 expire compatible idle not recently used daemons after short time 
WITHOUT_CLASSIFICATION	 the values are based what have found and zinc documentation hard say what effect they have the incremental build 
WITHOUT_CLASSIFICATION	 not zip file 
WITHOUT_CLASSIFICATION	 cannot convert 
WITHOUT_CLASSIFICATION	 static classes are used for the actions avoid implicitly dragging projecttasks into the model registry 
WITHOUT_CLASSIFICATION	 add outgoing configurations and publications 
WITHOUT_CLASSIFICATION	 eliminate the common root 
WITHOUT_CLASSIFICATION	 the strategy for sharing build cache configuration across included builds composite requires that the cache configuration finalized and cache controller available before configuring them this achieves that 
WITHOUT_CLASSIFICATION	 pass build jvm args through daemon via system property the launcher jvm 
WITHOUT_CLASSIFICATION	 look into the compile unit there class with that name 
WITHOUT_CLASSIFICATION	 when used input add the producing tasks known 
WITHOUT_CLASSIFICATION	 changes yet handle case where monotonic clock isnt monotonic 
WITHOUT_CLASSIFICATION	 type extends never contained 
WITHOUT_CLASSIFICATION	 there possibility that platform version was selected before new member the platform was discovered this case need restart the selection some members will not upgraded 
WITHOUT_CLASSIFICATION	 serialize the worker config this consumed 
WITHOUT_CLASSIFICATION	 values from jvmpackagenametest 
WITHOUT_CLASSIFICATION	 allow the gradle version overridden for tests that are sensitive the version and need test with various different version patterns use env variable because these are easy set daemon startup whereas system properties are scrubbed daemon startup 
WITHOUT_CLASSIFICATION	 ignore input received after the monitor operation has been completed 
WITHOUT_CLASSIFICATION	 restore the environment 
WITHOUT_CLASSIFICATION	 noinspection constantconditions 
WITHOUT_CLASSIFICATION	 create variants container only required 
WITHOUT_CLASSIFICATION	 currently not supported 
WITHOUT_CLASSIFICATION	 different implementation assume value has changed 
WITHOUT_CLASSIFICATION	 float float tmp fnullffloatvalue 
WITHOUT_CLASSIFICATION	 more than one conflicting project dependencies 
WITHOUT_CLASSIFICATION	 acquiring the exclusive lock can fail the rare case where another process just doing has just done the cache initialization 
WITHOUT_CLASSIFICATION	 started enable 
WITHOUT_CLASSIFICATION	 copied from 
WITHOUT_CLASSIFICATION	 return thismetaclass 
WITHOUT_CLASSIFICATION	 ignored 
WITHOUT_CLASSIFICATION	 reasonable default threshold bounds between and 
WITHOUT_CLASSIFICATION	 solution 
WITHOUT_CLASSIFICATION	 this can happen this used constructor before method also happens when using runwithsomerunner when the runner does not support rules 
WITHOUT_CLASSIFICATION	 mark all affected configurations observed 
WITHOUT_CLASSIFICATION	 filtering place 
WITHOUT_CLASSIFICATION	 these will also copied across any daemon used 
WITHOUT_CLASSIFICATION	 exactly visual studio 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 this approach should generally work because the moment reset capturing output per suite see and that reset happens earlier the chain theory when suite completed the output redirector has been already stopped and there shouldnt any output events passed see also gradle 
WITHOUT_CLASSIFICATION	 when daemon process has started yet 
WITHOUT_CLASSIFICATION	 dummy rule cause the extension realized 
WITHOUT_CLASSIFICATION	 the registered nodes may contain nodes which are longer selected dont remove them from the list the first place because proved slower than filtering needed 
WITHOUT_CLASSIFICATION	 this necessary because for the tooling api compatibility runner nativeservices can get initialized different classloader which then makes broken and unusable the test class because the native shared library loaded from another classloader initializing here ensure that loaded from the classloader the test class also uses 
WITHOUT_CLASSIFICATION	 generate public extensioncontainer getextensions return getconvention 
WITHOUT_CLASSIFICATION	 read server address and start connecting 
WITHOUT_CLASSIFICATION	 defer dependencies gathering need resolve across projects boundaries 
WITHOUT_CLASSIFICATION	 add name field 
WITHOUT_CLASSIFICATION	 empty initial operation trigger onstartwork calls 
WITHOUT_CLASSIFICATION	 and milestone work java 
WITHOUT_CLASSIFICATION	 use the highest preferred version that refines the chosen require selector 
WITHOUT_CLASSIFICATION	 when not running from gradle distro need runtime impl for launcher plus the search path look for other modules 
WITHOUT_CLASSIFICATION	 avoid silent retry 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 skipwhenempty implies incremental this file property empty then clean the previously generated outputs that means that there very close relation between the file property and the output 
WITHOUT_CLASSIFICATION	 cannot compute task execution time because need association with source set 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 ignore this will reported later 
WITHOUT_CLASSIFICATION	 the unlock was just requested but not yet confirmed give some more time 
WITHOUT_CLASSIFICATION	 triggered through tooling api gradle nativeplatformdll shared tooling client and daemon current and locked the client issue 
WITHOUT_CLASSIFICATION	 ignore all but the first recorded annotation 
WITHOUT_CLASSIFICATION	 this factory should injected but leaves nondaemon threads running when used from the tooling api client 
WITHOUT_CLASSIFICATION	 the collection will only initialized more than one project candidate found 
WITHOUT_CLASSIFICATION	 check node was previously traversed with the same net exclusion when not virtual platform 
WITHOUT_CLASSIFICATION	 read path gradle user home 
WITHOUT_CLASSIFICATION	 dont care collect the files later the correct order 
WITHOUT_CLASSIFICATION	 mandatory 
WITHOUT_CLASSIFICATION	 ensure have scope 
WITHOUT_CLASSIFICATION	 used generated code 
WITHOUT_CLASSIFICATION	 this deals with the fact that testng there are classlevel events but nevertheless want see the class name use rather than separator make clear that the class not separate level this matters when configuring granularity 
WITHOUT_CLASSIFICATION	 drain the buffer before returning endofstream 
WITHOUT_CLASSIFICATION	 assume indentation uses spaces 
WITHOUT_CLASSIFICATION	 otherwise defer the judgement our internal backoff handler 
WITHOUT_CLASSIFICATION	 slowest path full distribution 
WITHOUT_CLASSIFICATION	 value 
WITHOUT_CLASSIFICATION	 reset security manager the tests seem have installed 
WITHOUT_CLASSIFICATION	 supposed happen 
WITHOUT_CLASSIFICATION	 sort determinism 
WITHOUT_CLASSIFICATION	 keep the files and discard the origin values instead 
WITHOUT_CLASSIFICATION	 short lived process dont cache memory 
WITHOUT_CLASSIFICATION	 does not match element will never match when more elements added 
WITHOUT_CLASSIFICATION	 know that jvm binaries are binaryspec instances 
WITHOUT_CLASSIFICATION	 search the standard installation locations and construct 
WITHOUT_CLASSIFICATION	 this used parse yaml file 
WITHOUT_CLASSIFICATION	 check for duplicates 
WITHOUT_CLASSIFICATION	 any work execution happening nested buildsrc builds before the root build has started executing work ignored 
WITHOUT_CLASSIFICATION	 write line separator after any block 
WITHOUT_CLASSIFICATION	 the usage pattern this exception providing the rule identity and the cause providing the detail the way due how render chained exceptions build failures that because the information usually dense splitting things this way provides better output 
WITHOUT_CLASSIFICATION	 take ownership 
WITHOUT_CLASSIFICATION	 exactly visual studio 
WITHOUT_CLASSIFICATION	 mapping new getconvention return mapping 
WITHOUT_CLASSIFICATION	 you update filestore you may also need update 
WITHOUT_CLASSIFICATION	 optimize for the single entry case makes findentry faster 
WITHOUT_CLASSIFICATION	 the following types can appear anywhere the code but say nothing about api implementation usage 
WITHOUT_CLASSIFICATION	 has position sensitive arguments the output args need appear before the source file 
WITHOUT_CLASSIFICATION	 getmetaclass 
WITHOUT_CLASSIFICATION	 use this instead not available junit 
WITHOUT_CLASSIFICATION	 dont currently hold the project lock 
WITHOUT_CLASSIFICATION	 add new antlr virtual directory mapping 
WITHOUT_CLASSIFICATION	 only called when node exists 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 discard information region 
WITHOUT_CLASSIFICATION	 hashcode will always used precompute order make sure wont compute multiple times during comparisons 
WITHOUT_CLASSIFICATION	 created since last execution possibly another task 
WITHOUT_CLASSIFICATION	 lockin explicitly included builds 
WITHOUT_CLASSIFICATION	 test suite passingtestsuite started 
WITHOUT_CLASSIFICATION	 check for star imports import static pkgouter matching static inner classes 
WITHOUT_CLASSIFICATION	 dont need match path 
WITHOUT_CLASSIFICATION	 generate args instanceof object args new object args 
WITHOUT_CLASSIFICATION	 discard the calculated files collection too but need retain the display name for 
WITHOUT_CLASSIFICATION	 consider only extra attributes which are not every candidate because they are extra attributes consider that candidate which does not provide this value better match 
WITHOUT_CLASSIFICATION	 nop all 
WITHOUT_CLASSIFICATION	 sha hash sum has been defined verify here 
WITHOUT_CLASSIFICATION	 since single artifact shared between configurations share the metadata type well 
WITHOUT_CLASSIFICATION	 currently only snapshot the console output listener should snapshot all output listeners and cleanup restore 
WITHOUT_CLASSIFICATION	 setup component 
WITHOUT_CLASSIFICATION	 todo lock this down 
WITHOUT_CLASSIFICATION	 exactly visual studio 
WITHOUT_CLASSIFICATION	 this should turn into set converters some point 
WITHOUT_CLASSIFICATION	 important that this constructed the client that has the right gradlehomedir and other state internally 
WITHOUT_CLASSIFICATION	 convention 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 set convention mapping for default sources allows user not have specify 
WITHOUT_CLASSIFICATION	 todo make capabilities accessible rules 
WITHOUT_CLASSIFICATION	 remove the last walked should run after edge and restore state from before walking 
WITHOUT_CLASSIFICATION	 collect nodes implicit capability providers different than current node selected and not having explicit capabilities 
WITHOUT_CLASSIFICATION	 ensure clean end the line when the area scrolls 
WITHOUT_CLASSIFICATION	 same default conf but used 
WITHOUT_CLASSIFICATION	 capture changes implementation 
WITHOUT_CLASSIFICATION	 broken metadata bail 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 reach this point match was found either because there are versions matching the selector 
WITHOUT_CLASSIFICATION	 flags 
WITHOUT_CLASSIFICATION	 capture input files state 
WITHOUT_CLASSIFICATION	 have not root source folder information for the grammar files dont force relativeoutput cant calculate this results flat generated sources the output directory 
WITHOUT_CLASSIFICATION	 gradle stuff 
WITHOUT_CLASSIFICATION	 these fields are not covered mutation lock 
WITHOUT_CLASSIFICATION	 select all entry points entry point publication that does not contain component whose parent also published 
WITHOUT_CLASSIFICATION	 stack traces are filtered call order from bottom top 
WITHOUT_CLASSIFICATION	 todo this should input 
WITHOUT_CLASSIFICATION	 allow the daemon started concurrently 
WITHOUT_CLASSIFICATION	 filecreatetempfile sets the location the temp directory static variable the first call this prevents future changes javaiotmpdir from having any effect the same process set this use common tmp directory for all tests running the same process that dont have situation where one process initializes with tmp directory that then removes causing ioexception for any future tests that run the same process and call filecreatetempfile 
WITHOUT_CLASSIFICATION	 capture and restore this case the build code calls localesetdefault 
WITHOUT_CLASSIFICATION	 ignore the version the string cannot read 
WITHOUT_CLASSIFICATION	 see 
WITHOUT_CLASSIFICATION	 create proxy 
WITHOUT_CLASSIFICATION	 ignore the other values 
WITHOUT_CLASSIFICATION	 cant use immutable list here because some hashes can null 
WITHOUT_CLASSIFICATION	 look for our daemon among the busy daemons daemon will start busy state that nobody else will grab 
WITHOUT_CLASSIFICATION	 cannot just delegate the add method need the file content for checksum calculation here and reexecuting the action isnt acceptable 
WITHOUT_CLASSIFICATION	 read whether process info should published 
WITHOUT_CLASSIFICATION	 list modules with missing metadata files 
WITHOUT_CLASSIFICATION	 effectively read the manifest 
WITHOUT_CLASSIFICATION	 loaded from classes dir assume were running from the ide tests 
WITHOUT_CLASSIFICATION	 for each source set will 
WITHOUT_CLASSIFICATION	 skip builtin properties 
WITHOUT_CLASSIFICATION	 this handles macosx windows and linuxunixmacosx 
WITHOUT_CLASSIFICATION	 make copy the closure attach inputs and execute 
WITHOUT_CLASSIFICATION	 also check interfaces case have interfaces with nested classes 
WITHOUT_CLASSIFICATION	 use the timestamped version for all published artifacts the timestamped version hidden deep 
WITHOUT_CLASSIFICATION	 any swift compiler 
WITHOUT_CLASSIFICATION	 ignore 
WITHOUT_CLASSIFICATION	 nullable 
WITHOUT_CLASSIFICATION	 register builder for the custom tooling model 
WITHOUT_CLASSIFICATION	 need check the target version exists for this have try get metadata for the aligned version its there means can align otherwise must not add the edge resolution would fail 
WITHOUT_CLASSIFICATION	 this method should have been added the class 
WITHOUT_CLASSIFICATION	 formatteroff 
WITHOUT_CLASSIFICATION	 any swift compiler 
WITHOUT_CLASSIFICATION	 does not need redrawn 
WITHOUT_CLASSIFICATION	 present but empty 
WITHOUT_CLASSIFICATION	 slowest path 
WITHOUT_CLASSIFICATION	 otherwise deep compare outputs 
WITHOUT_CLASSIFICATION	 todo should attempt flush the output stream prior writing the error stream and vice versa 
WITHOUT_CLASSIFICATION	 choose the shortest match 
WITHOUT_CLASSIFICATION	 path isa iterable check before checking for iterable 
WITHOUT_CLASSIFICATION	 kept for backwards compatibility plugins using internal apis 
WITHOUT_CLASSIFICATION	 generate public object invokemethodstring name object params return objectparams 
WITHOUT_CLASSIFICATION	 fields used for performance optimizations avoid computing the derived dependencies withconstraints withoutconstraints eagerly because its very likely that those methods would only called the selected variant therefore its waste time compute them eagerly when those filtering methods are called cannot use dedicated lazy wrapper over configuration metadata 
WITHOUT_CLASSIFICATION	 this line must last 
WITHOUT_CLASSIFICATION	 replace deprecated usage values 
WITHOUT_CLASSIFICATION	 basically see operation with logging header and its not grouped just log 
WITHOUT_CLASSIFICATION	 use reflection support older jvms while supporting java 
WITHOUT_CLASSIFICATION	 bigendian 
WITHOUT_CLASSIFICATION	 apply any artifact type mappings the attributes the variant 
WITHOUT_CLASSIFICATION	 using fake junit test 
WITHOUT_CLASSIFICATION	 called under lock 
WITHOUT_CLASSIFICATION	 meta data artifacts are determined locally 
WITHOUT_CLASSIFICATION	 generate 
WITHOUT_CLASSIFICATION	 collapse the set 
WITHOUT_CLASSIFICATION	 wait for any work still running other threads 
WITHOUT_CLASSIFICATION	 since transport supports only one type credentials time lets use the first one found 
WITHOUT_CLASSIFICATION	 formatteron 
WITHOUT_CLASSIFICATION	 could return true all the read only properties point immutable objects but this stage there are such types supported 
WITHOUT_CLASSIFICATION	 add the module configurations files 
WITHOUT_CLASSIFICATION	 matches task identifier arg 
WITHOUT_CLASSIFICATION	 actual format apple swift version 
WITHOUT_CLASSIFICATION	 overwrite the source exclude linuxmainswift 
WITHOUT_CLASSIFICATION	 unpack the provider 
WITHOUT_CLASSIFICATION	 remains the same the content the existing file 
WITHOUT_CLASSIFICATION	 sdk information available the registry 
WITHOUT_CLASSIFICATION	 logging configuration 
WITHOUT_CLASSIFICATION	 skip this for now 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 ask for external dependencies its still fine bring fat jar nothing else available 
WITHOUT_CLASSIFICATION	 arbitrarily select and mark all rejected 
WITHOUT_CLASSIFICATION	 notify child configurations 
WITHOUT_CLASSIFICATION	 idea adds the jdks bootstrap classpath the classpath uses run test remove this 
WITHOUT_CLASSIFICATION	 can wait request previous handler allows waiting 
WITHOUT_CLASSIFICATION	 the order strange logically but here for performance optimization 
WITHOUT_CLASSIFICATION	 only interrupt poller thread its not current thread 
WITHOUT_CLASSIFICATION	 used maintain timer 
WITHOUT_CLASSIFICATION	 test default imports 
WITHOUT_CLASSIFICATION	 should reuse the link parsing stuff from instead 
WITHOUT_CLASSIFICATION	 are allowing unknowns just pass through the whole arg 
WITHOUT_CLASSIFICATION	 use the result previous rules the input for dependency substitution 
WITHOUT_CLASSIFICATION	 not present output check error output 
WITHOUT_CLASSIFICATION	 these could injected directly too 
WITHOUT_CLASSIFICATION	 used ensure the suffix isnt matching any part the prefix 
WITHOUT_CLASSIFICATION	 ignore future states the input node 
WITHOUT_CLASSIFICATION	 could precomputed but avoid doing attributes are never requested 
WITHOUT_CLASSIFICATION	 its often the case that all the candidate values are the same this case avoid the creation set and just iterate until find different value then only this case lazily initialize set and collect all the candidate values 
WITHOUT_CLASSIFICATION	 adding custom test listeners before gradles listeners this way custom listeners are more powerful and for example they can change test status 
WITHOUT_CLASSIFICATION	 some validation 
WITHOUT_CLASSIFICATION	 todo match with status order versions correctly 
WITHOUT_CLASSIFICATION	 check other behaviour still works 
WITHOUT_CLASSIFICATION	 check already resolved results for compatible version and use for this dependency rather than reresolving 
WITHOUT_CLASSIFICATION	 evaluate init scripts 
WITHOUT_CLASSIFICATION	 its intersection and this method always called the remainder reduction operation the remainder empty then means that the intersection empty 
WITHOUT_CLASSIFICATION	 any available gcc compatible implementation including mingw cygwin and clang 
WITHOUT_CLASSIFICATION	 when annotation processing isnt required its better add the groovy stubs part the source path this allows compilations complete faster because only the groovy stubs that are needed the java source are compiled 
WITHOUT_CLASSIFICATION	 note there isnt much can about collectionmatching filters the spec requires realized element unless make major changes 
WITHOUT_CLASSIFICATION	 presence capabilities bound the definition capabilities extension the project 
WITHOUT_CLASSIFICATION	 not change the order members used hash code here its been empirically tested reduce the number collisions large dependency graph performance test 
WITHOUT_CLASSIFICATION	 have received all requests have released something downstream can wait this isnt quite right 
WITHOUT_CLASSIFICATION	 avoid creating copy the resulting configuration identical 
WITHOUT_CLASSIFICATION	 convert scala java 
WITHOUT_CLASSIFICATION	 registry doesnt exist yet 
WITHOUT_CLASSIFICATION	 nonjavadoc see 
WITHOUT_CLASSIFICATION	 some other metaclass implementation fall back the public api 
WITHOUT_CLASSIFICATION	 cycle treat resolved here 
WITHOUT_CLASSIFICATION	 determine the dependencies the class load the byte code and look for constantclass entries the constant pool 
WITHOUT_CLASSIFICATION	 there some value the other ways locate msbuild aka matching the msbuild installation with the installation this last chance try and locate usable msbuild installation which will just try get the latest available msbuild can refine this later 
WITHOUT_CLASSIFICATION	 todo convert output file checks resource lock 
WITHOUT_CLASSIFICATION	 gather the default tasks from this first group project 
WITHOUT_CLASSIFICATION	 not empty may match any case above 
WITHOUT_CLASSIFICATION	 host 
WITHOUT_CLASSIFICATION	 remove the deprecations message deprecated gradle features use warningmode all see httpsdocsgradleorg and additional newline 
WITHOUT_CLASSIFICATION	 must add the implicit capability here because assumed that theres rule addcapability would effectively add capability the implicit one must not forgotten 
WITHOUT_CLASSIFICATION	 stop handling disconnects blocks until the handler has finished stop the connection this means that the thread receiving from the connection will receive null and finish stop receiving incoming messages blocks until the receive thread has finished this will notify the stdin and receive queues signal end input stop the receive queue unblock any threads blocked receive stop handling stdin blocks until the handler has finished discards any queued input 
WITHOUT_CLASSIFICATION	 tries relocate literals the form foobarbar 
WITHOUT_CLASSIFICATION	 based 
WITHOUT_CLASSIFICATION	 make sure getters end before the setters 
WITHOUT_CLASSIFICATION	 generate method 
WITHOUT_CLASSIFICATION	 default scala version 
WITHOUT_CLASSIFICATION	 todoadam arm only the target windows later todomput arm also the target windows windows phonemobilece todoadam only the target windows earlier 
WITHOUT_CLASSIFICATION	 exception has already been reported 
WITHOUT_CLASSIFICATION	 define some additional variants 
WITHOUT_CLASSIFICATION	 todo mix this using decoration also validate closure parameter types declared 
WITHOUT_CLASSIFICATION	 first replace slashes because they have special meaning the javadoc options file then replace every linebreak with slashlinebreak slash needed according javadoc options file format 
WITHOUT_CLASSIFICATION	 dont serialise the module dependencies this stage need keep track the mapping module dependency resolved dependency 
WITHOUT_CLASSIFICATION	 intentionally consider execution done before doing afterevaluate the android plugin relies this behaviour 
WITHOUT_CLASSIFICATION	 other stuff 
WITHOUT_CLASSIFICATION	 the following state needs tracked consistently construct independent the order dependencies are visited 
WITHOUT_CLASSIFICATION	 create new temporary parser read the configurations from the specified file 
WITHOUT_CLASSIFICATION	 only called when node exists therefore node known 
WITHOUT_CLASSIFICATION	 checkstyleoff 
WITHOUT_CLASSIFICATION	 todo the suffix should deterministic function the known and enabled annotations for now just assign using counter 
WITHOUT_CLASSIFICATION	 for tests using rich console standard out and error are combined output execution result 
WITHOUT_CLASSIFICATION	 there already registered conflict with least one matching participant hook this conflict 
WITHOUT_CLASSIFICATION	 contract requires build events are delivered single thread this taken care the daemon client when not embedded mode need apply some synchronization when embedded mode 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 explain that groovy for compile also needs the resources 
WITHOUT_CLASSIFICATION	 retry 
WITHOUT_CLASSIFICATION	 there are possibilities here the platform referenced real module which case directly add the graph the platform virtual constructed thing which case add virtual edges the graph 
WITHOUT_CLASSIFICATION	 todo reuse cached result from downstream users our classes directory 
WITHOUT_CLASSIFICATION	 standard doclet options 
WITHOUT_CLASSIFICATION	 luck 
WITHOUT_CLASSIFICATION	 verify url making http call 
WITHOUT_CLASSIFICATION	 this should really string object however properties loader signature expects string string even practice was never enforced one can pass other property types such boolean fixing the method signature would binary breaking change public api 
WITHOUT_CLASSIFICATION	 ignore files 
WITHOUT_CLASSIFICATION	 the current target project component must unmodified from the requested 
WITHOUT_CLASSIFICATION	 this means that receive output before even starting any class too late dont have place for such output any the reports skipping unfortunately this happens pretty often with current level testng support because output events emitted constructor beforetest beforeclass are sent before test start event started and there parent class event emitted testng short the testng support could better see also 
WITHOUT_CLASSIFICATION	 after this point only see getters 
WITHOUT_CLASSIFICATION	 target does not exist the map theres cycle for sure 
WITHOUT_CLASSIFICATION	 fine one more project dependencies among conflicting modules 
WITHOUT_CLASSIFICATION	 state artifactexclude exclude 
WITHOUT_CLASSIFICATION	 barrier open let travel 
WITHOUT_CLASSIFICATION	 ignore this installation for validation will caught later 
WITHOUT_CLASSIFICATION	 macos assume colocated xcode installed into optxcode and default location 
WITHOUT_CLASSIFICATION	 this shouldnt happen you call check availability with available first 
WITHOUT_CLASSIFICATION	 matches task namevaluepairs identifier arg map tasknamevaluepairs identifier arg 
WITHOUT_CLASSIFICATION	 could caused ignore problems stopping 
WITHOUT_CLASSIFICATION	 forward special cases directly consumer 
WITHOUT_CLASSIFICATION	 cant delegate because this would result asttransformation interface which implemented the transform class being loaded which 
WITHOUT_CLASSIFICATION	 version routes compiler published 
WITHOUT_CLASSIFICATION	 default methods are public nonabstract instance methods declared interface 
WITHOUT_CLASSIFICATION	 thisgetmetaclass 
WITHOUT_CLASSIFICATION	 the current filestore 
WITHOUT_CLASSIFICATION	 this uses the system classloader and will not release any loaded classes for the life the daemon process not use this load any classes which are part the build will not release them when the build complete 
WITHOUT_CLASSIFICATION	 todo not assume maven layout 
WITHOUT_CLASSIFICATION	 when selector changes from non forced forced must reselect 
WITHOUT_CLASSIFICATION	 check that the length the reserved region enough for storing our content 
WITHOUT_CLASSIFICATION	 generate implementation class 
WITHOUT_CLASSIFICATION	 root should the last entry 
WITHOUT_CLASSIFICATION	 legacy mode 
WITHOUT_CLASSIFICATION	 print the header were verbose mode were rich mode and some output has already been rendered and havent displayed the header yet weve displayed the header but the status has since changed 
WITHOUT_CLASSIFICATION	 metaclass return metaclass 
WITHOUT_CLASSIFICATION	 dont need parameter substitution return the value the expression after macro expanding 
WITHOUT_CLASSIFICATION	 simplifies 
WITHOUT_CLASSIFICATION	 there inheritance hierarchy play here the order the clauses very important 
WITHOUT_CLASSIFICATION	 flush any buffered events and update the clock 
WITHOUT_CLASSIFICATION	 ignore means the client has disconnected point sending him any log output should checking client still listens elsewhere anyway 
WITHOUT_CLASSIFICATION	 need check that versions match mismatch indicates force was used 
WITHOUT_CLASSIFICATION	 else already visited previously skip 
WITHOUT_CLASSIFICATION	 this after wtp configured because wtp config required update classpath properly 
WITHOUT_CLASSIFICATION	 implicit jvm args that should used fork jvm 
WITHOUT_CLASSIFICATION	 unbox value 
WITHOUT_CLASSIFICATION	 add included builds defined settings 
WITHOUT_CLASSIFICATION	 target target ancestor this node already being handled 
WITHOUT_CLASSIFICATION	 one binary store per idthreadid 
WITHOUT_CLASSIFICATION	 remove any outgoing edges for the current selection 
WITHOUT_CLASSIFICATION	 expire after normal idle timeout 
WITHOUT_CLASSIFICATION	 generate sourcelocation method 
WITHOUT_CLASSIFICATION	 inputslvar inputsfield parentinputslvar 
WITHOUT_CLASSIFICATION	 guava 
WITHOUT_CLASSIFICATION	 used internally determine rule effectively did something 
WITHOUT_CLASSIFICATION	 todo assumes theres single main component 
WITHOUT_CLASSIFICATION	 else something has changed the include file graph for this source file analyse again 
WITHOUT_CLASSIFICATION	 block until ready for write operations 
WITHOUT_CLASSIFICATION	 compile the interface temp file and then copy the cache folder this avoids sporadic cache lock timeouts when the compiler interface jar takes long time generate while avoiding starving multiple compiler daemons 
WITHOUT_CLASSIFICATION	 any swift compiler 
WITHOUT_CLASSIFICATION	 new module has more than version register conflict and return 
WITHOUT_CLASSIFICATION	 generate public returntype propnametype val superpropnamev prop true return val 
WITHOUT_CLASSIFICATION	 noop 
WITHOUT_CLASSIFICATION	 foo can match both foo and foonestedclass 
WITHOUT_CLASSIFICATION	 duplicate ignore 
WITHOUT_CLASSIFICATION	 always expand with trailing 
WITHOUT_CLASSIFICATION	 trigger replay this node add new constraints graph 
WITHOUT_CLASSIFICATION	 not enough data points 
WITHOUT_CLASSIFICATION	 unresolved have selector that was deferred but the constraint has been removed between 
WITHOUT_CLASSIFICATION	 called when the method throws exception 
WITHOUT_CLASSIFICATION	 collect for later not add until the graph known have not changed 
WITHOUT_CLASSIFICATION	 further work around for missing ability skip task when input file missing see below 
WITHOUT_CLASSIFICATION	 returns fixed value expression 
WITHOUT_CLASSIFICATION	 try move the file out the way case its permanently corrupt dont delete that can potentially used for debugging 
WITHOUT_CLASSIFICATION	 given 
WITHOUT_CLASSIFICATION	 note its not the role this class validate that the annotation properly used that say only getter returning string named instance trust the result the call 
WITHOUT_CLASSIFICATION	 replace with organisation 
WITHOUT_CLASSIFICATION	 dont like the assumption about the port very much 
WITHOUT_CLASSIFICATION	 sort based version 
WITHOUT_CLASSIFICATION	 getmethod used private method doesnt belong the api 
WITHOUT_CLASSIFICATION	 arent required and dont have signatory then just dont run 
WITHOUT_CLASSIFICATION	 what actually shows the console 
WITHOUT_CLASSIFICATION	 protects the following state 
WITHOUT_CLASSIFICATION	 expose the task build logic for now 
WITHOUT_CLASSIFICATION	 current test can associated the output the last known descriptor used see for more information 
WITHOUT_CLASSIFICATION	 cached classloader 
WITHOUT_CLASSIFICATION	 super test class file not test class directories 
WITHOUT_CLASSIFICATION	 deprecations these should just rendered the client instead being sent the daemon send them back again 
WITHOUT_CLASSIFICATION	 capture the current state things that will change during execution 
WITHOUT_CLASSIFICATION	 the iteration order zipgetentries based the hash the zip entry this isnt much use collect the entries map and iterate over them alphabetical order 
WITHOUT_CLASSIFICATION	 parent reference need resolve the target 
WITHOUT_CLASSIFICATION	 ensure type registered 
WITHOUT_CLASSIFICATION	 can compare here length because pname always substring name same length means they are equal 
WITHOUT_CLASSIFICATION	 found the desired settings file now build the associated buildsrc before loading settings this allows the settings script reference classes the buildsrc 
WITHOUT_CLASSIFICATION	 the binary inputs 
WITHOUT_CLASSIFICATION	 exclude frameworks for clang they need handled differently 
WITHOUT_CLASSIFICATION	 should final and set constructor 
WITHOUT_CLASSIFICATION	 the directory passed argument since filecreatetempfile sets the location the temp directory static variable the first call unless directory passed the call some tests change javaiotmpdir and this ensure that the current value javaiotmpdir gets used here 
WITHOUT_CLASSIFICATION	 avoid initializing the list there are components requiring download common case 
WITHOUT_CLASSIFICATION	 mix the implicit launcher jvm args with the requested jvm args 
WITHOUT_CLASSIFICATION	 identifier with separator this not include import directive some other directive 
WITHOUT_CLASSIFICATION	 make some assumptions about the console output 
WITHOUT_CLASSIFICATION	 order from most recent least recent 
WITHOUT_CLASSIFICATION	 descriptor file has been deleted ignore the entry 
WITHOUT_CLASSIFICATION	 this can happen when for example beforeclass afterclass method fails 
WITHOUT_CLASSIFICATION	 use the resolved component available this ensures that maven snapshot ids are correctly reported 
WITHOUT_CLASSIFICATION	 and 
WITHOUT_CLASSIFICATION	 the eclipse task the root project should generate eclipse projects for all gradle projects 
WITHOUT_CLASSIFICATION	 this url not recognized the mac console too few leading slashes solve this creating uri with empty authority 
WITHOUT_CLASSIFICATION	 add toolsjar the systemclassloader parent 
WITHOUT_CLASSIFICATION	 java and kotlin lambdas are coerced sam types compile time unpacking necessary there 
WITHOUT_CLASSIFICATION	 these methods return strings rather than types because may more complicated than what able expressed via modeltype also dont want encourage compatibility checking occurring looping through such types have more options for optimising the compatibility check internally also also these methods are only called for reporting values should typically not precomputed 
WITHOUT_CLASSIFICATION	 this only required avoid adding new public constructor the public patternset type 
WITHOUT_CLASSIFICATION	 based 
WITHOUT_CLASSIFICATION	 supported but unavailable nothing 
WITHOUT_CLASSIFICATION	 could probably apply some caching and some immutable types 
WITHOUT_CLASSIFICATION	 confirms there enough space candidate fit both suffix and prefix 
WITHOUT_CLASSIFICATION	 nothing dont store this 
WITHOUT_CLASSIFICATION	 target 
WITHOUT_CLASSIFICATION	 model properties 
WITHOUT_CLASSIFICATION	 visual studio information available the registry 
WITHOUT_CLASSIFICATION	 ignore all selectors failed and will have failures recorded 
WITHOUT_CLASSIFICATION	 cut the pre and postfix this url 
WITHOUT_CLASSIFICATION	 assume everything loaded into the current classloader 
WITHOUT_CLASSIFICATION	 note this currently not visible link avoid leaking onto abstracttask and the public api 
WITHOUT_CLASSIFICATION	 default value for older gradle clients 
WITHOUT_CLASSIFICATION	 callable extends callable 
WITHOUT_CLASSIFICATION	 override the params with the explicit settings provided the tooling api 
WITHOUT_CLASSIFICATION	 check dynamic object behaviour still works 
WITHOUT_CLASSIFICATION	 cast return type 
WITHOUT_CLASSIFICATION	 should constructed with the default system classloader root 
WITHOUT_CLASSIFICATION	 ideally wed delegate directly the antbuilder but its closure class different our callers closure class the antbuilders methodmissing doesnt work just converts our closures string because they are not instanceof its closure class 
WITHOUT_CLASSIFICATION	 cached state not copied since dependency inputs are different 
WITHOUT_CLASSIFICATION	 set the implicit system properties regardless whether default jvm args are required not this should not interfere with tests intentions 
WITHOUT_CLASSIFICATION	 setting the length improves upload performance 
WITHOUT_CLASSIFICATION	 ignore and fall back growl notify 
WITHOUT_CLASSIFICATION	 todocedric find out why use the same directly fails resolution trying get the artifacts from the resolving metadata instead the resolved metadata 
WITHOUT_CLASSIFICATION	 according jvm documentation 
WITHOUT_CLASSIFICATION	 ensure target project configured 
WITHOUT_CLASSIFICATION	 lock protects the following state using intentionally simple locking strategy 
WITHOUT_CLASSIFICATION	 the target may already modified from the original requested 
WITHOUT_CLASSIFICATION	 skip properties with nonabstract getter setter implementations 
WITHOUT_CLASSIFICATION	 release 
WITHOUT_CLASSIFICATION	 taking the first selector here determine the changing status and client module our best bet get the selector that will most likely chosen the end selectors are sorted accordingly see 
WITHOUT_CLASSIFICATION	 this only used for testing purposes can test handling fluid dependencies without adding dependency substitution rule 
WITHOUT_CLASSIFICATION	 already seen this source file before see can reuse the analysis from last time 
WITHOUT_CLASSIFICATION	 literal followed followed literal matches above 
WITHOUT_CLASSIFICATION	 now try each address 
WITHOUT_CLASSIFICATION	 need wrap the visitor that the file seen the visitor has already been extracted from the archive and not try extract again its unsafe keep the filevisitdetails provided tarfiletree directly because not expect visit the same paths again after extracting everything 
WITHOUT_CLASSIFICATION	 note this method taskinternal 
WITHOUT_CLASSIFICATION	 when artifact being published first checked whether available transport returns null then assumed that artifact does not exist throw attempt publish will fail altogether even use 
WITHOUT_CLASSIFICATION	 limit the inner class lookups here using this way only the name will change the packageprefix will not included the lookup the case where the packageprefix really class handled elsewhere 
WITHOUT_CLASSIFICATION	 serialize the worker this consumed 
WITHOUT_CLASSIFICATION	 always use default windows 
WITHOUT_CLASSIFICATION	 take root worker lease wont ever released projectbuilder has lifecycle 
WITHOUT_CLASSIFICATION	 otherwise expand 
WITHOUT_CLASSIFICATION	 list extends string 
WITHOUT_CLASSIFICATION	 have the list empty should array then 
WITHOUT_CLASSIFICATION	 todohh wire binary libs via executable 
WITHOUT_CLASSIFICATION	 not cache test task jacoco doesnt produce its output files 
WITHOUT_CLASSIFICATION	 same decoration addlistener remove correctly 
WITHOUT_CLASSIFICATION	 generate 
WITHOUT_CLASSIFICATION	 everything excluded only applies modules not artifacts 
WITHOUT_CLASSIFICATION	 assume changed reading old file fails 
WITHOUT_CLASSIFICATION	 output reports per execution not mixed crossproject modelregistry operations not happen concurrently 
WITHOUT_CLASSIFICATION	 asking for fat jar everything available shadow jar thats fine 
WITHOUT_CLASSIFICATION	 everything unmanaged struct that hasnt been handled before 
WITHOUT_CLASSIFICATION	 construct new compiler class 
WITHOUT_CLASSIFICATION	 was primitive type next see the name which vanilla name starts with lower case letter that case change lowercaseclass let the compiler skip the resolving several places this class 
WITHOUT_CLASSIFICATION	 parse parallelism flags 
WITHOUT_CLASSIFICATION	 write the output 
WITHOUT_CLASSIFICATION	 use jansis detection mechanism 
WITHOUT_CLASSIFICATION	 add object unpackstate return name 
WITHOUT_CLASSIFICATION	 created only demand 
WITHOUT_CLASSIFICATION	 callable 
WITHOUT_CLASSIFICATION	 use the debug variant the development binary prefer the host architecture present else use the first architecture specified 
WITHOUT_CLASSIFICATION	 toolchains should using default configuration 
WITHOUT_CLASSIFICATION	 this instance ends buildgradle scoped services for nesteds dont want invoke close that time instead close the root 
WITHOUT_CLASSIFICATION	 matches fall back regexp 
WITHOUT_CLASSIFICATION	 capture output files state 
WITHOUT_CLASSIFICATION	 there previous state then have output changes 
WITHOUT_CLASSIFICATION	 should reuse globalscopeservices here however this requires bunch stuff order discover the plugin service registries for now reimplement the discovery here 
WITHOUT_CLASSIFICATION	 this should apply some locking but most access the build state does not happen via this method yet 
WITHOUT_CLASSIFICATION	 not cache the task are not writing execution data file 
WITHOUT_CLASSIFICATION	 not resolvable discard the body when the expression not resolvable 
WITHOUT_CLASSIFICATION	 adding action that not duplicate 
WITHOUT_CLASSIFICATION	 release the artifact production 
WITHOUT_CLASSIFICATION	 some interesting type references 
WITHOUT_CLASSIFICATION	 return thisname 
WITHOUT_CLASSIFICATION	 ignore 
WITHOUT_CLASSIFICATION	 lookupdefineclass can only define class into same classloader the lookup object have use the fallback defineclass theyre not same which the case 
WITHOUT_CLASSIFICATION	 note null for settingsfile means explicitly settings non null value can non existent file which semantically equivalent empty file 
WITHOUT_CLASSIFICATION	 need another identifier 
WITHOUT_CLASSIFICATION	 generate 
WITHOUT_CLASSIFICATION	 download temporary location 
WITHOUT_CLASSIFICATION	 convert properties for logging object 
WITHOUT_CLASSIFICATION	 make sure its always but without affecting the lower bits 
WITHOUT_CLASSIFICATION	 for tests 
WITHOUT_CLASSIFICATION	 attempt resolution all types dont shortcircuit and stop weve previously failed 
WITHOUT_CLASSIFICATION	 left over data from previous append only possible when multichars new line been processed and split across multiple append calls 
WITHOUT_CLASSIFICATION	 var thisfield 
WITHOUT_CLASSIFICATION	 add dependencies for this goal 
WITHOUT_CLASSIFICATION	 the lock for this project the only lock hold 
WITHOUT_CLASSIFICATION	 fixme always build type name keep parity with previous gradle version tooling api 
WITHOUT_CLASSIFICATION	 theres more than one node selected for the same component need add the implicit capability the list order make sure can discover conflicts between variants the same module note that the fact the implicit capability general not included not bug but performance optimization 
WITHOUT_CLASSIFICATION	 without this the urlconnection will keep the backing jar file open indefinitely this will have performance impact for jarbacked uritextresource instances 
WITHOUT_CLASSIFICATION	 wrap prevent exposing stoppable dont want stop this scope 
WITHOUT_CLASSIFICATION	 other home dir use close these otherwise keep the services for next time 
WITHOUT_CLASSIFICATION	 already realized just run the action now 
WITHOUT_CLASSIFICATION	 every selector was empty simply resolve one them 
WITHOUT_CLASSIFICATION	 cannot private due reflective instantiation 
WITHOUT_CLASSIFICATION	 required for mavenlocal verify the presence the artifact 
WITHOUT_CLASSIFICATION	 make sure more specific annotation doesnt get overwritten with less specific one 
WITHOUT_CLASSIFICATION	 versions before would discard context forced cancel 
WITHOUT_CLASSIFICATION	 register each child each component 
WITHOUT_CLASSIFICATION	 idea module for project current build dont include any module that has been excluded from project 
WITHOUT_CLASSIFICATION	 inverse process resolveclasspath make sure stores correct result 
WITHOUT_CLASSIFICATION	 summary deprecations considered part the build summary 
WITHOUT_CLASSIFICATION	 file that can safely reuse the result for 
WITHOUT_CLASSIFICATION	 not using setoptionaloptional order avoid the common case 
WITHOUT_CLASSIFICATION	 caches the list dependency states for dependencies 
WITHOUT_CLASSIFICATION	 wont for arbitrary scripts though 
WITHOUT_CLASSIFICATION	 todo prevent multiple threads from performing the same vcs populate operation the same time 
WITHOUT_CLASSIFICATION	 task graph not calculated yet plugins can add tasks 
WITHOUT_CLASSIFICATION	 since might generate the deployment descriptor record each toplevel module 
WITHOUT_CLASSIFICATION	 log events 
WITHOUT_CLASSIFICATION	 this import must here due clash java between this and javautiloptional careful running optimize imports will wipe this out theres import below this comment this has happened 
WITHOUT_CLASSIFICATION	 these two are here work around 
WITHOUT_CLASSIFICATION	 remove leading remove last child segment use separator 
WITHOUT_CLASSIFICATION	 returns parameter 
WITHOUT_CLASSIFICATION	 generate class immutable return propertiesempty 
WITHOUT_CLASSIFICATION	 discard event 
WITHOUT_CLASSIFICATION	 lock demand 
WITHOUT_CLASSIFICATION	 use the jar when nothing has been requested 
WITHOUT_CLASSIFICATION	 inputstream originalin systemin 
WITHOUT_CLASSIFICATION	 decoration takes care the implementation 
WITHOUT_CLASSIFICATION	 todo hook this the daemon build lifecycle 
WITHOUT_CLASSIFICATION	 theres more than one module merge them into module set 
WITHOUT_CLASSIFICATION	 opposite outgoing edges virtual edges are for now pretty rare they are created lazily 
WITHOUT_CLASSIFICATION	 thisservices 
WITHOUT_CLASSIFICATION	 make sure dont interpret any tag while description tag 
WITHOUT_CLASSIFICATION	 force graph resolution this required calculate build dependencies 
WITHOUT_CLASSIFICATION	 this generates synthetic enforced platform variant with the same dependencies similar what the maven variant derivation strategy does 
WITHOUT_CLASSIFICATION	 climb the hierarchy looking for the highest parent 
WITHOUT_CLASSIFICATION	 netscape expires pattern 
WITHOUT_CLASSIFICATION	 the path the projects task container the model registry 
WITHOUT_CLASSIFICATION	 only one file 
WITHOUT_CLASSIFICATION	 maps from interned absolute path for file snapshot for the file 
WITHOUT_CLASSIFICATION	 used the javascript plugins 
WITHOUT_CLASSIFICATION	 for nonjava projects there are source sets configured 
WITHOUT_CLASSIFICATION	 not set for jaxp java wont allow referencing dtds using http urls because groovys xmlparser requests 
WITHOUT_CLASSIFICATION	 for performance ignore flushes 
WITHOUT_CLASSIFICATION	 naming conventions via call 
WITHOUT_CLASSIFICATION	 common root 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 were reaching this point were very likely going iterate the dependencies several times appears that iterating using dependencies expensive because the creation iterator and checking bounds iterating array faster 
WITHOUT_CLASSIFICATION	 create test suite executable 
WITHOUT_CLASSIFICATION	 todo reuse metadata was already fetched select the component from the version list 
WITHOUT_CLASSIFICATION	 indicates whether the tests should run deterministic order preserving the order guarantees that the complete test including beforexxx and afterxxx run test thread before the next test run not required not present the order will not preserved 
WITHOUT_CLASSIFICATION	 endtaskargmethod 
WITHOUT_CLASSIFICATION	 check module node import packages 
WITHOUT_CLASSIFICATION	 this allows generate the deployment descriptor after recording all modules contains 
WITHOUT_CLASSIFICATION	 use the runtime when nothing has been requested 
WITHOUT_CLASSIFICATION	 unfortunate cast see 
WITHOUT_CLASSIFICATION	 pathtype 
WITHOUT_CLASSIFICATION	 this means the client does not support reporting jvm memory info 
WITHOUT_CLASSIFICATION	 todo synchronization with other methods 
WITHOUT_CLASSIFICATION	 discard this operation and all children 
WITHOUT_CLASSIFICATION	 note not wantneed decorated version javaforkoptions javadebugoptions because these immutable instances are held across builds and will retain the decorated object 
WITHOUT_CLASSIFICATION	 dont the parent chain dont want risk classes crossing scope boundaries and being non collectible 
WITHOUT_CLASSIFICATION	 see gradle 
WITHOUT_CLASSIFICATION	 the name the test method 
WITHOUT_CLASSIFICATION	 should consider change the return type directdependency which requires adjustment kotlin dsl 
WITHOUT_CLASSIFICATION	 file resources are handled slightly differently present file repos are treated differently dont cache their files 
WITHOUT_CLASSIFICATION	 tagsample 
WITHOUT_CLASSIFICATION	 discard listeners 
WITHOUT_CLASSIFICATION	 this doesnt take into account build dependencies the sourcedirectoryset should just ditch sourcedirectoryset from here since its not really great model and drags too much baggage 
WITHOUT_CLASSIFICATION	 dont know the underlying collection can return size constant time 
WITHOUT_CLASSIFICATION	 always ignore line order for matching out parallel builds 
WITHOUT_CLASSIFICATION	 seems the only feasible way create dependency with classifier 
WITHOUT_CLASSIFICATION	 upgrade required 
WITHOUT_CLASSIFICATION	 there currently requirement the jdk javac implementation that when javac invoked with explicitly empty sourcepath code sourcepath wont allow you compile java module however really want explicitly set empty sourcepath that dont implicitly pull unrequested sourcefiles which havent been snapshotted because will consider the task uptodate the implicit files change this implementation haslocation pretends that the javafilemanager has concept source path 
WITHOUT_CLASSIFICATION	 input 
WITHOUT_CLASSIFICATION	 restarting this configuration after conflict resolution this configuration belongs the select version queue ourselves for traversal not then remove our incoming edges which triggers them moved across the selected configuration 
WITHOUT_CLASSIFICATION	 compilers available complain about the missing compiler 
WITHOUT_CLASSIFICATION	 task dependencies may calculated more than once this guard purely optimisation 
WITHOUT_CLASSIFICATION	 fields guarded lock 
WITHOUT_CLASSIFICATION	 need remember further element was matched earlier one need consider then 
WITHOUT_CLASSIFICATION	 once the root build starts executing work are executing phase 
WITHOUT_CLASSIFICATION	 use selected port 
WITHOUT_CLASSIFICATION	 can wait this handler has completed the previous handler allows waiting 
WITHOUT_CLASSIFICATION	 sort based from component 
WITHOUT_CLASSIFICATION	 levelconfig levelwarning levelwarning levelsevere levelsevere 
WITHOUT_CLASSIFICATION	 ends with 
WITHOUT_CLASSIFICATION	 supports building both bit and bit binaries 
WITHOUT_CLASSIFICATION	 load the static type descriptor from class constants 
WITHOUT_CLASSIFICATION	 wed have created there were file fingerprints 
WITHOUT_CLASSIFICATION	 decided have vanilla name starting with lower case letter that will not try resolve this name against imports instead full import needed for these will this check for this method does also check the module contains class the same package this name this check not done for vanilla names starting 
WITHOUT_CLASSIFICATION	 need this here that the transfer restarted when httpclient reopens the resource digest auth only 
WITHOUT_CLASSIFICATION	 not openjdkcompatible compiler signature changed 
WITHOUT_CLASSIFICATION	 todoadam deprecate 
WITHOUT_CLASSIFICATION	 ignore tasks created after not closed 
WITHOUT_CLASSIFICATION	 already reached this goal 
WITHOUT_CLASSIFICATION	 always want include classname even longer than max length 
WITHOUT_CLASSIFICATION	 kotlinc warning ignore 
WITHOUT_CLASSIFICATION	 node must project item 
WITHOUT_CLASSIFICATION	 flatten because need serialize 
WITHOUT_CLASSIFICATION	 add javahome none provided 
WITHOUT_CLASSIFICATION	 for testing 
WITHOUT_CLASSIFICATION	 when xmxm runtimemaxmemory returns about assume that gradle itself uses about heap 
WITHOUT_CLASSIFICATION	 the groovyobject interface defines dynamic property and dynamic method methods implementers are free implement their own logic these methods which makes invisible the metaclass the most notable case this closure this case use these methods directly the groovyobject case does implement logic this level 
WITHOUT_CLASSIFICATION	 todo stop all daemon services 
WITHOUT_CLASSIFICATION	 for each level the file path add the path 
WITHOUT_CLASSIFICATION	 below could better throwing here means that useful context information including candidate formats etc not presented the user 
WITHOUT_CLASSIFICATION	 nobody said anything about this variants target platform use whatever the convention says 
WITHOUT_CLASSIFICATION	 reference class via modeltype avoid strong reference 
WITHOUT_CLASSIFICATION	 used for testing the plugins dsl 
WITHOUT_CLASSIFICATION	 create key manager 
WITHOUT_CLASSIFICATION	 the version string cannot parsed 
WITHOUT_CLASSIFICATION	 exclusions nothing then the intersection will nothing 
WITHOUT_CLASSIFICATION	 separate java class because ibm jdk see 
WITHOUT_CLASSIFICATION	 update the state region 
WITHOUT_CLASSIFICATION	 using array here because were going iterate pretty often and avoids the creation iterator that checks for concurrent modification 
WITHOUT_CLASSIFICATION	 the download thread may still running ignore any further status events from 
WITHOUT_CLASSIFICATION	 fall back propertymissing available 
WITHOUT_CLASSIFICATION	 known value only write index 
WITHOUT_CLASSIFICATION	 not supported java 
WITHOUT_CLASSIFICATION	 avoid excess creation suggestion objects 
WITHOUT_CLASSIFICATION	 todo set header dir for applications 
WITHOUT_CLASSIFICATION	 just identifier this token 
WITHOUT_CLASSIFICATION	 not the first top level node 
WITHOUT_CLASSIFICATION	 tries relocate literals the form foobarbar 
WITHOUT_CLASSIFICATION	 both are strings compare them taking into account special meaning 
WITHOUT_CLASSIFICATION	 this could very well zip something else understand but cant know for sure the client may try infer from the file extension 
WITHOUT_CLASSIFICATION	 build buildsrc load settingsgradle and construct composite appropriate 
WITHOUT_CLASSIFICATION	 check see should adjust the level based set lifecycle log level 
WITHOUT_CLASSIFICATION	 check environment 
WITHOUT_CLASSIFICATION	 restart each configuration for the evicted configuration this means moving incoming dependencies across the matching selected configuration for the select configuration this mean traversing its dependencies 
WITHOUT_CLASSIFICATION	 functionlike macro 
WITHOUT_CLASSIFICATION	 object name object value 
WITHOUT_CLASSIFICATION	 the provider does not know how produce the value use the value instead 
WITHOUT_CLASSIFICATION	 register capabilities for this node 
WITHOUT_CLASSIFICATION	 set thisname param 
WITHOUT_CLASSIFICATION	 milestone was broken the ibm jvm 
WITHOUT_CLASSIFICATION	 replace higher priority version with highest priority and version 
WITHOUT_CLASSIFICATION	 serialize the shared packages this consumed gradleworkermain 
WITHOUT_CLASSIFICATION	 send some messages 
WITHOUT_CLASSIFICATION	 could throw 
WITHOUT_CLASSIFICATION	 handle consumer 
WITHOUT_CLASSIFICATION	 throw new already registered type accessor 
WITHOUT_CLASSIFICATION	 operation there script code provided 
WITHOUT_CLASSIFICATION	 this dependency internal only 
WITHOUT_CLASSIFICATION	 will overwritten setidle not idle 
WITHOUT_CLASSIFICATION	 there script class when there are statements methods declared the script 
WITHOUT_CLASSIFICATION	 tododaniel swift compiler should extends from abstraction nativecompiler most applies swiftcompiler 
WITHOUT_CLASSIFICATION	 services mixed 
WITHOUT_CLASSIFICATION	 any available visual studio implementation 
WITHOUT_CLASSIFICATION	 here know that the user requested specific classifier there may multiple candidate variants left but maybe only one them provides the classified artifact were looking for 
WITHOUT_CLASSIFICATION	 expected 
WITHOUT_CLASSIFICATION	 nonserializable field 
WITHOUT_CLASSIFICATION	 can only set once should really part the constructor 
WITHOUT_CLASSIFICATION	 thissuperp 
WITHOUT_CLASSIFICATION	 dont care about nodes whose output not consumed anyone anymore 
WITHOUT_CLASSIFICATION	 throw new viewtypeclass args 
WITHOUT_CLASSIFICATION	 because these properties can convention mapped need special handling here you add another one these modelled properties you need update instructionvalue 
WITHOUT_CLASSIFICATION	 milestone 
WITHOUT_CLASSIFICATION	 override this that the working directory not canonicalised some int tests require that the working directory not canonicalised 
WITHOUT_CLASSIFICATION	 generate authentication token which must provided the client any requests makes 
WITHOUT_CLASSIFICATION	 todo creating bundle should done some general purpose plugin 
WITHOUT_CLASSIFICATION	 wire build dependent components tasks dependencies 
WITHOUT_CLASSIFICATION	 ibm windows gotchas need print something else the stream after print the daemon greeting 
WITHOUT_CLASSIFICATION	 todo turn this into implspec annotation the comment above 
WITHOUT_CLASSIFICATION	 see ideascalaconfigurer which requires the ipr generated first 
WITHOUT_CLASSIFICATION	 map the arguments this expression 
WITHOUT_CLASSIFICATION	 noinspection 
WITHOUT_CLASSIFICATION	 dont retain the value allow classloader collected 
WITHOUT_CLASSIFICATION	 disallow custom services type serviceregistry these are automatically provided 
WITHOUT_CLASSIFICATION	 add link task 
WITHOUT_CLASSIFICATION	 assume this class and has implemented all properties and methods somewhere the superclass hierarchy 
WITHOUT_CLASSIFICATION	 this that visualcpp has the object file the generated source file available link time 
WITHOUT_CLASSIFICATION	 result from require just use the highest preferred version range merging 
WITHOUT_CLASSIFICATION	 are going throw below but want the message reflect that didnt recognise the first char the option specifier 
WITHOUT_CLASSIFICATION	 take copy because adding idmappings value may result new mappings being added 
WITHOUT_CLASSIFICATION	 generate supersetterv 
WITHOUT_CLASSIFICATION	 this point daemon mode the process has started successfully and all streams the process have been closed fork mode the process has completed and all cleanup has been done both cases all asynchronous work for the process has completed and were done 
WITHOUT_CLASSIFICATION	 cache result because pretty expensive compute 
WITHOUT_CLASSIFICATION	 trailing assumes 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 milestone and 
WITHOUT_CLASSIFICATION	 note meminfomatcher not thread safe and access needs limited single thread 
WITHOUT_CLASSIFICATION	 otherwise the streamsize returns max integer and the offset longer correct 
WITHOUT_CLASSIFICATION	 broken another thread 
WITHOUT_CLASSIFICATION	 not supported for now 
WITHOUT_CLASSIFICATION	 endhostandpath 
WITHOUT_CLASSIFICATION	 include file changed 
WITHOUT_CLASSIFICATION	 otherwise try remotely 
WITHOUT_CLASSIFICATION	 this little coincidental view attributes have not been accessed dont allow matching variants 
WITHOUT_CLASSIFICATION	 todo weve already calculated the common prefix and calling plus will calculate again 
WITHOUT_CLASSIFICATION	 add the unit test and extension 
WITHOUT_CLASSIFICATION	 call thissuper 
WITHOUT_CLASSIFICATION	 macro function call 
WITHOUT_CLASSIFICATION	 this ensures that subprojects are realized and register their project and project configuration ide artifacts 
WITHOUT_CLASSIFICATION	 makes identity comparisons 
WITHOUT_CLASSIFICATION	 milestone 
WITHOUT_CLASSIFICATION	 removing the leading this longer path defined eclipse 
WITHOUT_CLASSIFICATION	 creates control regexp pattern where extra revision tokens must have the same value the original one 
WITHOUT_CLASSIFICATION	 notify any waiting flush threads that the worker done possibly with failure 
WITHOUT_CLASSIFICATION	 also use the generated class for itself 
WITHOUT_CLASSIFICATION	 task execution services all levels needs this 
WITHOUT_CLASSIFICATION	 compatible variant found 
WITHOUT_CLASSIFICATION	 ant optional dependency groovyall module but mandatory dependency groovy compiler thats why add here the following assumes that any groovy compiler version supported gradle compatible with gradles current ant version 
WITHOUT_CLASSIFICATION	 asserts using 
WITHOUT_CLASSIFICATION	 used for log and date only 
WITHOUT_CLASSIFICATION	 milestone 
WITHOUT_CLASSIFICATION	 intentionally asymmetrical getexecuted this prevents recursion projectevaluate 
WITHOUT_CLASSIFICATION	 adding the properties from the super class onto the inheriting class 
WITHOUT_CLASSIFICATION	 but should 
WITHOUT_CLASSIFICATION	 member the class breaks binary compatibility that will handled when the member passed maybeviolation 
WITHOUT_CLASSIFICATION	 thisservicesmethod 
WITHOUT_CLASSIFICATION	 empty only whitespace 
WITHOUT_CLASSIFICATION	 reuse not possible across modules currently 
WITHOUT_CLASSIFICATION	 for backwards compatibility use the last added description 
WITHOUT_CLASSIFICATION	 linux users cannot touch files they dont own but have write access because the jdk uses futimes instead futimens note the see 
WITHOUT_CLASSIFICATION	 thead tdpropertytd tddescriptiontd thead 
WITHOUT_CLASSIFICATION	 read properties files 
WITHOUT_CLASSIFICATION	 implicitly dont clean this throws 
WITHOUT_CLASSIFICATION	 for someone looking for the difference between this and the duplicate code above this one uses the testtaskprovider and the reporttask the other just uses the reporttask 
WITHOUT_CLASSIFICATION	 disable jar file caching prevent file locking 
WITHOUT_CLASSIFICATION	 add plugin implementation here 
WITHOUT_CLASSIFICATION	 performance test that compares gradles current performance against some baseline and fails slower 
WITHOUT_CLASSIFICATION	 else already visited currently visiting which means cycle skip 
WITHOUT_CLASSIFICATION	 fix the source file name displayed the error messages 
WITHOUT_CLASSIFICATION	 can tell for sure 
WITHOUT_CLASSIFICATION	 when there class name match return true for excluding that can keep searching individual test methods for exact match return false here instead then well give searching individual test methods and just ignore the entire test class which may not what want 
WITHOUT_CLASSIFICATION	 linux memavailable linux memfree buffers cached sreclaimable mapped 
WITHOUT_CLASSIFICATION	 these should come from the compiler classloader 
WITHOUT_CLASSIFICATION	 acquire exclusive lock the information region and write our details there 
WITHOUT_CLASSIFICATION	 works java 
WITHOUT_CLASSIFICATION	 trailing eol 
WITHOUT_CLASSIFICATION	 pom packaging doesnt matter when have single unclassified artifact 
WITHOUT_CLASSIFICATION	 try each address turn not all them are necessarily reachable when socket option ipvvonly the default for debian and others will try each them until can connect 
WITHOUT_CLASSIFICATION	 use the display name anyway 
WITHOUT_CLASSIFICATION	 use java apis available 
WITHOUT_CLASSIFICATION	 handle origin metadata 
WITHOUT_CLASSIFICATION	 determine which output produce development time 
WITHOUT_CLASSIFICATION	 dispatch not serialized 
WITHOUT_CLASSIFICATION	 when running from gradle distro only need launcher jar the daemon can find everything from there 
WITHOUT_CLASSIFICATION	 todo reuse graph discard state once not required 
WITHOUT_CLASSIFICATION	 collect the components sort consumerfirst order 
WITHOUT_CLASSIFICATION	 replicate little bit annotationvisitor here because cant wait until later this 
WITHOUT_CLASSIFICATION	 this the highest parent the hierarchy 
WITHOUT_CLASSIFICATION	 further mutation allowed and theres parent the artifact set corresponds this configuration own artifacts 
WITHOUT_CLASSIFICATION	 nothing for now 
WITHOUT_CLASSIFICATION	 remove duplicates 
WITHOUT_CLASSIFICATION	 from compile configuration when the targets runtime configuration does not extend from compile include the compile dependencies 
WITHOUT_CLASSIFICATION	 when creating the osgi manifest must have single view all the classes included the jar 
WITHOUT_CLASSIFICATION	 todo visit dependencies this collection instead 
WITHOUT_CLASSIFICATION	 dont write the rightmost column some consoles the cursor will wrap the next line and currently wrapping causes layout weirdness 
WITHOUT_CLASSIFICATION	 not store the history there was failure and the outputs did not change since then the next execution can incremental for example the current execution fails because compile failure and for the next execution the source file fixed only the one changed source file needs compiled 
WITHOUT_CLASSIFICATION	 check alreadyresolved dependencies and use this version its compatible 
WITHOUT_CLASSIFICATION	 perform conflict resolution 
WITHOUT_CLASSIFICATION	 caches the list dependency states which are not excluded 
WITHOUT_CLASSIFICATION	 relative coordinate system 
WITHOUT_CLASSIFICATION	 the first call getconfiguration done before getderivedvariants called then means were using the legacy matching without attributes and that the metadata construct should not include the constraints keep the constraints the descriptors because actually use attribute matching can select the platform variant which does use constraints 
WITHOUT_CLASSIFICATION	 synchronizes the system properties because ivysettings iterates over them without taking defensive copy this can fail another process sets system property that moment 
WITHOUT_CLASSIFICATION	 antlr always returning 
WITHOUT_CLASSIFICATION	 todo this inside some testng suite that failures and logging are attached testng rather than some test worker 
WITHOUT_CLASSIFICATION	 progress events have expensive logic their own dont anything with them only test the overhead sendingreceiving them 
WITHOUT_CLASSIFICATION	 have not seen this node before add its dependencies the head the queue and leave this node the queue make sure has been configured 
WITHOUT_CLASSIFICATION	 need toolsjar for compile tasks 
WITHOUT_CLASSIFICATION	 handle the property part were not part the property 
WITHOUT_CLASSIFICATION	 not need check instances lowercaseclass class because unless there was import for for this not lookup these cases this was decision made the mailing list ensure will not visit this method again set noclass for this name 
WITHOUT_CLASSIFICATION	 trigger download file required 
WITHOUT_CLASSIFICATION	 not substitute plugins from same build builds that were not explicitly included 
WITHOUT_CLASSIFICATION	 noinspection 
WITHOUT_CLASSIFICATION	 this approximation all compiled sources will use the same task dependency 
WITHOUT_CLASSIFICATION	 shorten args and write out optionstxt file this must called only once per execute 
WITHOUT_CLASSIFICATION	 this point the workinprogress area may may not have been resized due maximum size constraint 
WITHOUT_CLASSIFICATION	 using string instead plain here might look strange but this turned out the fastest several experiments including using moduleidentifier initial implementation using moduleidentifier through for interning using level map group then name using interned string for the cachedid interning turned out cost much what gain from faster checks maps and none them reached the performance just using good old string 
WITHOUT_CLASSIFICATION	 copy the raw form 
WITHOUT_CLASSIFICATION	 not use timestamp that the same the end the last build the start this build 
WITHOUT_CLASSIFICATION	 when using keep the old behaviour all file inputs being incremental 
WITHOUT_CLASSIFICATION	 unknown scope defaulting compile 
WITHOUT_CLASSIFICATION	 encode the character using hex notation 
WITHOUT_CLASSIFICATION	 use empty settings for target build file located the same directory the settings file 
WITHOUT_CLASSIFICATION	 this point know the component exists 
WITHOUT_CLASSIFICATION	 any available clang 
WITHOUT_CLASSIFICATION	 cannot use instead sha here because cache will get corrupted due its expectation sha hashes 
WITHOUT_CLASSIFICATION	 discard static initializers 
WITHOUT_CLASSIFICATION	 generate 
WITHOUT_CLASSIFICATION	 this scala compile published into jar generate analysis mapping file 
WITHOUT_CLASSIFICATION	 consume content for nonsuccessful responses this avoids the connection being left open 
WITHOUT_CLASSIFICATION	 macro expand parameter 
WITHOUT_CLASSIFICATION	 already something uncompress 
WITHOUT_CLASSIFICATION	 reset console mode 
WITHOUT_CLASSIFICATION	 not macro expand parameter 
WITHOUT_CLASSIFICATION	 gate hasnt been opened yet 
WITHOUT_CLASSIFICATION	 getmaxworkercount because main thread executes work well see todo this could more efficient that only start worker when there are none idle and there worker lease available 
WITHOUT_CLASSIFICATION	 dont synchronize value creation 
WITHOUT_CLASSIFICATION	 todo locate this tool from tool provider 
WITHOUT_CLASSIFICATION	 have keep this for while 
WITHOUT_CLASSIFICATION	 wire build dependent binaries tasks dependencies 
WITHOUT_CLASSIFICATION	 these files have unreliable timestamp discard any cached state for them and rehash next time they are seen 
WITHOUT_CLASSIFICATION	 the previous result still not rejected not need reresolve the previous result still good 
WITHOUT_CLASSIFICATION	 put the whole arguments string single quotes unless defaultjvmopts was empty 
WITHOUT_CLASSIFICATION	 constantclass entry read the class descriptor 
WITHOUT_CLASSIFICATION	 see different value the set already exists which case initialize the set wasnt done already and collect all values 
WITHOUT_CLASSIFICATION	 assuming format swift version 
WITHOUT_CLASSIFICATION	 the remote may have already given the checksum 
WITHOUT_CLASSIFICATION	 need resolve the classes into set files skipwhenempty will work otherwise collection empty directories not seen empty 
WITHOUT_CLASSIFICATION	 lets make sure never need reallocate 
WITHOUT_CLASSIFICATION	 throws exception 
WITHOUT_CLASSIFICATION	 this set represents the order which elements are inserted the store either actual provided construct correct iteration order from this set 
WITHOUT_CLASSIFICATION	 yeah setting the background intensity not underlining but its best can using the windows console api 
WITHOUT_CLASSIFICATION	 this could more efficient assume that removal happens much less often than addition 
WITHOUT_CLASSIFICATION	 typeservice 
WITHOUT_CLASSIFICATION	 generate class publictype 
WITHOUT_CLASSIFICATION	 protects the following state contains only application owned classloaders 
WITHOUT_CLASSIFICATION	 these objects are going across the wire convert any subclasses back file case the subclass isnt available gradle make them absolute here deal with different root the server 
WITHOUT_CLASSIFICATION	 serialize anything else 
WITHOUT_CLASSIFICATION	 does defensive copy avoid leaking class references through the contained the maps values the keyset would keep strong reference back the map and all its entries 
WITHOUT_CLASSIFICATION	 also available via but would have grab via reflection 
WITHOUT_CLASSIFICATION	 extract exceptions 
WITHOUT_CLASSIFICATION	 summary 
WITHOUT_CLASSIFICATION	 todo mix groovy dsl support 
WITHOUT_CLASSIFICATION	 order important here because they will searched that order 
WITHOUT_CLASSIFICATION	 adds action which executed before this collection mutated with the addition removal elements any exception thrown the action will veto the mutation todo combine this with the mutationguard rework behave with the mutation validators used only expect used with addremove methods and fail when correctly try also prevent allwithtypeetc mutation methods only used addremove methods but should remove this special handling and fix and 
WITHOUT_CLASSIFICATION	 null the constructorselector says its 
WITHOUT_CLASSIFICATION	 create log file 
WITHOUT_CLASSIFICATION	 show all operation output when debug enabled 
WITHOUT_CLASSIFICATION	 transition any other nodes that depend the predecessor state 
WITHOUT_CLASSIFICATION	 element names can only contain colon see the name has prefix evaluate both prefix and name 
WITHOUT_CLASSIFICATION	 coerce the value the property type known 
WITHOUT_CLASSIFICATION	 very expensive when the property not known instead reach into the meta class call much more efficient lookup method since this hot code path also reuse the argument array used for the reflective call save memory 
WITHOUT_CLASSIFICATION	 dont collect build dependencies not required 
WITHOUT_CLASSIFICATION	 please keep the formatting below helps enabling disabling stages optimizes for nulls params mandatory caches the result operations performs algebra caches the result optimization operations the end the chain mandatory shares the same caches the top level one after reducing can find already cached merge operations 
WITHOUT_CLASSIFICATION	 not part the public api 
WITHOUT_CLASSIFICATION	 cleanup old html report directories 
WITHOUT_CLASSIFICATION	 fix problems updating jar files disabling default caching url connections urlconnection default caching should disabled since causes jar file locking issues and jvm crashes updating jar files changes jar files wont noticed all cases when caching enabled leaves the jarfile instance open urlconnection caching enabled 
WITHOUT_CLASSIFICATION	 here means that have validated that the entry still uptodate and that means couple things the cache policy said that the entry still valid for example refreshdependencies wasnt called the rule cacheable have validated that its discovered inputs are still the same 
WITHOUT_CLASSIFICATION	 gigs 
WITHOUT_CLASSIFICATION	 from every configuration other than compile include both the runtime and compile dependencies 
WITHOUT_CLASSIFICATION	 read serialized worker 
WITHOUT_CLASSIFICATION	 only add confs they are specified they arent endelement will handle this only there are conf defined sub elements 
WITHOUT_CLASSIFICATION	 this empty root block discard 
WITHOUT_CLASSIFICATION	 buffer was full just call threadyield 
WITHOUT_CLASSIFICATION	 these constants are defined here and not with the rest their kind helptasksplugin because they are referenced the core modules which dont depend plugins where helptasksplugin defined 
WITHOUT_CLASSIFICATION	 overwrite rather than append dependencies 
WITHOUT_CLASSIFICATION	 resolve constantlooking expressions statically here gets transformed away later 
WITHOUT_CLASSIFICATION	 currently need resolve the file that the artifact can used both script classpath and the main build instead this should resolved required 
WITHOUT_CLASSIFICATION	 create unbuildable build configuration the indexer can keep functioning 
WITHOUT_CLASSIFICATION	 turn the requested watch points into actual enclosing directories that exist 
WITHOUT_CLASSIFICATION	 need transformer part antbuilder api from base services 
WITHOUT_CLASSIFICATION	 create trust manager 
WITHOUT_CLASSIFICATION	 dont know what the max heap approximate based total memory 
WITHOUT_CLASSIFICATION	 check for presence the domain object may have been replaced 
WITHOUT_CLASSIFICATION	 make convention mapping work 
WITHOUT_CLASSIFICATION	 convert second time with only the published configurations this ensures that the correct artifacts are included 
WITHOUT_CLASSIFICATION	 nothing eclipseruntime supplied 
WITHOUT_CLASSIFICATION	 add separators before and after anything with comment that block group statements 
WITHOUT_CLASSIFICATION	 try get the name from eclipseprojectname 
WITHOUT_CLASSIFICATION	 shutdown the adapter groovy system 
WITHOUT_CLASSIFICATION	 discard the compile loader 
WITHOUT_CLASSIFICATION	 only report subject binding target state after node creation 
WITHOUT_CLASSIFICATION	 remembers the unresolved dependency for later logging and also adds fake file dependency with the file path pointing the attempted component selector this shows the ide red flag the dependencies view thats not the best usability and also muddies the api contract because disguise unresolved dependency file dependency even though that file really doesnt exist instead when generating files the command line the logged warning enough when using the tooling api dedicated unresolved dependency object would better and could shown notification the command line warning should probably omitted that case 
WITHOUT_CLASSIFICATION	 set the visible included builds 
WITHOUT_CLASSIFICATION	 nested closure 
WITHOUT_CLASSIFICATION	 only cache nonoverloaded methods name 
WITHOUT_CLASSIFICATION	 artifacts are not known until the file collection queried 
WITHOUT_CLASSIFICATION	 toolchains should linking against stuff the standard locations 
WITHOUT_CLASSIFICATION	 have pass build jvm args directly launcher jvm 
WITHOUT_CLASSIFICATION	 cant acquire lock get details owner include the error message 
WITHOUT_CLASSIFICATION	 ignore things know are empty 
WITHOUT_CLASSIFICATION	 ping the owner via all available local addresses 
WITHOUT_CLASSIFICATION	 check our classpath 
WITHOUT_CLASSIFICATION	 inject allowed fields only 
WITHOUT_CLASSIFICATION	 class file versions 
WITHOUT_CLASSIFICATION	 todo when support multiple components configurable dependencies well need merge the confs multiple dependencies with same 
WITHOUT_CLASSIFICATION	 ignore exception shutdown 
WITHOUT_CLASSIFICATION	 the target project component has not been modified from the requested 
WITHOUT_CLASSIFICATION	 generate null 
WITHOUT_CLASSIFICATION	 return 
WITHOUT_CLASSIFICATION	 detect anonymous static classes enum constants with class body see and the optional class body enum constant implicitly defines anonymous class declaration that extends the immediately enclosing enum type 
WITHOUT_CLASSIFICATION	 hackery make closure execution faster shortcircuiting the expensive property and method lookup closure 
WITHOUT_CLASSIFICATION	 only managed implementation and value types are allowed managed property type unless marked with unmanaged 
WITHOUT_CLASSIFICATION	 isinitialpass 
WITHOUT_CLASSIFICATION	 readonly property with managed type 
WITHOUT_CLASSIFICATION	 not traverse seen already 
WITHOUT_CLASSIFICATION	 inject the launcher jvm args via one the environment variables 
WITHOUT_CLASSIFICATION	 the classloader structure flat theres need send the classpath 
WITHOUT_CLASSIFICATION	 could potentially avoid creating value that already being created different thread 
WITHOUT_CLASSIFICATION	 wait for the process stdout indicate that the process has been started successfully 
WITHOUT_CLASSIFICATION	 currently single list optionals 
WITHOUT_CLASSIFICATION	 expire under high jvm memory pressure 
WITHOUT_CLASSIFICATION	 scenariolist contains duplicate scenarios because rerun 
WITHOUT_CLASSIFICATION	 the jansistrip property set then just strip the 
WITHOUT_CLASSIFICATION	 makes sure that commonelements stacktracesize 
WITHOUT_CLASSIFICATION	 use this instead not available junit 
WITHOUT_CLASSIFICATION	 generate prop true 
WITHOUT_CLASSIFICATION	 ignore any other outcome 
WITHOUT_CLASSIFICATION	 public methods belongs your api 
WITHOUT_CLASSIFICATION	 todo allow this added lazily 
WITHOUT_CLASSIFICATION	 then want validate strictly 
WITHOUT_CLASSIFICATION	 selection deferred know another selector will added soon 
WITHOUT_CLASSIFICATION	 when selector changes from non lock lock must reselect 
WITHOUT_CLASSIFICATION	 important that the launchables are unpacked the client side avoid sending back any additional internal state that the launchable may hold onto for example gradletask implementations hold onto every task for every project the build 
WITHOUT_CLASSIFICATION	 retry after getting bad file descriptor exception 
WITHOUT_CLASSIFICATION	 lambdas contain name thats based index timestamp runtime and changes buildtobuild this makes comparing two builds very difficult when lambda the stack changes 
WITHOUT_CLASSIFICATION	 mutablemodelnode methods 
WITHOUT_CLASSIFICATION	 quote everything else 
WITHOUT_CLASSIFICATION	 this severs the connection between from this debugoptions the other debugoptions 
WITHOUT_CLASSIFICATION	 just for reporting 
WITHOUT_CLASSIFICATION	 have single common resolution conflicts resolve 
WITHOUT_CLASSIFICATION	 must included build 
WITHOUT_CLASSIFICATION	 this slight different condition than that used for dependency declared gradle project which targethasvariants relying the fallback default for consumer attributes without any variants 
WITHOUT_CLASSIFICATION	 todo merge this and the component container 
WITHOUT_CLASSIFICATION	 lookup class all classloaders 
WITHOUT_CLASSIFICATION	 would typically use but does not work with signatures 
WITHOUT_CLASSIFICATION	 either macro function macro token concatenation 
WITHOUT_CLASSIFICATION	 generate 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 not null not empty 
WITHOUT_CLASSIFICATION	 read command line flags 
WITHOUT_CLASSIFICATION	 should not happen 
WITHOUT_CLASSIFICATION	 couldnt handle anything with timestamp whose timezone was behind gmt 
WITHOUT_CLASSIFICATION	 caching involves distinct caches that scripts with the same hash classpath not get compiled twice first look for cache script which path hash matches this cache invalidated when the compile classpath the script changes then look into the cache for generic script with the same hash that will remapped the script class name both caches can closed directly after use because for the script changes its compile classpath changes different directory will used for the script changes different cache used the classpath changes the cache invalidated but classes are remapped anyway never directly used 
WITHOUT_CLASSIFICATION	 create sourcefile object represent the javascript file compile 
WITHOUT_CLASSIFICATION	 remove all the methods from the main class 
WITHOUT_CLASSIFICATION	 dont support shrinking the moment 
WITHOUT_CLASSIFICATION	 create synthetic for the build the already used should instead use structured implementation some kind instead 
WITHOUT_CLASSIFICATION	 exists has content 
WITHOUT_CLASSIFICATION	 not process objects groovyobjects methods 
WITHOUT_CLASSIFICATION	 todo this should applied all methods including delegating methods 
WITHOUT_CLASSIFICATION	 could potentially coordinate with thread that snapshotting overlapping directory tree 
WITHOUT_CLASSIFICATION	 supported nothing 
WITHOUT_CLASSIFICATION	 the module matches add the root component into the mix 
WITHOUT_CLASSIFICATION	 too many requests not available through httpstatusxxx 
WITHOUT_CLASSIFICATION	 unpacks the request serialize across the daemon and creates instance 
WITHOUT_CLASSIFICATION	 cleanup will abort the process desired 
WITHOUT_CLASSIFICATION	 include file not found but previously was found 
WITHOUT_CLASSIFICATION	 empty capability list means that its implicit capability only 
WITHOUT_CLASSIFICATION	 readwriteexecute for user only readwrite for user only 
WITHOUT_CLASSIFICATION	 groovy when normal variable simply being used there need try resolve its type variable type resolve should proceed only the variable being declared 
WITHOUT_CLASSIFICATION	 only handle the command line for now 
WITHOUT_CLASSIFICATION	 turn off request logging unless debug mode enabled 
WITHOUT_CLASSIFICATION	 unknown type just inspect ourselves should instead share this with all registries 
WITHOUT_CLASSIFICATION	 fall back default runner 
WITHOUT_CLASSIFICATION	 resolvable configurations 
WITHOUT_CLASSIFICATION	 based the benchmark found and the results the were using native platform for mac and mix file and nio api for linux and windows once jdk out need revisit the choice because testing for fileexists should become much cheaper using the pure nio implementation 
WITHOUT_CLASSIFICATION	 val rightresult resultright val generatedfiles rightget val empty emptybooleanvalue 
WITHOUT_CLASSIFICATION	 matches task args identifier args taskargs identifier args map taskargs identifier args 
WITHOUT_CLASSIFICATION	 report fields with annotations that have not been seen while processing properties 
WITHOUT_CLASSIFICATION	 snarl not running 
WITHOUT_CLASSIFICATION	 credential decides can handle the return code message indicated something specific authentication and backoff desired 
WITHOUT_CLASSIFICATION	 body simple expression including macro function call with arguments 
WITHOUT_CLASSIFICATION	 enable the use gradle metadata this temporary optin switch until available default 
WITHOUT_CLASSIFICATION	 this cached because used very often sorting selectors 
WITHOUT_CLASSIFICATION	 providerinternal isa check first 
WITHOUT_CLASSIFICATION	 implementations should not wrap exceptions this done 
WITHOUT_CLASSIFICATION	 found attribute with the same name but they not necessarily have the same type 
WITHOUT_CLASSIFICATION	 consumable configurations 
WITHOUT_CLASSIFICATION	 handle just empty string single identifier params should handle more parsing the tokens into expression 
WITHOUT_CLASSIFICATION	 todo add handling for testonly dependencies once merged 
WITHOUT_CLASSIFICATION	 macro name 
WITHOUT_CLASSIFICATION	 does not take effect until after execution has completed 
WITHOUT_CLASSIFICATION	 only apply default locations when none explicitly configured 
WITHOUT_CLASSIFICATION	 empty text nodes hinder subsequent formatting 
WITHOUT_CLASSIFICATION	 resolve later 
WITHOUT_CLASSIFICATION	 first look for property known the metaclass 
WITHOUT_CLASSIFICATION	 component under test 
WITHOUT_CLASSIFICATION	 just move back seconds 
WITHOUT_CLASSIFICATION	 first pass local resolves only 
WITHOUT_CLASSIFICATION	 todo deprecate and eventually prevent these mutations parent when already resolved 
WITHOUT_CLASSIFICATION	 artifacts keep track transformed artifacts given artifact may appear multiple variants 
WITHOUT_CLASSIFICATION	 ignore exclusions for dependencies with but not for 
WITHOUT_CLASSIFICATION	 jvm args that must used fork jvm 
WITHOUT_CLASSIFICATION	 custom type 
WITHOUT_CLASSIFICATION	 discovered java location 
WITHOUT_CLASSIFICATION	 include all optional dependencies optional configuration 
WITHOUT_CLASSIFICATION	 ignored 
WITHOUT_CLASSIFICATION	 assume 
WITHOUT_CLASSIFICATION	 create the and initialize the sslcontext 
WITHOUT_CLASSIFICATION	 use identity hashmap for performance because know that our attributes are generated factory which guarantees same instances 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 casts class below are workaround eclipse compiler bug see 
WITHOUT_CLASSIFICATION	 clean old stop events 
WITHOUT_CLASSIFICATION	 exit code success exit code failed tests anything else considered execution failure 
WITHOUT_CLASSIFICATION	 macos assume colocated xcode installed into optxcode 
WITHOUT_CLASSIFICATION	 previous character not separator 
WITHOUT_CLASSIFICATION	 defer attaching the model until all components have been most likely configured todo make this relationship explicit make this more reliable and offer better diagnostics 
WITHOUT_CLASSIFICATION	 extracted distribution usually looks like checksumdir gradlebinzipok gradlebinziplck gradlebinzip gradle 
WITHOUT_CLASSIFICATION	 check package this class defined the usage here means that the module package will not involved when the compiler tries find inner class 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 windows know the console does not interpret ansi codes 
WITHOUT_CLASSIFICATION	 following patterns are built upon constants above and should not modified 
WITHOUT_CLASSIFICATION	 ordered how much they filter 
WITHOUT_CLASSIFICATION	 default the local cache directory cache 
WITHOUT_CLASSIFICATION	 just need get the lock for this project 
WITHOUT_CLASSIFICATION	 note when removing provider dont need fireobjectremoved they were never added the first place 
WITHOUT_CLASSIFICATION	 the same situation with nativeheaderoutput javac just npes dont bother 
WITHOUT_CLASSIFICATION	 the jansipassthrough property set then dont interpret 
WITHOUT_CLASSIFICATION	 benchmark mode cnt score error units thrpt opss thrpt opss 
WITHOUT_CLASSIFICATION	 are currently adding configuration either include exclude artifact element dependency this means that have add this element the corresponding conf the current dependency descriptor 
WITHOUT_CLASSIFICATION	 path 
WITHOUT_CLASSIFICATION	 the previous result was rejected not need reresolve new rejects will superset previous rejects 
WITHOUT_CLASSIFICATION	 mingw requires the path set 
WITHOUT_CLASSIFICATION	 supername can null what are analyzing javalangobject which can happen when custom java sdk classpath typically androidjar 
WITHOUT_CLASSIFICATION	 see all entry points have the same identifier 
WITHOUT_CLASSIFICATION	 unfortunately cant determine this constructor time because cachebuilder calls our constructor and its not easy pass arguments 
WITHOUT_CLASSIFICATION	 virtual components have source 
WITHOUT_CLASSIFICATION	 collect any container level add actions added since the last call configure 
WITHOUT_CLASSIFICATION	 not change the signature this method convention used our internal performance testing infrastructure 
WITHOUT_CLASSIFICATION	 add the application and extension 
WITHOUT_CLASSIFICATION	 try configure element 
WITHOUT_CLASSIFICATION	 pass extract plugin requests and plugin repositories and execute buildscript ignoring not even compiling anything else 
WITHOUT_CLASSIFICATION	 another case want check here are nested class abc and want access without qualifying alone will work since that the qualified minus package name that class anyway 
WITHOUT_CLASSIFICATION	 first things first retro compatibility 
WITHOUT_CLASSIFICATION	 strip the ansi sequences 
WITHOUT_CLASSIFICATION	 milestone was broken where jna was not available noinspection 
WITHOUT_CLASSIFICATION	 todo this where the password information would 
WITHOUT_CLASSIFICATION	 unknown try remote search 
WITHOUT_CLASSIFICATION	 for custom ivy pattern matchers dont inspect the rule any more deeply this prevents from doing smart merging later 
WITHOUT_CLASSIFICATION	 conflict with matching participants found create new 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 the included ivy file not found file system tries resolve using 
WITHOUT_CLASSIFICATION	 todo display name 
WITHOUT_CLASSIFICATION	 prevent further tests ignored from triggering start actions 
WITHOUT_CLASSIFICATION	 known but not buildable 
WITHOUT_CLASSIFICATION	 stop the pipeline mark daemon stopped that any incoming requests will rejected with daemon unavailable remove presence from registry stop accepting new connections wait for commands progress finish except for abandoned long running commands like running build 
WITHOUT_CLASSIFICATION	 example 
WITHOUT_CLASSIFICATION	 executebuild should the last action but case want decorate the result the future 
WITHOUT_CLASSIFICATION	 generate public type getter return prop prop 
WITHOUT_CLASSIFICATION	 new entry 
WITHOUT_CLASSIFICATION	 else has been removed something else ignore 
WITHOUT_CLASSIFICATION	 need use foreign build make and buildidentifiername work dependency results 
WITHOUT_CLASSIFICATION	 use set here because for excludes order edges irrelevant hit the cache more using set 
WITHOUT_CLASSIFICATION	 note the space the directory name intentional 
WITHOUT_CLASSIFICATION	 browsers dont understand name 
WITHOUT_CLASSIFICATION	 the cached version still current 
WITHOUT_CLASSIFICATION	 convert properties object 
WITHOUT_CLASSIFICATION	 delegate class not visible managed view type view type more general than delegate type use the delegate classloader instead 
WITHOUT_CLASSIFICATION	 module was already visited there cycle 
WITHOUT_CLASSIFICATION	 hot path create little possible 
WITHOUT_CLASSIFICATION	 these are implemented system property but dont really function like one include this system property set 
WITHOUT_CLASSIFICATION	 need 
WITHOUT_CLASSIFICATION	 theres authentication involved requests can done concurrently 
WITHOUT_CLASSIFICATION	 start preparing the result 
WITHOUT_CLASSIFICATION	 deserialize the worker action 
WITHOUT_CLASSIFICATION	 add tasks created through rules the actual task container 
WITHOUT_CLASSIFICATION	 can probably skip this 
WITHOUT_CLASSIFICATION	 split out the output into main content and post build content 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 use defensive copy the build definition may mutated during build execution 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 can get duplicate finish events 
WITHOUT_CLASSIFICATION	 this method effectively part cross gradle version contract 
WITHOUT_CLASSIFICATION	 read worker implementation classpath 
WITHOUT_CLASSIFICATION	 any logging prior this point will not end the daemon log file 
WITHOUT_CLASSIFICATION	 with normalized line endings 
WITHOUT_CLASSIFICATION	 the following values are relatively expensive create defer creation until required 
WITHOUT_CLASSIFICATION	 use java apis available otherwise fallback noop 
WITHOUT_CLASSIFICATION	 move into cache 
WITHOUT_CLASSIFICATION	 iterate and stop all daemons 
WITHOUT_CLASSIFICATION	 read header 
WITHOUT_CLASSIFICATION	 lines for buildstatus and for cursor parking space 
WITHOUT_CLASSIFICATION	 construct task selectors 
WITHOUT_CLASSIFICATION	 get the class and set the compileroptions class 
WITHOUT_CLASSIFICATION	 the task dependencies for the configuration have been calculated using 
WITHOUT_CLASSIFICATION	 consumer version provided client and later 
WITHOUT_CLASSIFICATION	 write rich content both stdout and stderr 
WITHOUT_CLASSIFICATION	 replace returns the sets the with the 
WITHOUT_CLASSIFICATION	 its rare that component would declare more than capability 
WITHOUT_CLASSIFICATION	 dont want add core classloader explicitly here 
WITHOUT_CLASSIFICATION	 the getgetter was ignored can override with the isgetter 
WITHOUT_CLASSIFICATION	 this rule just here ensure backwards compatibility for builds that create publications with model rules 
WITHOUT_CLASSIFICATION	 lock the state region with the requested mode 
WITHOUT_CLASSIFICATION	 ignore private getters without annotations 
WITHOUT_CLASSIFICATION	 discard the node can garbage collected some ant tasks cache potentially large amount state fields 
WITHOUT_CLASSIFICATION	 for each remaining level the relativeto path add 
WITHOUT_CLASSIFICATION	 ends with 
WITHOUT_CLASSIFICATION	 not part normal visitor see 
WITHOUT_CLASSIFICATION	 dont need unpack the serialized failure will already have been reported and not used anything downstream this action 
WITHOUT_CLASSIFICATION	 flushing data coming only from current appending 
WITHOUT_CLASSIFICATION	 theory this should not happen 
WITHOUT_CLASSIFICATION	 what actually exposed 
WITHOUT_CLASSIFICATION	 visible tasks are specified those that have nonempty group 
WITHOUT_CLASSIFICATION	 dont track publications repositories configured without base url 
WITHOUT_CLASSIFICATION	 groovy may inner enum defined this class itself which case does not need explicitly qualified the currentclass name 
WITHOUT_CLASSIFICATION	 append failures for locking and fail version conflict 
WITHOUT_CLASSIFICATION	 sort for determinism 
WITHOUT_CLASSIFICATION	 perform the work per repository 
WITHOUT_CLASSIFICATION	 set the antlr output directory adding javac inputs 
WITHOUT_CLASSIFICATION	 generate public return type methodclosure return method 
WITHOUT_CLASSIFICATION	 now visit the result order 
WITHOUT_CLASSIFICATION	 todo merge ioactions 
WITHOUT_CLASSIFICATION	 need filter the level child runners because the suite not doing the right thing here 
WITHOUT_CLASSIFICATION	 just ignore the exception the dir doesnt exist anymore 
WITHOUT_CLASSIFICATION	 block until the listener has finished notifying 
WITHOUT_CLASSIFICATION	 should never happen here 
WITHOUT_CLASSIFICATION	 deduplicates the include file states these are often shared between source files 
WITHOUT_CLASSIFICATION	 currently the converter stateless doesnt need any external context for performance return singleton 
WITHOUT_CLASSIFICATION	 was broken for java 
WITHOUT_CLASSIFICATION	 order dynamic selectors after static selectors 
WITHOUT_CLASSIFICATION	 callable super string 
WITHOUT_CLASSIFICATION	 read logging config and setup logging 
WITHOUT_CLASSIFICATION	 this has the downside adding playjavaforms for all kind play projects including scala based projects still users can exclude the dependency they wantneed maybe the future can enable users have some flag specify the project java scala based 
WITHOUT_CLASSIFICATION	 self close parent order discover its children its target the case reference 
WITHOUT_CLASSIFICATION	 nothing 
WITHOUT_CLASSIFICATION	 system types come from the system classloader and their classloader null 
WITHOUT_CLASSIFICATION	 there are different output properties compared the previous execution then have output changes 
WITHOUT_CLASSIFICATION	 alternatively could return would differ least the following ways live autowiring 
WITHOUT_CLASSIFICATION	 the target was invalid 
WITHOUT_CLASSIFICATION	 coerce the value the type accepted the property setter and invoke the setter directly 
WITHOUT_CLASSIFICATION	 release any other project locks might happen hold 
WITHOUT_CLASSIFICATION	 add groovytemplates for groovy 
WITHOUT_CLASSIFICATION	 the main java component 
WITHOUT_CLASSIFICATION	 are handling the root the tree here 
WITHOUT_CLASSIFICATION	 try use new label 
WITHOUT_CLASSIFICATION	 wildcards matches above 
WITHOUT_CLASSIFICATION	 have not seen this node before add its dependencies the head the queue and leave this node the queue 
WITHOUT_CLASSIFICATION	 push back remaining bytes multibyte unicode character 
WITHOUT_CLASSIFICATION	 bcpgoutputstream seems some internal buffering its unclear whether its strictly required here though 
WITHOUT_CLASSIFICATION	 logging 
WITHOUT_CLASSIFICATION	 dont know the parent will use the top suite this way always have and attach logging events for 
WITHOUT_CLASSIFICATION	 the old value better fit than the new one lets ignore the new one altogether 
WITHOUT_CLASSIFICATION	 important not add until after has been applied there can pluginswithtype callbacks waiting build what the plugin did 
WITHOUT_CLASSIFICATION	 choose the main artifact based its type 
WITHOUT_CLASSIFICATION	 type super 
WITHOUT_CLASSIFICATION	 whatever the exclude filter there are dependencies 
WITHOUT_CLASSIFICATION	 only supports java was the last release 
WITHOUT_CLASSIFICATION	 use highest version highest scope keep highest scope exclusions only 
WITHOUT_CLASSIFICATION	 new 
WITHOUT_CLASSIFICATION	 unboxing and boxing does the trick 
WITHOUT_CLASSIFICATION	 tasks graph already calculated and tasks executed action model builders can access tasks results 
WITHOUT_CLASSIFICATION	 from fork options 
WITHOUT_CLASSIFICATION	 tasks 
WITHOUT_CLASSIFICATION	 only set nonnull task list the least one task has been given this method this needed since any nonnull list even empty treated execute these tasks before building the model this would cause error when fetching the buildenvironment model 
WITHOUT_CLASSIFICATION	 overwrite property 
WITHOUT_CLASSIFICATION	 the cached class loader long the action executed 
WITHOUT_CLASSIFICATION	 defines all projections for the node initializes the node allows mutation setup default values for element mutation action provided when element defined customisations post customisation default values post mutation validations 
WITHOUT_CLASSIFICATION	 these are not null are pessimistic loaders asked for before locking 
WITHOUT_CLASSIFICATION	 not known yet 
WITHOUT_CLASSIFICATION	 todo wolfs use decorated here since idea import currently relies this see 
WITHOUT_CLASSIFICATION	 use the ansioutputstream strip out the ansi escape sequences 
WITHOUT_CLASSIFICATION	 decorating factory 
WITHOUT_CLASSIFICATION	 host 
WITHOUT_CLASSIFICATION	 exclude framework directories for gcc they are added system search paths but they are actually not 
WITHOUT_CLASSIFICATION	 todo make build type configurable for components 
WITHOUT_CLASSIFICATION	 currently leave zincscalacompiler also compile the java code 
WITHOUT_CLASSIFICATION	 dont log 
WITHOUT_CLASSIFICATION	 evicted but can still reintegrated later different path 
WITHOUT_CLASSIFICATION	 state and extendsfrom intentionally not copied must reresolve copy copying extendsfrom could mess dependencies when copy was reresolved 
WITHOUT_CLASSIFICATION	 tagtaskargmethod 
WITHOUT_CLASSIFICATION	 generate public object getpropertystring name return 
WITHOUT_CLASSIFICATION	 this method tries minimize the number volatile readwrites not try inline the variables there 
WITHOUT_CLASSIFICATION	 shouldnt happen 
WITHOUT_CLASSIFICATION	 todo configure eclipse projects too 
WITHOUT_CLASSIFICATION	 not delete parent dirs 
WITHOUT_CLASSIFICATION	 unspecified 
WITHOUT_CLASSIFICATION	 synthesise test for the broken configuration method 
WITHOUT_CLASSIFICATION	 see 
WITHOUT_CLASSIFICATION	 should provide gradle version parameter this check can more precise 
WITHOUT_CLASSIFICATION	 need work with the string version the usage attribute since this expected for all providers the schema 
WITHOUT_CLASSIFICATION	 queue this for checking again later this done because were checking what have locally cache and there may nothing were queuing back that the next time check remote access 
WITHOUT_CLASSIFICATION	 jar compatible with classes resources 
WITHOUT_CLASSIFICATION	 transform into their corresponding progress operationidentifier 
WITHOUT_CLASSIFICATION	 expect that all options must applicable for each task 
WITHOUT_CLASSIFICATION	 special validation 
WITHOUT_CLASSIFICATION	 discarded from stream 
WITHOUT_CLASSIFICATION	 the other disambiguated current never consider other again 
WITHOUT_CLASSIFICATION	 add the file name 
WITHOUT_CLASSIFICATION	 safety check dispatching message should not cause the thread dispatch another message should not any logging 
WITHOUT_CLASSIFICATION	 this logger has been replaced for example using gradleuselogger dont log anything 
WITHOUT_CLASSIFICATION	 below does not help windows environments was unable get plain javadoc utility work successfully with multiline options the options file least will work out the box linux mac environments windows the options file will have correct contents according the javadoc spec but may not work the failure will exactly the same didnt replace line breaks 
WITHOUT_CLASSIFICATION	 that logging gets its way the daemon log 
WITHOUT_CLASSIFICATION	 only functioncall argslist supported 
WITHOUT_CLASSIFICATION	 explicit flush systemerr autoflushing printwriter unless replaced 
WITHOUT_CLASSIFICATION	 dont need generate subclass 
WITHOUT_CLASSIFICATION	 note cant conclude anything the label scrolled leave the erasing the parent widget 
WITHOUT_CLASSIFICATION	 already reported 
WITHOUT_CLASSIFICATION	 generate 
WITHOUT_CLASSIFICATION	 there any other parent properties 
WITHOUT_CLASSIFICATION	 buffer full wait until has been read 
WITHOUT_CLASSIFICATION	 the same gatekeeper that opened must close 
WITHOUT_CLASSIFICATION	 write count 
WITHOUT_CLASSIFICATION	 track the closure itself not the action class 
WITHOUT_CLASSIFICATION	 this performance optimization dependency states are deduplicated 
WITHOUT_CLASSIFICATION	 rewrite the method call match closure which what the delegate will 
WITHOUT_CLASSIFICATION	 dont attach any labels 
WITHOUT_CLASSIFICATION	 have visited this nodes dependencies add the end the plan 
WITHOUT_CLASSIFICATION	 need gradle core pick ant logging adapter antbuilder and such 
WITHOUT_CLASSIFICATION	 ignore missing files 
WITHOUT_CLASSIFICATION	 dont care 
WITHOUT_CLASSIFICATION	 
WITHOUT_CLASSIFICATION	 find existing matching conflict 
WITHOUT_CLASSIFICATION	 not present assume failure details 
WITHOUT_CLASSIFICATION	 suppress checkstyle gets confused with type params the outer type 
WITHOUT_CLASSIFICATION	 commit all changes the working tree 
WITHOUT_CLASSIFICATION	 not yet supported for implicit included builds 
WITHOUT_CLASSIFICATION	 default behavior always buildable binary implementations should define what criteria make them buildable not 
WITHOUT_CLASSIFICATION	 only merge about the same capability otherwise last wins 
WITHOUT_CLASSIFICATION	 goal has previously been achieved longer required 
WITHOUT_CLASSIFICATION	 compare dynamic selectors lexicographically 
WITHOUT_CLASSIFICATION	 handle tree 
WITHOUT_CLASSIFICATION	 gettype annotation 
WITHOUT_CLASSIFICATION	 once the root build starts configuring are configuring phase 
WITHOUT_CLASSIFICATION	 discard state that longer required 
WITHOUT_CLASSIFICATION	 does not override equals but hashcode order cache the latters precomputed value improve performance when used hashmaps 
WITHOUT_CLASSIFICATION	 when this function has parameters dont need substitute parameters return the expression after macro expanding also handle calling zero args function also dont need substitute parameters 
WITHOUT_CLASSIFICATION	 use options file pass across application classpath 
WITHOUT_CLASSIFICATION	 the plugin has already been added 
WITHOUT_CLASSIFICATION	 empty rhs 
WITHOUT_CLASSIFICATION	 the event has logging header doesnt manifest console output 
WITHOUT_CLASSIFICATION	 same classes may found different classpath treesjars and keep only the first one 
WITHOUT_CLASSIFICATION	 have add these after the system properties they can override any system properties identical properties later the command line override earlier ones 
WITHOUT_CLASSIFICATION	 dont merge anything the iws yet kept the logic for the sake consistency and compatibility with pre ways configuring idea information 
WITHOUT_CLASSIFICATION	 the last comment line the timestamp 
WITHOUT_CLASSIFICATION	 dont need lock anything until use the caches 
WITHOUT_CLASSIFICATION	 handle failure 
WITHOUT_CLASSIFICATION	 detect transformation the classpath need recompile because could typically facing the case where entries are reversed the order classpath elements and one class that was shadowing the other now visible 
WITHOUT_CLASSIFICATION	 deserialize the class and parameters the workerclassloader the context classloader 
WITHOUT_CLASSIFICATION	 end workaround 
WITHOUT_CLASSIFICATION	 abortall set also stop enforced tasks 
WITHOUT_CLASSIFICATION	 dont map 
WITHOUT_CLASSIFICATION	 ignore for now 
WITHOUT_CLASSIFICATION	 delivery was interrupted return silently 
WITHOUT_CLASSIFICATION	 nothing special check for ucrt 
WITHOUT_CLASSIFICATION	 have conflict 
WITHOUT_CLASSIFICATION	 have not visited the successor node add the queue for visiting 
WITHOUT_CLASSIFICATION	 build events 
WITHOUT_CLASSIFICATION	 would normally log level higher than equal lifecycle but the ant message priority actually lower than the set lifecycle log level 
WITHOUT_CLASSIFICATION	 need parameter substitution return the value the expression after parameter substitutions and macro expanding the result 
WITHOUT_CLASSIFICATION	 prefer selector that strictly matches the selected version 
WITHOUT_CLASSIFICATION	 cached resolved executables 
WITHOUT_CLASSIFICATION	 buffer was still full after nonblocking retries now block 
WITHOUT_CLASSIFICATION	 capture log all failures 
WITHOUT_CLASSIFICATION	 authstate has been established and this put post request add preemptive authorisation 
WITHOUT_CLASSIFICATION	 consumer didnt express any preferences everything fits 
WITHOUT_CLASSIFICATION	 catch any unchecked exceptions and add the file path for troubleshooting 
WITHOUT_CLASSIFICATION	 historic note this class still uses the groovy jsonbuilder was originally developed groovy class 
WITHOUT_CLASSIFICATION	 create client that will not match any existing daemons will always startup new one 
WITHOUT_CLASSIFICATION	 try the owner 
WITHOUT_CLASSIFICATION	 includes trailing 
WITHOUT_CLASSIFICATION	 only share artifactset the artifacts are not filtered the dependency 
WITHOUT_CLASSIFICATION	 make sure hash codes are serializable with single byte length 
WITHOUT_CLASSIFICATION	 the first directory the one created used the default output directory for processed resources 
WITHOUT_CLASSIFICATION	 for tests default method interface might not able get the implementation class directly this case need retrieve test plan get the real implementation class 
WITHOUT_CLASSIFICATION	 just read the state region 
WITHOUT_CLASSIFICATION	 the value true output file false parent output file 
WITHOUT_CLASSIFICATION	 matches task identifier taskidentifier 
WITHOUT_CLASSIFICATION	 hackery 
