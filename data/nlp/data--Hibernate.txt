SATD	 use count the default this mimics the old behavior although none might better option moving forward the case callable 
SATD	 perhaps not really necessary 
SATD	 todo what else here 
SATD	 todo disable batch loading lockmode read 
SATD	 todo handle concurrent writes correctly the client should pass lock 
SATD	 turn hibernatecp into gets chance see all hibernatecp 
SATD	 note there wierd implementation the client side 
SATD	 todo this was added support initializing entitys entityentry snapshot during reattach this should refactored instead expose method assemble entityentry based this state for return 
SATD	 need drop constraints before dropping tables this dialect 
SATD	 fixme per the regionfactory class javadoc this constructor version should not necessary param props the configuration properties 
SATD	 does this dialect support check constraints 
SATD	 this called sessionfactory irregardless just disregard here could also add check sessionfactory only conditionally call start 
SATD	 does this dialect support the unique column syntax 
SATD	 this done here cos might only know the type here ugly todo improve this lot 
SATD	 does this dialect support the for update syntax 
SATD	 todo what the implication this 
SATD	 todo yuck 
SATD	 todo again how should this work for nonpojo entities 
SATD	 does this dialect support for update allowing particular rows locked 
SATD	 todo really bad evil hack fix 
SATD	 aliasrefnoderesolve false false aliasrefnodegettext todo kosher here todo kosher here 
SATD	 todo better degrade lazyfalse uninstrumented 
SATD	 does this dialect support the oraclestyle for update nowait syntax 
SATD	 icky workaround for mysql bug 
SATD	 have set the table later yuck 
SATD	 todo somehow add the newly created foreign keys the internal collection 
SATD	 this inner class implements case statementperhaps being bit overclever here 
SATD	 todo merge into one method 
SATD	 todo this bit copypaste from 
SATD	 todo what type 
SATD	 todo inefficient 
SATD	 fixme get the persistentclass 
SATD	 todo can remove this once the deprecated ctor can made private 
SATD	 todo this too conservative all preceding joins were also inner joins could use inner join here 
SATD	 todo redesign how propertyaccessors are acquired 
SATD	 todo not sure this needed 
SATD	 create index the key columns 
SATD	 todo joinkeycolumnname should called either here slightly higer level the stack get all the information need right now hbmbinder does not support the 
SATD	 todo improve this hack 
SATD	 todo bad implementation cos depends upon ordering mapping doc fixing this requires that gain access the mappings reference from configuration the filterdefinitions map directly sometime during after all the typesfilterdefs are known and before building persisters 
SATD	 use trim here ugly 
SATD	 todo ideally need the construction propertyaccessor take the following entitymode entitymodespecific data the classname for pojo entities propertyspecific data based the entitymode propertyname domjnodename the easiest way with the introduction the new runtimemetamodel classes would the the following predicates takes references both and what now termed propertyaccessor stores any values needed from those two pieces information code can then simply call with parameters likewise with 
SATD	 can happen because the multiple ways cacheremove can invoked 
SATD	 ick 
SATD	 todo this very suboptimal for some subclasses namely components since does not take advantage twophaseload 
SATD	 todo should this 
SATD	 todo suck this into initlaziness 
SATD	 temporary magic value the need for intended alleviated with future developement thus not defined environment constant used control whether should consult the jdbc metadata determine certain settings default values useful not this when the database may not available mainly tools usage 
SATD	 todo this right 
SATD	 the subquery yuck 
SATD	 use stringbuffer workaround jdk bug 
SATD	 todo copypaste from recreate 
SATD	 workaround for backward compatibility sets with notnull columns assume all columns are used the row locator sql 
SATD	 todo this eventually needs removed 
SATD	 todo remove 
SATD	 just help out during the load ugly know 
SATD	 hackworkaround sqlquery impl depend having key 
SATD	 todo handle the case foreign key something other than the 
SATD	 todo assumes all collections disassemble array 
SATD	 todo would love have this work notification basis where the successful binding entitysubclass would emit notification which the extendsqueue entries could react 
SATD	 todo really neceassry provide configuration should not enough with associated class why does entitypersisters not get access configuration the only reason could see that configuration gets passed collection persisters that they can look the domj node name the entity element case explicit node name was applied the collection element level are you kidding trivial fix then just store and expose the node name the entity persister which the collection persister looks anyway via other means 
SATD	 todo deprecated remove eventually 
SATD	 todo possibly relax that 
SATD	 todo this bit dodgy come with better way check this plus see above comment 
SATD	 use degenerated strategy for backward compatibility 
SATD	 todo this temporary that the end result will probably not take property reference perse 
SATD	 todo better handle dynamic filters through implicit see the discussion there javadocs why currently not done that way 
SATD	 get the right object from the list would easier just call getentity 
SATD	 todo should record how many properties have reffered and dont getemall throw exception way better than trial and error 
SATD	 todo this dependency kinda bad 
SATD	 todo get sql rendering out this package 
SATD	 why does this matter 
SATD	 important account for newly saved entities query todo some kind check for new status 
SATD	 todo can always use the null property approach for everything 
SATD	 does this need holdlock also return tablename with updlock rowlock holdlock 
SATD	 for sets should end the collection load after resolving the entities since might call hashcode the elements todo could this polymorphically and have two different operations implemented differently for arrays 
SATD	 todo remove this and just have subclasses use directly 
SATD	 sqlserver least needed this dropped after use strange 
SATD	 necessary register exact since can only appear where clause 
SATD	 for arrays should end the collection load before resolving the entities since the actual array instances are not instantiated during loading todo could this polymorphically and have two different operations implemented differently for arrays 
SATD	 does this dialect support the alter table syntax 
SATD	 this next bit allow for both and for older behavior where version number did not get seeded was already set the object todo shift into unsavedvalue strategy 
SATD	 todo reenable also fix the above todo 
SATD	 orphans should not deleted during copy 
SATD	 orphans should not deleted during merge 
SATD	 todo suck this logic into the collection 
SATD	 todo can actually just determine this from the incoming entityentrys 
SATD	 todo this bit actually has called after all cascades but since identity insert called synchronously instead asynchronously other actions isnt 
SATD	 this class has proxies shortcut 
SATD	 todo should this watch out for performance 
SATD	 todo need map the prob proper key right 
SATD	 todo better pass the argument 
SATD	 even really need this the update will fail anyway 
SATD	 todo would better refresh from 
SATD	 this form used from annotations essentially the same the above using resultsetmapping reference but without cachemode readonly and comment fixme annotations not use can remove from pov deprecated param query the sql query string param resultsetref the resultsetmapping name param queryspaces any specified query spaces used for autoflushing param cacheable whether the query results are cacheable param cacheregion cacheable the region into which store the results param timeout jdbclevel timeout applied param fetchsize jdbclevel fetchsize applied param flushmode the flush mode use for this query param parametertypes parameter type map param callable does the query string represent callable object proc 
SATD	 todo ugly here 
SATD	 todo not quite sure about the full implications this 
SATD	 this only works because collection entries are kept sequenced map persistence context maybe should like entities and keep separate sequences set todo calling entryset identitymap slow 
SATD	 todo much rather have this done from 
SATD	 todo hack note here cleanup the load context when have more local lce entries this works for the time being because really only the collection load contexts are implemented long term this cleanup should become part the close result set processing from the sandboxjdbc jdbccontainer code 
SATD	 todo add the notion enabled filters the cachekey differentiate filtered collections from nonfiltered but cachekey currently used for both collections and entities would ideally need define two seperate ones currently this works conjuction with the check which makes sure not read from cache with enabled filters early exit 
SATD	 postload needed for ejb todo reuse the postloadevent 
SATD	 todo should check the current isolation mode explicitly 
SATD	 brand new collection todo array cant lock objects with arrays now 
SATD	 todo iteratively get transient entities and retry merge until one the following conditions not decreasing and copycachesize not increasing todo find out retrying can add entities copycache dont think can for now just retry once throw there are still any transient entities 
SATD	 null brand new collection this will also inefficiently handle arrays which have snapshot cant any better 
SATD	 todo perhaps should additionally require that the incoming entity version equivalent the defined unsavedvalue 
SATD	 provides query splitting methods which were originally querytranslator todo this will need refactored some point author josh 
SATD	 todo most below was taken verbatim from dotnode should either delegate this logic supertype 
SATD	 todo currently expects that the individual with expressions apply the same sql table join this may not the case for joinedsubclass where the property values might coming from different tables the joined hierarchy some point should expand this support that capability however that has some difficulties the biggest how handle ors when the individual comparisons are linked different sql joins here would need track each comparison individually along with the join alias which applies and then pass that information back the fromelement can pass along the joinsequence 
SATD	 explicit select expression render the and properties projection lists for every persister the from clause into single token node todo the only reason need this stuff now collection filters should get rid derived select clause completely 
SATD	 todo better way 
SATD	 hack alert attempt work around ghost impliedfromelements that occasionally show between the actual things being joined this consistently occurs from index nodes least against manytomany not sure there are other conditions essentially lookahead the next fromelement that actually writes something the sql 
SATD	 not possible simply reuse the versionpropertynode here causes oom errors due circularity 
SATD	 this function has template restore output apply the template and write the result out todo downcast avoid using interface yuck 
SATD	 some point the generate phase needs moved out here because single objectlevel dml might spawn multiple sql dml command executions possible just move the sql generation for dml stuff but for consistencysake probably best just move responsiblity for the generation phase completely into the delegates themselves also not sure why queryloader currently even has dependency this all does need ideally like see the walker itself given the delegates directly 
SATD	 todothis only needed during compilation can eliminate the instvar 
SATD	 todo absolutely usages this constructor form can away 
SATD	 todo this bit ugly 
SATD	 even here only properties mapped the base table are referenced the set and where clauses this could handled the basicdelegate todo decide better performancewise perform that check simply use the 
SATD	 todo remove these last two batcher longer managing connections 
SATD	 very important this class needs free any static references any cglib javassist classes otherwise users will always need both their classpaths matter which either they use another option here would remove the method and have the users through the sessionfactory get this information 
SATD	 todo really need able deal with component paths here also this difficult because the hqlsql grammar expects all those node types fromreferencenodes one potential fix here would convert the intoclause just use combo child the insertstatement and move all this logic into the insertstatement thats probably the easiest approach read least amount changes the grammar and code but just doesnt feel right then insert would contain fromclauses 
SATD	 todo optimization here would consider cascade deletes and not gen those delete statements the difficulty the ordering the tables here the cascade attributes the persisters the table info gotten here should really selfcontained class representation defining all the needed attributes then could then get array those 
SATD	 todo switch statements are always evil already had bugs because forgotten token types use polymorphism for this 
SATD	 really there are two situations where should allow the insertion into properties defined superclass unionsubclass with abstract root entity discrimsubclass handled already because the fact that alreay always returns for this call may want disallow for discrimsubclass just for consistencysake currently does not work anyway 
SATD	 implicit joins are always reuse 
SATD	 todo used exprnoparens was this needed 
SATD	 todo may also want check that the types here map exactly one columnjdbctype cant think situation where arithmetic expression between multicolumn mappings makes any sense 
SATD	 not know either type blind guess 
SATD	 todo get sql rendering out here create ast for the join expressions use the sql generator grammar generate the sql text for the index expression 
SATD	 would probably refactor have logicparser builds tree simple expressions connected and not expressionparser translates from terms like foo foobar foobarbaz sql terms like foosid foosbarid etc and which does much the same thing does now 
SATD	 shortcircuit for performance 
SATD	 not absolutely necessary but does help with aggressive release 
SATD	 try block hack around fact that currently tuplizers are not given the opportunity resolve subclass entity name this allows the assume custom interceptor the ability influence this decision were not able based the given entityname 
SATD	 todo this one the ugliest and most fragile pieces code hibernate 
SATD	 todo implement functionality this might painful here the join post processing for the subquery has already been performed meaning that for thetajoin dialects the join conditions have already been moved over the where clause simple solution here might perform join post processing once for the entire query including any subqueries one fell swoop 
SATD	 yuck 
SATD	 ignore the incoming property could not found cannot sure what here the very least the safest simply not apply any dereference toggling 
SATD	 todo make this bit nicer 
SATD	 yuck 
SATD	 todo potentially look optimizing these two arrays 
SATD	 note that parameter now unused delete 
SATD	 todo figure out better way get the from elements proper tree structure this not the destination manytomany add child the origin 
SATD	 todo this constructor form only used from constructor directly below can away 
SATD	 should reengineer this class that rather than the current hoc linear approach processing stream tokens instead build tree expressions 
SATD	 todo should this get moved persistentcontext logically persistentcontext the thing which interceptor gets attached 
SATD	 todo something much better look the type the other expression todo have andor rules complete the resolution boolean nodes 
SATD	 todo this class does too many things need different kind path expression parser for each the diffferent ways which path expressions can occur 
SATD	 todo optimize this better 
SATD	 todo should allow suffixes these 
SATD	 todo this really necessary 
SATD	 todo not sure the best way handle this the nonperformant way 
SATD	 todo there better way 
SATD	 the class now way complex 
SATD	 todo would really nice cache the spec the querydef not have recalc the hash currently not doable though because the resultsetref stuff 
SATD	 name from super query bit inelegant that shows here 
SATD	 real hacky used count the nesting parentheses 
SATD	 put has nowait semantics this really appropriate note that needs async replication never local sync 
SATD	 ugly hack for cases like multipart path expression ending elements indices 
SATD	 fixme hacky workaround jbcache 
SATD	 todo copypaste from sessionimpl pull 
SATD	 todo need find clean way handle the event source role seperate classs responsible for events just duplicates most the session methods passing around seperate reto interceptor factory actionqueue and persistentcontext not manageable 
SATD	 must done here because sideeffect yuck 
SATD	 should actually rework this class not implement parser and just process path expressions the most convenient way 
SATD	 todo should remove this exposure and have all references the sessions batcher use the connectionmanager 
SATD	 may screwed here since the collection action about execute and not know the final owner key value 
SATD	 needed the clazz check work around unionsubclasses todo there way tell whether persister truly discrimcolumn based inheritence 
SATD	 work around bug all known connection pools 
SATD	 todo reuse the preloadevent 
SATD	 need better way define the suffixes here 
SATD	 workaround for weblogic 
SATD	 todo temporary 
SATD	 todo yuck fix after hhh complete 
SATD	 would great move all this below here into another method that could also used from the new scrolling stuff would need change the way the maxrow stuff handled behind interface that could the control breaking the means know when stop 
SATD	 todo the ientityspan bit depends upon subclass implementation very bad 
SATD	 some messy complex stuff here since createcriteria can take aliased path path rooted the creating criteria instance 
SATD	 todo add criteriaimplementor interface this class depends directly upon criteriaimpl the impl package 
SATD	 polymorphism not really handled completely correctly perhapswell actually its assuming that the entity name used the lookup the same the the one used here which will 
SATD	 this not very nice and quite slow 
SATD	 todo get sql rendering out here 
SATD	 meant handle dynamic instantiation queriescopy from queryloader 
SATD	 make sure this defined parameter and check the incoming value type todo what should the actual exception type here 
SATD	 worrying about proxies perhaps little bit overkill here 
SATD	 todo throw exception maybe warn not the same 
SATD	 todo make entitypersister not depend interface possible 
SATD	 todo what amount significant digits need supported here from the decimalformat docs significant digits minimum integer digits maximum fraction digits 
SATD	 for backward compatibility allow set with notnull element columns using all columns the row locater sql todo create implicit not null constraint all cols 
SATD	 todo copypaste from manytoonetype 
SATD	 todo code duplication with 
SATD	 todo throw exception 
SATD	 should this interface extend propertymapping 
SATD	 todo here why need make bytecode provider global todo again fix this after hhh complete 
SATD	 todo currently keeps getters and setters instead propertyaccessors because the way getgetter and getsetter are implemented currently yuck 
SATD	 todo yuck this not quite good enough its quick hack around the problem having toone association that refers embedded component 
SATD	 todo implement caching proxies 
SATD	 this really necessary 
SATD	 todo this little inefficient dont need whole deep replaceelements call 
SATD	 todo this bit arbitrary expose switch the user 
SATD	 return collection removal fixme even isinversetrue 
SATD	 todo fix this will work for nonpojo entity mode 
SATD	 todo move these new joinabletype abstract class extended entitytype and 
SATD	 todo would nice handle proxy classes elegantly 
SATD	 spaces todo not sure but perhaps should exclude abstract denormalized tables 
SATD	 todo there more elegant way than downcasting 
SATD	 todo remove use instanceof 
SATD	 todo perhaps this should some other runtimeexception 
SATD	 yuck 
SATD	 todo need some caching scheme really comes down decision regarding amount state any kept propertyaccessors 
SATD	 todo design new lifecycle for proxyfactory 
SATD	 todo should really just collect these from the various selectexpressions rather than regenerating here 
SATD	 todo should this really return null not figure out something better here 
SATD	 todo should seriously consider not allowing txn begin from child session can always route the request the root session 
SATD	 should indicate that are processing insertupdatedelete query with subquery implied via collection property function here need use the table name itself the qualification alias todo verify this works for all databases todo this also the case nonindexed scenarios 
SATD	 todo this really needs delayed unitl after definitively know all node types where this currently problem parameters for which where cannot unequivocally resolve expected type 
SATD	 todo make this the factory for entity mode related sessions also means making this the target transactionsynch and the thing that knows how cascade things between related sessions that point perhaps this thing sessioncontext and connectionmanager jdbccontext sessioncontext should live the impl package 
SATD	 create index the key columns 
SATD	 this 
SATD	 init the table here instead earlier that can get quoted table name todo would better simply pass the qualified table name instead splitting into schemacatalogtable names 
SATD	 perhaps this should exception since only ever used the above method 
SATD	 note this assumes something about how implemented the subclass was before now tried remove that unqoting and missing aliases 
SATD	 put placeholder entries dont recurse back and try save the same object again question should this done before onsave called likewise should done before onupdate 
SATD	 before cascade todo should this 
SATD	 todo should throw exception really know for sure that this detached instance rather than just assuming throw new 
SATD	 todo the order which entities are saved may matter particular transient entity may need saved before other transient entities can saved keep retrying the batch transient entities until either there are transient entities left transientcopycache transient entities were saved the last batch for now just run through the transient entities and retry the merge 
SATD	 todo object was uninitialized proxy this inefficient resulting two sql selects 
SATD	 todo put this stuff back read snapshot from the secondlevel cache needs some extra work 
SATD	 this kinda the best can 
SATD	 trim done workaround stupid oracle bug that cant handle whitespaces before 
SATD	 todo this neednt exclude subclasses 
SATD	 todo use two visitors here inefficient 
SATD	 todo does this really need here does the collection already have its own uptodate snapshot 
SATD	 otherwise trimspecification andor trimcharacter have been specified need decide which options are present and the right thing should leading trimcharacters trimmed should trailing trimcharacters trimmed the trimcharacter the trimsource 
SATD	 possible that the treewalking outerjoinloader can get association defined subclass which case the propertyref might refer property defined subclass the current class this case the table name not known this temporary solution assumes that the propertyref refers property the subclass table that the association belongs reasonable guess todo fix this add propertyname 
SATD	 todo alternative check the owner has changed hasnt then return collectiongetowner 
SATD	 suppose 
SATD	 tbd should this varbinary binary 
SATD	 shortcut 
SATD	 todo should provide some way get keys collection statistics make easier retrieve from gui perspective 
SATD	 todo probably better calculate these and pass them itll more performant 
SATD	 todo should additionally check the current isolation mode explicitly 
SATD	 todo simply remove this override fix the above todos 
SATD	 todo there really any reason kkeep trying this fails once 
SATD	 todo not sure this correct could not find docs how this 
SATD	 hsql has blobclob support but just put these here for now 
SATD	 merges dont cascade uninitialized collections todo perhaps this does need cascade after all 
SATD	 yick need this for proper handling 
SATD	 todo should orphans really deleted during lock 
SATD	 todo move stringhelper 
SATD	 sets can just view part another collection need copy sure wont changing underneath thissetaddallset 
SATD	 todo would really really nice use this also model components 
SATD	 todo move sql package 
SATD	 todo look the owning property and check that isnt lazy instrumentation 
SATD	 todo add this info the translator and aggregate here 
SATD	 would better use the elementtype determine whether the old and the new are equal here the problem being not necessarily have access the element type all cases 
SATD	 todo code duplication with 
SATD	 todo refactor sql package 
SATD	 todo two hashmap lookups here one too many 
SATD	 note that this method could easily moved ever needed reuse from other subclasses 
SATD	 from the collection associations locate oja for the manytoone corresponding this persister fully define the manytomany need that oja that can use its alias here todo there better way here 
SATD	 todo this class depends directly upon criteriaimpl the impl package add criteriaimplementor interface 
SATD	 need qualify index names with the schema name 
SATD	 todo probably should have make clean 
SATD	 yukky dont you have subclasses for that todo race conditions can happen here 
SATD	 note very hackish workaround todo fix this will work for nonpojo entity mode 
SATD	 todo need make the majority this functionality into toplevel support class for custom impl support 
SATD	 for domj collections only todo would better this was done the higher level printer 
SATD	 todo inefficient that cache just going ignore the updated state 
SATD	 todo alternative check the owner has changed hasnt then get the from collectiongetowner 
SATD	 todorefactor make this method private 
SATD	 todo keep seperate notions here for shallownonshallow queries 
SATD	 todo temporary needed because currently persister the one that creates and renders the join fragments for inheritence hierarchies 
SATD	 this called sessionfactory irregardless just disregard here could also add check sessionfactory only conditionally call stop 
SATD	 swaldman modify allow null values signify fall through poolconfig defaults 
SATD	 work around that crazy issue where the tree contains empty fromelements text afaict this caused 
SATD	 kinda ugly but needed for collections with node mapping 
SATD	 todo would great have method dont believe that accounts for the identifier property returns for property named then should have nonid field named 
SATD	 entity name will not available for nonpojo entities todo cache the entity name somewhere that available this exception 
SATD	 index todo this kinda slow 
SATD	 todo move sql package and refactor with similar things 
SATD	 todo not sure about the exception handling this bit 
SATD	 ugly little workaround for fact that does not handle component properties 
SATD	 append the sql return the generated identifier todo suck into insert 
SATD	 this really ugly but necessary 
SATD	 todo modify the class definition not already transformed 
SATD	 todo should use select for update 
SATD	 create action that will evict collection and entity regions based queryspaces table names todo cache the autodetected information and pass instead 
SATD	 todo this correct 
SATD	 used only for regression testing todo obviously get rid all this junk 
SATD	 note this assumes something about how implemented the subclass was before now tried remove that unqoting and missing aliases 
SATD	 todo move into collection type can use polymorphism 
SATD	 todo should just collect these like with the collections above 
SATD	 todo should really move this log statement collectiontype where this used from 
SATD	 hum should cascade anyway throw exception fine like 
SATD	 todo this might really even moved into the cfg package and used the basis for all things which are configurable 
SATD	 todo copypaste from insertrows 
SATD	 todo suck into event class 
SATD	 todo never reached since gettypename actually throws exception 
SATD	 this used sessionfactoryimpl hand the generated sessionimpl was the only reason could see that cannot just use null 
SATD	 xmlforest requires new kind function constructor 
SATD	 todo this valid operation timestamps cache 
SATD	 todo considered validating the presence the cache here but decided defer unti case the cache never actually used 
SATD	 todo why not use the timestamp dataversion 
SATD	 todo eventually merge this with treecache and just add optional optlock support there 
SATD	 work around the feature where tree cache validating the inserted node during the next transaction idea 
SATD	 todo considered validating cache config here but decided defer unti case the cache never actually used 
SATD	 need that here rather than the save event listener let the post insert events have idfilled entity when identity used ejb 
SATD	 unhappy about this being public there better way 
SATD	 todo safe interpret mapremovekey null nondirty 
SATD	 fixme hack work around fact that calling node added rootaddchild fqn doesnt properly set the version the node 
SATD	 work around the feature where tree cache validating the inserted node during the next transaction idea 
SATD	 todo replace this with more elegant solution 
SATD	 short cut check 
SATD	 todo handle concurrent writes correctly this should return lock the client 
SATD	 this ugly here but needed because its subquery 
SATD	 todo will need reference session factory fully complete hhh 
SATD	 inheritance cycle detection paranoid check 
SATD	 todo encapsulate the protected instance variables 
SATD	 polymorphism comment above 
SATD	 add entry for this type entity can assured that all referenced entities have already been processed specify that this entity with the latest batch doing the batch number before adding the name the list faster way get accurate number 
SATD	 todo handle typedefs 
SATD	 todo get all properties not just the fetched ones 
SATD	 todo native ids 
SATD	 todo returnelem 
SATD	 todo handle propertyref 
SATD	 todo validate existing property with the chosen name secondpass 
SATD	 todo check that 
SATD	 todo restrict violation 
SATD	 todo assertion only could optimized away 
SATD	 todo lowercasing done here was done random before maybe not needed all 
SATD	 todo optimize away this lookup for entities 
SATD	 todo tolowercase was not done before only used template 
SATD	 todo arithmetic expressions multiple new foo 
SATD	 todo not visible the user 
SATD	 todo proxies 
SATD	 todo can limit stored procedures 
SATD	 todo formulas 
SATD	 todo better error message since actually support composites names are explicitly listed 
SATD	 todo use these methods above 
SATD	 todo cache the persister this shows yourkit 
SATD	 todo add referencedclass disambiguate fks the same columns pointing different tables 
SATD	 todo create loaders for component properties 
SATD	 todo still need make entitymodeaware 
SATD	 todo terrible implementation 
SATD	 todo eventually put this back once think all fixed object otheralias columnalias 
SATD	 todo dont really like this implementation would better this was handled 
SATD	 todo check key contains the owner 
SATD	 todo cache this instvar 
SATD	 todo temporary initial step towards hhh 
SATD	 todo remove this once componentmetamodel complete and merged 
SATD	 todo add owner argument 
SATD	 todo handle but such case does not exist the wild far 
SATD	 todo for some dialects would appropriate add the other select strings 
SATD	 todo unnecessary for databases with ansistyle joins 
SATD	 todo maybe call getrowselection 
SATD	 todo make this handle multiple collection roles 
SATD	 todo include the rowids 
SATD	 are still not resolved might represent constant needed add this here because the allowance nakedproprefs the grammar collides with the definition literalsconstants nondeterminism todo cleanup the grammar that processconstants always just handled from here 
SATD	 todo should return containstablealias 
SATD	 todo look perhaps caching this 
SATD	 todo avoid this for nonnew instances where mightbedirtyfalse 
SATD	 todo theoretically nonthreadsafe 
SATD	 todo look optimizing these 
SATD	 todo cache this sql 
SATD	 todo check mimer sql cannot handle the way does 
SATD	 todo are using identity columns fetch the identifier 
SATD	 todo check there actual definition elemnents when ref defined 
SATD	 tablenull association fill later todo fill the mappings for table null 
SATD	 tablenull association fill later todo fill the mappings for table null 
SATD	 todo add support for readwrite nonstrictreadwrite 
SATD	 todo return new lockts 
SATD	 todo why arent these the same 
SATD	 todo support multiple fetch groups would need clone the set lazy properties 
SATD	 todo 
SATD	 todo 
SATD	 todo always true for now but not later decide support elements the from clause 
SATD	 could move this inside wanted tolerate collection initializations during collection dirty checking 
WITHOUT_CLASSIFICATION	 see the user configured multiplexer stack 
WITHOUT_CLASSIFICATION	 root entity comes last 
WITHOUT_CLASSIFICATION	 elementtype 
WITHOUT_CLASSIFICATION	 scan the query string for class names appearing the from clause and replace with all persistent implementors the classinterface returning multiple query strings make sure dont pick class the select clause 
WITHOUT_CLASSIFICATION	 identifier collections not supported for tomany 
WITHOUT_CLASSIFICATION	 assumes that trimspecification has been specified handle the exception that explicitly 
WITHOUT_CLASSIFICATION	 overridden informational metadata 
WITHOUT_CLASSIFICATION	 the current depth the root thing being loaded the manytomany collection itself here alright use inner join 
WITHOUT_CLASSIFICATION	 update removed rows fks null 
WITHOUT_CLASSIFICATION	 registerfunction trim new standardsqlfunction trim hibernatestring 
WITHOUT_CLASSIFICATION	 bufappend selectfragment lhsalias ignore suffix for collection columns 
WITHOUT_CLASSIFICATION	 initialize the set queried identifier spaces tables 
WITHOUT_CLASSIFICATION	 use suffix for the entity columns 
WITHOUT_CLASSIFICATION	 got here because assumed that instance with assigned was detached when was really persistent 
WITHOUT_CLASSIFICATION	 the class hierarchy structure 
WITHOUT_CLASSIFICATION	 remove the current element from insertions will added back later 
WITHOUT_CLASSIFICATION	 private final string roottablename 
WITHOUT_CLASSIFICATION	 note this being used from the process shutting down sessionfactory specific things consider this clearing the region should not propagate other nodes the cluster any this the cachemodelocal option bit really just trying best effort cleanup after ourselves lock failures etc are not critical here this the failsilently option bit 
WITHOUT_CLASSIFICATION	 initialization 
WITHOUT_CLASSIFICATION	 stuff that persistercentric andor entityinfocentric 
WITHOUT_CLASSIFICATION	 not null start with implicit 
WITHOUT_CLASSIFICATION	 continue loop 
WITHOUT_CLASSIFICATION	 return existing object initialized proxy unless deleted 
WITHOUT_CLASSIFICATION	 the list entity names that indicate the batch number 
WITHOUT_CLASSIFICATION	 disassembled state gets put new array write cache value 
WITHOUT_CLASSIFICATION	 add these directly the executions queue 
WITHOUT_CLASSIFICATION	 execute the sql 
WITHOUT_CLASSIFICATION	 sort the updates 
WITHOUT_CLASSIFICATION	 this could also just true all the time 
WITHOUT_CLASSIFICATION	 the mapping entity names their latest batch numbers 
WITHOUT_CLASSIFICATION	 chop the last union all 
WITHOUT_CLASSIFICATION	 note that for sequential scrolling make the assumption that the first persister element the root entity 
WITHOUT_CLASSIFICATION	 todo check this 
WITHOUT_CLASSIFICATION	 for deprecated saveorupdatecopy 
WITHOUT_CLASSIFICATION	 check constraint violation unique index primary key violation 
WITHOUT_CLASSIFICATION	 the closure all properties the entire hierarchy including subclasses and superclasses this class 
WITHOUT_CLASSIFICATION	 deliberately excluded 
WITHOUT_CLASSIFICATION	 subclass discrimination works assigning particular values certain combinations null primary key values the outer join using sql case 
WITHOUT_CLASSIFICATION	 tokens that close sub expression tokens that open sub expression tokens that would indicate sub expression boolean expression 
WITHOUT_CLASSIFICATION	 multiparam numeric dialect functions 
WITHOUT_CLASSIFICATION	 use theta style for regression move the node after the origin node 
WITHOUT_CLASSIFICATION	 multiparam date dialect functions 
WITHOUT_CLASSIFICATION	 add the main query 
WITHOUT_CLASSIFICATION	 sqlexception support 
WITHOUT_CLASSIFICATION	 add the restriction the outer select 
WITHOUT_CLASSIFICATION	 bitlength feels bit broken have cast char order pass when numeric value supplied but course the answers given will wildly different for these two datatypes will bytes char string but will bytes true numeric jay nance 
WITHOUT_CLASSIFICATION	 this assumes you will want ignore any update counts 
WITHOUT_CLASSIFICATION	 skip the from keyword params 
WITHOUT_CLASSIFICATION	 custom sql 
WITHOUT_CLASSIFICATION	 return newly loaded object 
WITHOUT_CLASSIFICATION	 make circularreference safe 
WITHOUT_CLASSIFICATION	 cope with special cases and not 
WITHOUT_CLASSIFICATION	 subclass closure properties 
WITHOUT_CLASSIFICATION	 for dialects which are known not support ansisql rowvalueconstructor syntax should mutate the tree 
WITHOUT_CLASSIFICATION	 have the form trimfrom trimsource this functionally equivalent trimtrimsource early exit 
WITHOUT_CLASSIFICATION	 subclasses 
WITHOUT_CLASSIFICATION	 need hydrate 
WITHOUT_CLASSIFICATION	 starts with implicitly 
WITHOUT_CLASSIFICATION	 instantiate new instance 
WITHOUT_CLASSIFICATION	 simple nullability constraint 
WITHOUT_CLASSIFICATION	 need upgrade the lock mode the mode requested 
WITHOUT_CLASSIFICATION	 register the type the out param oracle specific type 
WITHOUT_CLASSIFICATION	 look for proxy 
WITHOUT_CLASSIFICATION	 features which change between and 
WITHOUT_CLASSIFICATION	 evicts dont cascade uninitialized collections 
WITHOUT_CLASSIFICATION	 features which remain constant across and 
WITHOUT_CLASSIFICATION	 need treat this where optimisticlockall dirty does not make sense first need locate the loaded state note potentially could proxy perform the location the safe way 
WITHOUT_CLASSIFICATION	 column getname 
WITHOUT_CLASSIFICATION	 might happen with managed connection 
WITHOUT_CLASSIFICATION	 dont need subclass tables because they cant appear conditions 
WITHOUT_CLASSIFICATION	 not finalstatic avoid possible classcast exceptions using different oracle drivers 
WITHOUT_CLASSIFICATION	 make certain that this called before any subsequent 
WITHOUT_CLASSIFICATION	 private list aliases new arraylist 
WITHOUT_CLASSIFICATION	 the reason for this sql doesnt let you sort expression you are not returning the result set 
WITHOUT_CLASSIFICATION	 register resolvers set via environment property 
WITHOUT_CLASSIFICATION	 existing collection that was either nonempty uninitialized replaced null different collection the collection uninitialized hibernate has way knowing the collection actually empty without querying the 
WITHOUT_CLASSIFICATION	 update all the modified entries 
WITHOUT_CLASSIFICATION	 special case where need force incloude all subclass joins 
WITHOUT_CLASSIFICATION	 did not find collection element the result set ensure that collection created with the owners identifier since what have empty collection 
WITHOUT_CLASSIFICATION	 binary stream character stream 
WITHOUT_CLASSIFICATION	 nobatch 
WITHOUT_CLASSIFICATION	 assumes that types are all span 
WITHOUT_CLASSIFICATION	 hibernate impelemnts cast dialectjava 
WITHOUT_CLASSIFICATION	 this the root versioned table and are using versionbased optimistic locking are not updating the version also dont check unless this generated version column 
WITHOUT_CLASSIFICATION	 aggregate functions shouldnt registered right registerfunction list new stopped list 
WITHOUT_CLASSIFICATION	 its the given optional object 
WITHOUT_CLASSIFICATION	 decide which resultset get the property value from 
WITHOUT_CLASSIFICATION	 properties this class including inherited properties 
WITHOUT_CLASSIFICATION	 otherwise assume the parent the the criteria that created 
WITHOUT_CLASSIFICATION	 the closure all columns used the entire hierarchy including subclasses and superclasses this class 
WITHOUT_CLASSIFICATION	 can straight the first required row 
WITHOUT_CLASSIFICATION	 now look the object are really interested this lets correctly handle proxies and multirow multicolumn queries 
WITHOUT_CLASSIFICATION	 before adding collection 
WITHOUT_CLASSIFICATION	 discriminator column 
WITHOUT_CLASSIFICATION	 code handle subclasses topclass 
WITHOUT_CLASSIFICATION	 none because its the requested lock mode not the actual 
WITHOUT_CLASSIFICATION	 private final map new hashmap 
WITHOUT_CLASSIFICATION	 conceivable that the dialect ctor could throw hibernateexceptions dont rewrap 
WITHOUT_CLASSIFICATION	 class table 
WITHOUT_CLASSIFICATION	 synchronized avoid multithread access issues defined method synch avoid potential deadlock issues due nature code 
WITHOUT_CLASSIFICATION	 required exception table iconst 
WITHOUT_CLASSIFICATION	 for now just reflatten the metamodel since this temporary stuff anyway hhh 
WITHOUT_CLASSIFICATION	 checkcast cast the bean into raw bean 
WITHOUT_CLASSIFICATION	 this one only really needed for badlybehaved applications the transactionmanager has sychronization registered its noop actually need for downgrading locks 
WITHOUT_CLASSIFICATION	 checkcast case primitive type invokevirtual case primitive type 
WITHOUT_CLASSIFICATION	 this point have drivingsqlalias the sql alias the driving table corresponding the given user alias however the driving table not necessarily the table against which want apply locks mainly the exception case here joinedsubclass hierarchies where instead want apply the lock against the root table for all other strategies just happens that driving and root are the same 
WITHOUT_CLASSIFICATION	 this bean args raw bean exception 
WITHOUT_CLASSIFICATION	 get the first child considered subclasses may this differently order skip nodes that are not select expressions distinct 
WITHOUT_CLASSIFICATION	 new 
WITHOUT_CLASSIFICATION	 not keywords 
WITHOUT_CLASSIFICATION	 getfield get field javassistcallback defined already 
WITHOUT_CLASSIFICATION	 all are considered equal 
WITHOUT_CLASSIFICATION	 dup 
WITHOUT_CLASSIFICATION	 todo move this per hhh also see hhh and componentmetamodel 
WITHOUT_CLASSIFICATION	 putfield put field javassistcallback defined already 
WITHOUT_CLASSIFICATION	 configure the cache use our 
WITHOUT_CLASSIFICATION	 local variables this callback 
WITHOUT_CLASSIFICATION	 find the batch number associated with the current association any 
WITHOUT_CLASSIFICATION	 invokeinterface 
WITHOUT_CLASSIFICATION	 always assume instance with null identifier identifier property unsaved 
WITHOUT_CLASSIFICATION	 ddl support 
WITHOUT_CLASSIFICATION	 seems not really public boolean return true 
WITHOUT_CLASSIFICATION	 below for cache that dont have str there str and register str directly 
WITHOUT_CLASSIFICATION	 temporary 
WITHOUT_CLASSIFICATION	 byte 
WITHOUT_CLASSIFICATION	 the column doesnt exist all 
WITHOUT_CLASSIFICATION	 note that string deprecated 
WITHOUT_CLASSIFICATION	 the object already loaded return the loaded one 
WITHOUT_CLASSIFICATION	 create new lock that times out immediately 
WITHOUT_CLASSIFICATION	 convenience methods relating operations across arrays types 
WITHOUT_CLASSIFICATION	 really could refresh the item not lock but might slower return freshtimestamp txtimestamp 
WITHOUT_CLASSIFICATION	 due the complexity initializing the selectclause not generate one here not found simply return null also not cache since gets generated well after are created 
WITHOUT_CLASSIFICATION	 discriminator 
WITHOUT_CLASSIFICATION	 versiontype impl note simply returns null for seed and next the only known application binary types for versioning for use with the timestamp datatype supported sybase and sql server which are completely dbgenerated values 
WITHOUT_CLASSIFICATION	 preflushing section 
WITHOUT_CLASSIFICATION	 use the lower case function name remember whether were select clause not 
WITHOUT_CLASSIFICATION	 upper deprecated 
WITHOUT_CLASSIFICATION	 let this take precedence defined since works for assigned identifiers 
WITHOUT_CLASSIFICATION	 throw new write readonly object 
WITHOUT_CLASSIFICATION	 the contract says that returning null indication that the specified entityname thisgetentityname should used 
WITHOUT_CLASSIFICATION	 according both the ansisql and ejb specs trim can either take exactly one parameter variable number parameters between and from the sql spec trim function trim left paren trim operands right paren trim operands trim specification trim character from trim source trim specification leading trailing both only trim specification omitted both assumed trim character omitted space assumed 
WITHOUT_CLASSIFICATION	 the syntax used add foreign key constraint table 
WITHOUT_CLASSIFICATION	 note conceptually possible that usertype could map null nonnull value the following arguable 
WITHOUT_CLASSIFICATION	 note interfaces assumed already contain hibernateproxyclass 
WITHOUT_CLASSIFICATION	 identifiercommalist 
WITHOUT_CLASSIFICATION	 assembled state gets put new array read from cache value 
WITHOUT_CLASSIFICATION	 not have worry about queued additions uninitialized collections since they can only occur for inverse collections 
WITHOUT_CLASSIFICATION	 disassemble named parameters 
WITHOUT_CLASSIFICATION	 not wrappered yet its dirty this cant occur because now always call wrap before getting here return obj instanceof true obj type 
WITHOUT_CLASSIFICATION	 again ccs did not have such concept but reasonable proximity clear the cache after transaction long the underlying cache not jta aware 
WITHOUT_CLASSIFICATION	 oracle driver reports support getgeneratedkeys but they only support the version taking array the names the columns returned via its returning clause other driver seems support this overloaded version 
WITHOUT_CLASSIFICATION	 again ccs did not have such concept however reasonable proximity clear the cache for nontransaction aware caches will also clear the end the transaction 
WITHOUT_CLASSIFICATION	 remove all collections for the entity from the sessionlevel cache 
WITHOUT_CLASSIFICATION	 invokeinterface callbackwrite 
WITHOUT_CLASSIFICATION	 moved from 
WITHOUT_CLASSIFICATION	 joins 
WITHOUT_CLASSIFICATION	 this entity and the property the identifier property then use getidentifiertype note that the propertynameequals propertypath checks whether have component key reference where the component class property name the same the entity property name the two are not equal this the case and wed need fall through using the property mapping 
WITHOUT_CLASSIFICATION	 classes mentioned extends not available put queue 
WITHOUT_CLASSIFICATION	 stuff that tuplizercentric 
WITHOUT_CLASSIFICATION	 propgetname join 
WITHOUT_CLASSIFICATION	 needed bump this dotnode because that the only thing which currently knows about the propertyref path the correct format either this recurse over the dotnodes constructing the property path just like dotnode does internally 
WITHOUT_CLASSIFICATION	 access cached sql 
WITHOUT_CLASSIFICATION	 stuff that tuplizercentric but passed session 
WITHOUT_CLASSIFICATION	 figure out which tables need fetched 
WITHOUT_CLASSIFICATION	 private final list persisters new arraylist 
WITHOUT_CLASSIFICATION	 figure out which columns are needed 
WITHOUT_CLASSIFICATION	 possible for this method called during flush processing make certain that not accidently initialize uninitialized proxy 
WITHOUT_CLASSIFICATION	 figure out which formulas are needed 
WITHOUT_CLASSIFICATION	 get the second pass 
WITHOUT_CLASSIFICATION	 render the sql 
WITHOUT_CLASSIFICATION	 local cache use synchronization 
WITHOUT_CLASSIFICATION	 sql strings 
WITHOUT_CLASSIFICATION	 public static object cloneclass elementclass object array object result object arraynewinstance elementclass arraylength result arraylength return result 
WITHOUT_CLASSIFICATION	 identity support 
WITHOUT_CLASSIFICATION	 there resulting row return null 
WITHOUT_CLASSIFICATION	 load each type 
WITHOUT_CLASSIFICATION	 unfortunately not really safe normalize this initial value like the others because would not able control this are using sequence 
WITHOUT_CLASSIFICATION	 select topic syntax from where section like function order section topic see also 
WITHOUT_CLASSIFICATION	 the optional sql string defined the where attribute 
WITHOUT_CLASSIFICATION	 pass this argument only avoid double looking 
WITHOUT_CLASSIFICATION	 for version properties marked being generated make sure they are always generated aka insert invalid this disallowed the dtd but just make sure 
WITHOUT_CLASSIFICATION	 added this caching noticed that gettype being called multiple times 
WITHOUT_CLASSIFICATION	 information about lazy properties this class 
WITHOUT_CLASSIFICATION	 there are any scalars nonentities selected render the select column aliases 
WITHOUT_CLASSIFICATION	 information about all columnsformulas class hierarchy 
WITHOUT_CLASSIFICATION	 inner classes 
WITHOUT_CLASSIFICATION	 column settypetype 
WITHOUT_CLASSIFICATION	 saveorupdatecopy operations 
WITHOUT_CLASSIFICATION	 dynamic filters attached the classlevel 
WITHOUT_CLASSIFICATION	 the loaded owner will set null after the collection removed capture its value the affected owner accessible both pre and post events 
WITHOUT_CLASSIFICATION	 temporary table support 
WITHOUT_CLASSIFICATION	 assume are autocommit state 
WITHOUT_CLASSIFICATION	 custom sql 
WITHOUT_CLASSIFICATION	 cascade first that all unsaved objects get their copy created before actually copy cascadeonmergeevent persister entity copycache 
WITHOUT_CLASSIFICATION	 modelgetkeysettype new type modelgetidentifier 
WITHOUT_CLASSIFICATION	 the syntax used add column table 
WITHOUT_CLASSIFICATION	 simple because cant have onetoone collection even propertyref compositeelement 
WITHOUT_CLASSIFICATION	 completely optional cascading drop clause 
WITHOUT_CLASSIFICATION	 during deserialization need reconnect all proxies and collections this session well the entityentry and collectionentry instances these associations are transient because serialization used for different things 
WITHOUT_CLASSIFICATION	 properties 
WITHOUT_CLASSIFICATION	 sqlresulttypes type new 
WITHOUT_CLASSIFICATION	 identifier 
WITHOUT_CLASSIFICATION	 call getkeyfromresultset here that can know the key value upon which perform the breaking logic however also then called from getrowfromresultset which certainly not the most efficient but the call here needed and there currently other way without refactoring the methods 
WITHOUT_CLASSIFICATION	 version 
WITHOUT_CLASSIFICATION	 operations which cascade far the collection also cascade collection elements 
WITHOUT_CLASSIFICATION	 where string 
WITHOUT_CLASSIFICATION	 the loop ensures atomicity the select update even for transaction read committed isolation level 
WITHOUT_CLASSIFICATION	 subclass property closure 
WITHOUT_CLASSIFICATION	 effort avoid from potential recursive calls back through here result the eventual call scan the internal loadingcollections map for matches and store those matches temp collection the temp collection then used drive the endread processing 
WITHOUT_CLASSIFICATION	 before add 
WITHOUT_CLASSIFICATION	 the configured transactionfactory says only supports local callback mode sense attempting register jta synchronization 
WITHOUT_CLASSIFICATION	 handle any filters applied the class level 
WITHOUT_CLASSIFICATION	 sybase driver jconnect throwing npe here certain cases but well just handle the general unexpected case 
WITHOUT_CLASSIFICATION	 only onetoone lazy fetched 
WITHOUT_CLASSIFICATION	 replicate does cascade uninitialized collections 
WITHOUT_CLASSIFICATION	 note early exit here 
WITHOUT_CLASSIFICATION	 translates ast join type the token type into joinfragmentxxx join type param astjointype the ast join type from hqlsqltokentypes sqltokentypes return joinfragmentxxx join type see joinfragment see sqltokentypes 
WITHOUT_CLASSIFICATION	 note this assumes something about how implemented the subclass 
WITHOUT_CLASSIFICATION	 deliberately ignore return value 
WITHOUT_CLASSIFICATION	 strip leading 
WITHOUT_CLASSIFICATION	 the metadata allowed proxy creation and caller did not request forceful eager loading generate proxy 
WITHOUT_CLASSIFICATION	 this from element collection and the path collection property maxindex etc then generate subquery 
WITHOUT_CLASSIFICATION	 otherwise return the hydrated state associations are not resolved 
WITHOUT_CLASSIFICATION	 the name the sql function that transforms string lowercase 
WITHOUT_CLASSIFICATION	 null owner 
WITHOUT_CLASSIFICATION	 essentially the real session closed allow any method call pass through since the real session will complain throwing appropriate exception note that allowing close above has the same basic effect but capture that there simply perform the unbind 
WITHOUT_CLASSIFICATION	 automatically makes column with the default name none specifed xml 
WITHOUT_CLASSIFICATION	 just ignore 
WITHOUT_CLASSIFICATION	 this the exception returned cannot locate appropriate constructor 
WITHOUT_CLASSIFICATION	 normal hibernate usage delete detached entity jpa however forbids thus this hook for hem affect this behavior 
WITHOUT_CLASSIFICATION	 null sql means that the only lazy properties are shared onetoone associations which are handled differently the typenullsafeget code 
WITHOUT_CLASSIFICATION	 the property mapping consists all formulas make nonupdateable 
WITHOUT_CLASSIFICATION	 the user specifically supplied inserttrue which constitutes illegal combo 
WITHOUT_CLASSIFICATION	 the property mapping consists all formulas make insertable 
WITHOUT_CLASSIFICATION	 might unwrapped collection reference try find wrapper slowish 
WITHOUT_CLASSIFICATION	 custom sql 
WITHOUT_CLASSIFICATION	 tablename classname path 
WITHOUT_CLASSIFICATION	 return 
WITHOUT_CLASSIFICATION	 the entry will removed after the flush and will longer override the stale snapshot this now handled removeentity entitydeleteaction 
WITHOUT_CLASSIFICATION	 bad cast 
WITHOUT_CLASSIFICATION	 arraylist list new arraylist listaddall listaddall 
WITHOUT_CLASSIFICATION	 propertyrefs for associations defined component are not supported need slice 
WITHOUT_CLASSIFICATION	 have embedded composite identifier 
WITHOUT_CLASSIFICATION	 there propertyref assume the join the subclass table the table the subclass that the association belongs 
WITHOUT_CLASSIFICATION	 stops flush being called multiple times this method recursively called 
WITHOUT_CLASSIFICATION	 create new from node for the referenced class 
WITHOUT_CLASSIFICATION	 performance avoid the array search 
WITHOUT_CLASSIFICATION	 now get existing proxy for each row element there one 
WITHOUT_CLASSIFICATION	 orphan delete used for programmer error detection 
WITHOUT_CLASSIFICATION	 empty means scoping 
WITHOUT_CLASSIFICATION	 enable for hhh which dont like 
WITHOUT_CLASSIFICATION	 lockmode anything 
WITHOUT_CLASSIFICATION	 forcecacherefresh 
WITHOUT_CLASSIFICATION	 this collection initializer must create collection for each the passedin keys account for the possibility that the collection empty and has rows the result set 
WITHOUT_CLASSIFICATION	 embedded component composite ids and unique note that this does not handle nested components 
WITHOUT_CLASSIFICATION	 and perform the load 
WITHOUT_CLASSIFICATION	 aliases 
WITHOUT_CLASSIFICATION	 cache these since they are stateless this one could even static 
WITHOUT_CLASSIFICATION	 nested composite element 
WITHOUT_CLASSIFICATION	 must occur after resolving identifiers 
WITHOUT_CLASSIFICATION	 get the persister for the subclass 
WITHOUT_CLASSIFICATION	 aliases for compositeids 
WITHOUT_CLASSIFICATION	 sqlqueryparser parser new sqlqueryparser sqlquery aliases collaliases collpersisters suffixes collsuffixes sql parserprocess 
WITHOUT_CLASSIFICATION	 fetch embedded identifiers propertynames from the virtual identifier component 
WITHOUT_CLASSIFICATION	 need grab the version value from the entity otherwise have issues with generatedversion entities that may have multiple actions queued during the same flush 
WITHOUT_CLASSIFICATION	 embedded composite ids aliasidname aliasidname 
WITHOUT_CLASSIFICATION	 note need the wrap here even its not dirty because collections need wrapping but changes them dont dirty the container also for versioned data need wrap before calling 
WITHOUT_CLASSIFICATION	 todo skip formulas 
WITHOUT_CLASSIFICATION	 guid support 
WITHOUT_CLASSIFICATION	 invokeinterface invoke 
WITHOUT_CLASSIFICATION	 hibernate seems ignore this type 
WITHOUT_CLASSIFICATION	 dont need filters for the static loaders 
WITHOUT_CLASSIFICATION	 the user requested greater more restrictive form pessimistic lock 
WITHOUT_CLASSIFICATION	 two passes for collection propertyref 
WITHOUT_CLASSIFICATION	 public boolean have because postgres sets current rollback only after failed create table return true 
WITHOUT_CLASSIFICATION	 select the correct row either rowid 
WITHOUT_CLASSIFICATION	 optimizer mappedclass getternames setternames proptypes 
WITHOUT_CLASSIFICATION	 todo eventually rowidnamej 
WITHOUT_CLASSIFICATION	 include the discriminator and classlevel where but not filters 
WITHOUT_CLASSIFICATION	 lazy join 
WITHOUT_CLASSIFICATION	 not absolutely necessary but helps for some equalshashcode implementations 
WITHOUT_CLASSIFICATION	 this property the table which are updating 
WITHOUT_CLASSIFICATION	 the hibernatemapping did not specify schemacatalog use the defaults specified properties but note that the schemacatalog were specified hibernatemapping params they will already initialized and will override the values set here they are 
WITHOUT_CLASSIFICATION	 this should only possible the caches are constructor injected 
WITHOUT_CLASSIFICATION	 transactions marked for rollbackonly cause some impls throw exceptions 
WITHOUT_CLASSIFICATION	 special shortcut for properties skip the join this must only occur the end path expression 
WITHOUT_CLASSIFICATION	 impl note due the delayed population setters setters cached for performance really cannot properly define equality for this transformer 
WITHOUT_CLASSIFICATION	 column simplevalue icgetindex setnullablefalse 
WITHOUT_CLASSIFICATION	 have mapped identifier property and the root the incoming property path matched that identifier property 
WITHOUT_CLASSIFICATION	 contained elements 
WITHOUT_CLASSIFICATION	 for noninverse onetomany with notnull add backref 
WITHOUT_CLASSIFICATION	 stop the class from being unloaded 
WITHOUT_CLASSIFICATION	 mappings might contain either the raw extends name the case entityname mapping fqn the case pojo mapping 
WITHOUT_CLASSIFICATION	 for objects that came via update 
WITHOUT_CLASSIFICATION	 use dialect default properties 
WITHOUT_CLASSIFICATION	 increment the version number necessary 
WITHOUT_CLASSIFICATION	 the cache provider needed when either have secondlevel cache enabled query cache enabled note that usesecondlevelcache enabled default 
WITHOUT_CLASSIFICATION	 information about all properties class hierarchy 
WITHOUT_CLASSIFICATION	 string provider loginfo bytecode provider name provider bytecodeprovider bytecodeprovider provider bytecodeprovider 
WITHOUT_CLASSIFICATION	 informational metadata 
WITHOUT_CLASSIFICATION	 are using all dirty propertybased optimistic locking 
WITHOUT_CLASSIFICATION	 orphans should deleted during saveupdate 
WITHOUT_CLASSIFICATION	 maybe concrete sqlpropertyresult type but map exactly what required the moment 
WITHOUT_CLASSIFICATION	 for some reason the antlrcommonast initialization routines force this method get called twice the first time with empty string 
WITHOUT_CLASSIFICATION	 check 
WITHOUT_CLASSIFICATION	 sqlaliassuffixesi 
WITHOUT_CLASSIFICATION	 void showsql void formatsql 
WITHOUT_CLASSIFICATION	 materialize associations and initialize the object later 
WITHOUT_CLASSIFICATION	 private todo hhh and hhh 
WITHOUT_CLASSIFICATION	 fetchjoin overrides default laziness fetchjoin overrides default laziness 
WITHOUT_CLASSIFICATION	 drop them reverse order case needs done that way 
WITHOUT_CLASSIFICATION	 this check needed since processing leaves the cursor after the last physical row for the current logical row thus are after the last physical row this might caused either scrolling the last logical row scrolling past the last logical row the latter scenario the previous logical row really the last logical row all other cases should process back two logical records the current logic row plus the previous logical row 
WITHOUT_CLASSIFICATION	 the owning entity may have been deleted and its identifier unset due identifierrollback which case try look its identifier from the persistence context 
WITHOUT_CLASSIFICATION	 build array with indices equal the total number actual returns the result hibernate will return for this query scalars nonscalars 
WITHOUT_CLASSIFICATION	 public return 
WITHOUT_CLASSIFICATION	 mckoi has known variation select for update syntax 
WITHOUT_CLASSIFICATION	 was referenced somewhere 
WITHOUT_CLASSIFICATION	 should performancewise generate new delegate instances for each request since these are locally stackscoped besides makes the code much easier read than the old transactionhelper stuff 
WITHOUT_CLASSIFICATION	 nothing even the operand parameter way could infer appropriate expected type here 
WITHOUT_CLASSIFICATION	 the root the incoming property path matched one the embedded composite identifier properties 
WITHOUT_CLASSIFICATION	 add normal properties 
WITHOUT_CLASSIFICATION	 serialization 
WITHOUT_CLASSIFICATION	 add the discriminator 
WITHOUT_CLASSIFICATION	 handles arrays and newly instantiated collections 
WITHOUT_CLASSIFICATION	 either its role changed 
WITHOUT_CLASSIFICATION	 noncritical swallow and let the other propagate 
WITHOUT_CLASSIFICATION	 will need create new entries 
WITHOUT_CLASSIFICATION	 this piece needed for usage select clause 
WITHOUT_CLASSIFICATION	 noop dont own the cache shouldnt stop 
WITHOUT_CLASSIFICATION	 key entity involved with the operation performed the listener value can either copy the entity the entity itself 
WITHOUT_CLASSIFICATION	 get the names the columns used link between the collection owner and the collection elements 
WITHOUT_CLASSIFICATION	 lets assume that there only one lazy fetch group for now 
WITHOUT_CLASSIFICATION	 more specifically datetime the operator minus the param needs some datetime type the operator plus the param needs some numeric type 
WITHOUT_CLASSIFICATION	 dont even bother trying read any further 
WITHOUT_CLASSIFICATION	 prepend value and type list with null for any positions before the wanted position 
WITHOUT_CLASSIFICATION	 not used for backward compatibility 
WITHOUT_CLASSIFICATION	 static helper methods 
WITHOUT_CLASSIFICATION	 base expectation impls 
WITHOUT_CLASSIFICATION	 this property belongs the table and inserted 
WITHOUT_CLASSIFICATION	 need extract the component values and check for subtype replacements 
WITHOUT_CLASSIFICATION	 add the primary key 
WITHOUT_CLASSIFICATION	 impl note allows multiple collection fetches long the entire fecthed graph still points back single root entity for return 
WITHOUT_CLASSIFICATION	 registercolumntype typesblob mediumblob registercolumntype typesblob blob 
WITHOUT_CLASSIFICATION	 delegate already handles columns 
WITHOUT_CLASSIFICATION	 estatusdeleted 
WITHOUT_CLASSIFICATION	 kept for backward compatibility until after the beta release 
WITHOUT_CLASSIFICATION	 legacy behavior apply the bridge 
WITHOUT_CLASSIFICATION	 exception occurs during flush user must call rollback 
WITHOUT_CLASSIFICATION	 turn off includesubclasses all fromelements 
WITHOUT_CLASSIFICATION	 cant just return null here since that would cause owning component become null 
WITHOUT_CLASSIFICATION	 the object transient detached 
WITHOUT_CLASSIFICATION	 now update only the tables with dirty properties and the table with the version number 
WITHOUT_CLASSIFICATION	 render the sql query 
WITHOUT_CLASSIFICATION	 must return valid rdmsrsa command from this method prevent rdmsrsa from issuing error 
WITHOUT_CLASSIFICATION	 write the values fields onto the prepared statement must use the state the time the insert was issued cos foreign key constraints not necessarily the objects current state 
WITHOUT_CLASSIFICATION	 characterl characterl for use prior characterl 
WITHOUT_CLASSIFICATION	 todo shouldnt inserts expectationsnone 
WITHOUT_CLASSIFICATION	 proxy cannot transient and breaks 
WITHOUT_CLASSIFICATION	 dont bother trying update know there row there yet 
WITHOUT_CLASSIFICATION	 this the root level node generate explicit from clause the root 
WITHOUT_CLASSIFICATION	 check 
WITHOUT_CLASSIFICATION	 actual cache the entries soft references are used for both the keys and the values here since the values pertaining the mru entries are kept seperate hard reference cache avoid their 
WITHOUT_CLASSIFICATION	 all fields are null might need delete existing row 
WITHOUT_CLASSIFICATION	 note updates joined tables cant batched 
WITHOUT_CLASSIFICATION	 string functions 
WITHOUT_CLASSIFICATION	 starting index 
WITHOUT_CLASSIFICATION	 object have been loaded with setreadonlytrue hhh 
WITHOUT_CLASSIFICATION	 build given containing element for the returnxxx elements param resultsetelem the element containing the return definitions param path clue param mappings the current processing state return the description the mappings 
WITHOUT_CLASSIFICATION	 private list new arraylist private list collectionaliases new arraylist private list new arraylist private list collectionresults new arraylist 
WITHOUT_CLASSIFICATION	 write any appropriate versioning conditional parameters 
WITHOUT_CLASSIFICATION	 check the detached object being merged the parent 
WITHOUT_CLASSIFICATION	 render the sql query 
WITHOUT_CLASSIFICATION	 determine the collection elements are entities 
WITHOUT_CLASSIFICATION	 the key the key immutable can use the current object state not necessarily the state the time the delete was issued 
WITHOUT_CLASSIFICATION	 let returnpropertys override whatever the persister has for aliases 
WITHOUT_CLASSIFICATION	 should use the current object state after any updates that occurred during flush 
WITHOUT_CLASSIFICATION	 might need run different filter entirely after the flush because the collection role may have changed 
WITHOUT_CLASSIFICATION	 amazingly these two will work because abstractcollection uses iterator fill the array 
WITHOUT_CLASSIFICATION	 cant cache this stuff either perinvocation are given map useralias lock mode create new map sqlalias lock mode 
WITHOUT_CLASSIFICATION	 note dirtyfieldsnull means had snapshot and couldnt get one using selectbeforeupdate oldfieldsnull just means had snapshot begin with might have used selectbeforeupdate get the dirtyfields 
WITHOUT_CLASSIFICATION	 loop through all the associations the current entity and make sure that they are processed before the current batch number 
WITHOUT_CLASSIFICATION	 parametercontainer impl 
WITHOUT_CLASSIFICATION	 temporary 
WITHOUT_CLASSIFICATION	 note that load this collection from cartesian product the multiplicity would broken use idbag instead 
WITHOUT_CLASSIFICATION	 column and table should renamed but would break the public api 
WITHOUT_CLASSIFICATION	 for manytomany joins use the tablename from the queryable collection for the default text 
WITHOUT_CLASSIFICATION	 int result result result typehashcode result result valuenull valuehashcode return result 
WITHOUT_CLASSIFICATION	 for the case dynamicupdatetrue need generate the update sql 
WITHOUT_CLASSIFICATION	 merge operations 
WITHOUT_CLASSIFICATION	 default collections sharing entity cache there one 
WITHOUT_CLASSIFICATION	 commented out inspection public abstract void addconditionstring alias string columns string condition 
WITHOUT_CLASSIFICATION	 dont need check laziness dirty checking algorithm handles that 
WITHOUT_CLASSIFICATION	 roottablename factorygetdialect 
WITHOUT_CLASSIFICATION	 for the case dynamicupdatefalse snapshot use the static sql 
WITHOUT_CLASSIFICATION	 abort the save the object already saved circular cascade 
WITHOUT_CLASSIFICATION	 not get then try 
WITHOUT_CLASSIFICATION	 remove initial and 
WITHOUT_CLASSIFICATION	 default sharing the entity cache there one 
WITHOUT_CLASSIFICATION	 have the form trimtrimsource trim leading and trailing spaces 
WITHOUT_CLASSIFICATION	 for the case dynamicinserttrue need generate the insert sql 
WITHOUT_CLASSIFICATION	 was reference self dont need nullify unless are using native generation which case definitely need nullify 
WITHOUT_CLASSIFICATION	 the user visible aliases which are unknown the superclass these are not the actual physical sql aliases 
WITHOUT_CLASSIFICATION	 for the case dynamicinsertfalse use the static sql 
WITHOUT_CLASSIFICATION	 composite key use foo and bar foo and bar for batching todo unnecessary for databases with ansistyle joins 
WITHOUT_CLASSIFICATION	 shortcut its location didnt change 
WITHOUT_CLASSIFICATION	 swaldman define cpstyle configuration parameters for properties with hibernatespecific overrides detect and warn about conflicting declarations 
WITHOUT_CLASSIFICATION	 need use the identifier type the collection owner since the incoming value actually the owners using the collections key type causes problems with propertyref keys 
WITHOUT_CLASSIFICATION	 instantiate collection during the flush process must ignore for the rest the flush 
WITHOUT_CLASSIFICATION	 moved from 
WITHOUT_CLASSIFICATION	 new collections that get found wrapped during flush shouldnt ignored 
WITHOUT_CLASSIFICATION	 meant handle dynamic instantiation queries 
WITHOUT_CLASSIFICATION	 newly wrapped collection not dirty get unnecessary version updates 
WITHOUT_CLASSIFICATION	 always add the collections query spaces 
WITHOUT_CLASSIFICATION	 the blob type requires size arguement this defaults bytes arg defaults whole byte other argument mods include kilobyte megabyte gigabyte refer the pbdevelopers guide for more info 
WITHOUT_CLASSIFICATION	 detached collections that get found reattached during flush shouldnt ignored 
WITHOUT_CLASSIFICATION	 revert traditional hibernate behavior setting initialpoolsize minpoolsize unless otherwise specified with cpstyle parameter 
WITHOUT_CLASSIFICATION	 need utilize dynamic delete statements 
WITHOUT_CLASSIFICATION	 otherwise utilize the static delete statements 
WITHOUT_CLASSIFICATION	 intentionally empty 
WITHOUT_CLASSIFICATION	 public boolean equalsobject other read return bagequalsother public int hashcodeobject other read return baghashcode 
WITHOUT_CLASSIFICATION	 final boolean forcecacherefresh 
WITHOUT_CLASSIFICATION	 just performance opt 
WITHOUT_CLASSIFICATION	 essentially have local hibernate transaction progress and already has the usertransaction cached use that usertransaction determine the status transaction manager has been located use that transaction manager determine the status finally the last resort try lookup the usertransaction via jndi and use that determine the status 
WITHOUT_CLASSIFICATION	 used set the type the parent dot node 
WITHOUT_CLASSIFICATION	 all joins join the the driving table 
WITHOUT_CLASSIFICATION	 more specifically datetime the operator minus really cannot determine the expected type either another datetime numeric would valid the operator plus the param needs some numeric type 
WITHOUT_CLASSIFICATION	 notice that skip the first table the driving table 
WITHOUT_CLASSIFICATION	 aliases named identifier aliasidname 
WITHOUT_CLASSIFICATION	 skip the driving table 
WITHOUT_CLASSIFICATION	 inserts 
WITHOUT_CLASSIFICATION	 get the right order not that really matters 
WITHOUT_CLASSIFICATION	 note early exit 
WITHOUT_CLASSIFICATION	 trying via forname first close drivermanagers semantics 
WITHOUT_CLASSIFICATION	 this bit only really absolutely necessary for handling requestedid but also good merge multiple object graphs since helps ensure uniqueness 
WITHOUT_CLASSIFICATION	 private boolean showsql private boolean formatsql 
WITHOUT_CLASSIFICATION	 case were deserialized different jvm look for instance with the same name alternatively could actual jndi lookup here 
WITHOUT_CLASSIFICATION	 try make sure dont wrap and already wrapped session 
WITHOUT_CLASSIFICATION	 this implied join from clause then use ansistyle joining and set the flag the fromelement that indicates that was implied the from clause itself 
WITHOUT_CLASSIFICATION	 render the where and from parts 
WITHOUT_CLASSIFICATION	 there already existing batch for this type entity check see the latest batch acceptable 
WITHOUT_CLASSIFICATION	 allow these through the the real session matter what 
WITHOUT_CLASSIFICATION	 dont really know all the codes required adequately decipher returned jdbc exceptions here simply allow the failure eaten and the subsequent should fail 
WITHOUT_CLASSIFICATION	 could regerate this inside each called method 
WITHOUT_CLASSIFICATION	 the cascadingaction implementations 
WITHOUT_CLASSIFICATION	 now render the joins 
WITHOUT_CLASSIFICATION	 youre closing down the connectionprovider chances are not real big deal just warn 
WITHOUT_CLASSIFICATION	 create new batch for this type the batch number the number current batches 
WITHOUT_CLASSIFICATION	 keyword support 
WITHOUT_CLASSIFICATION	 this will add the new from element the origin 
WITHOUT_CLASSIFICATION	 now render the select clause 
WITHOUT_CLASSIFICATION	 the keyword used insert row without specifying any column values 
WITHOUT_CLASSIFICATION	 now tie all together 
WITHOUT_CLASSIFICATION	 does the limit clause take maximum row number instead total number returned rows 
WITHOUT_CLASSIFICATION	 insertupdatedelete sql 
WITHOUT_CLASSIFICATION	 the keyword used specify nullable column 
WITHOUT_CLASSIFICATION	 select sql 
WITHOUT_CLASSIFICATION	 overriden avoid systemexit 
WITHOUT_CLASSIFICATION	 need check laziness dirty checking handles that 
WITHOUT_CLASSIFICATION	 callable statement support 
WITHOUT_CLASSIFICATION	 fully resolve the map reference create implicit joins 
WITHOUT_CLASSIFICATION	 break the outer loop 
WITHOUT_CLASSIFICATION	 since this entity will now processed the latest possible batch can assured that will come after all other associations theres not need continue checking 
WITHOUT_CLASSIFICATION	 remove any snapshot not really for memory management purposes but rather because might now stale and there longer any entityentry take precedence this now handled removeentity 
WITHOUT_CLASSIFICATION	 the basic implementation simply use the nodes text 
WITHOUT_CLASSIFICATION	 intersystems cache does not current support select for update syntax set your transaction mode readcommitted before using 
WITHOUT_CLASSIFICATION	 cascade current collection elements 
WITHOUT_CLASSIFICATION	 constructors 
WITHOUT_CLASSIFICATION	 not really necessary but good for consistency 
WITHOUT_CLASSIFICATION	 try find out the name the primary key create identity the identitygenerator used 
WITHOUT_CLASSIFICATION	 cant cascade nonembedded elements 
WITHOUT_CLASSIFICATION	 postdelete after actually deleting row record the fact that the instance longer exists the database needed for identitycolumn key generation and remove from the session cache 
WITHOUT_CLASSIFICATION	 newly instantiated collection cant have orphans 
WITHOUT_CLASSIFICATION	 dont hold the jbc node lock throughout the that prevents reads and other updates 
WITHOUT_CLASSIFICATION	 check the version unsavedvalue appropriate 
WITHOUT_CLASSIFICATION	 create the sessionfactory from hibernatecfgxml 
WITHOUT_CLASSIFICATION	 handle orphaned entities 
WITHOUT_CLASSIFICATION	 check the unsavedvalue 
WITHOUT_CLASSIFICATION	 get here possible that have proxy the way the merge map resolution note decided put this here rather than the above loop was nervous about the performance the loopinloop especially considering this far more likely the edge case 
WITHOUT_CLASSIFICATION	 check see the secondlevel cache 
WITHOUT_CLASSIFICATION	 custom sql would better these were private 
WITHOUT_CLASSIFICATION	 our column span the number columns the 
WITHOUT_CLASSIFICATION	 for property references generate projectionalias 
WITHOUT_CLASSIFICATION	 key 
WITHOUT_CLASSIFICATION	 force immediate execution the insert 
WITHOUT_CLASSIFICATION	 general purpose parameters 
WITHOUT_CLASSIFICATION	 entities 
WITHOUT_CLASSIFICATION	 constructors 
WITHOUT_CLASSIFICATION	 loaded entity instances entityuniquekey 
WITHOUT_CLASSIFICATION	 allow any identifier quoted with backtick only recognizes identifiers beginning with letter 
WITHOUT_CLASSIFICATION	 collections 
WITHOUT_CLASSIFICATION	 configurable implementation 
WITHOUT_CLASSIFICATION	 identity map entityentry instances the entity instance 
WITHOUT_CLASSIFICATION	 write html footer 
WITHOUT_CLASSIFICATION	 entity proxies entitykey 
WITHOUT_CLASSIFICATION	 delete does cascade uninitialized collections 
WITHOUT_CLASSIFICATION	 snapshots current database state for entities that have not been loaded 
WITHOUT_CLASSIFICATION	 nativesql collect key column and autoaliases 
WITHOUT_CLASSIFICATION	 identity map array holder arrayholder instances the array instance 
WITHOUT_CLASSIFICATION	 cannot occur 
WITHOUT_CLASSIFICATION	 dont need lock the cache here since someone else inserted the same first the insert would fail 
WITHOUT_CLASSIFICATION	 this not strictly true actually just need make sure that ordered rootentity and that that orderby comes before any nonrootentity ordering 
WITHOUT_CLASSIFICATION	 try get 
WITHOUT_CLASSIFICATION	 pass control along the rest the processing chain 
WITHOUT_CLASSIFICATION	 set entitykeys deleted objects 
WITHOUT_CLASSIFICATION	 all this only really needs consider properties this class not its subclasses but since are reusing code used for sequential selects use the subclass closure 
WITHOUT_CLASSIFICATION	 list collection wrappers that were instantiating during result set processing that will need initialize the end the query 
WITHOUT_CLASSIFICATION	 protected void initpropertypaths final string path final type type final string columns final string formulatemplates final mapping factory throws mappingexception type formulatemplates type columns formulatemplates factory 
WITHOUT_CLASSIFICATION	 downgrade locks 
WITHOUT_CLASSIFICATION	 column getname 
WITHOUT_CLASSIFICATION	 nothing 
WITHOUT_CLASSIFICATION	 deserialize 
WITHOUT_CLASSIFICATION	 actually the semantics the next three are really bag note that unlike objects collection insertions updates deletions are not really remembered between flushes just reuse the same lists for convenience 
WITHOUT_CLASSIFICATION	 public boolean isshowsqlenabled return showsql public boolean isformatsqlenabled return formatsql 
WITHOUT_CLASSIFICATION	 with twodeep subqueries the same alias would get generated for both using the old method that now used fallback the main criteria alias isnt set 
WITHOUT_CLASSIFICATION	 arraynull templistsize 
WITHOUT_CLASSIFICATION	 sort the updates 
WITHOUT_CLASSIFICATION	 should safe only ever expect entitypersister references here 
WITHOUT_CLASSIFICATION	 optimize the hash size eliminate rehash 
WITHOUT_CLASSIFICATION	 unwrap the object 
WITHOUT_CLASSIFICATION	 impl note takes advantage the fact that escpaed single quote embedded within quoteblock can really handled two seperate quoteblocks for the purposes this method 
WITHOUT_CLASSIFICATION	 the entity associated with the current action 
WITHOUT_CLASSIFICATION	 this page intentionally left blank 
WITHOUT_CLASSIFICATION	 unfortunately this stuff cant cached because perinvocation not constant for the querytranslator instance 
WITHOUT_CLASSIFICATION	 initialize unwrap the object 
WITHOUT_CLASSIFICATION	 sequence support 
WITHOUT_CLASSIFICATION	 not anything 
WITHOUT_CLASSIFICATION	 cant batch joined inserts especially not identity insert nor can batch statements where the expectation based output param 
WITHOUT_CLASSIFICATION	 return the proxied object 
WITHOUT_CLASSIFICATION	 else collection element but also owner 
WITHOUT_CLASSIFICATION	 have the form trimtrimsource trim leading and trailing spaces early exit 
WITHOUT_CLASSIFICATION	 overwrite old proxy 
WITHOUT_CLASSIFICATION	 the mru cache used keep hard references the most recently used query plans note lru here bit misnomer indicates that lru entries are removed the actual kept entries are the mru entries 
WITHOUT_CLASSIFICATION	 early exit 
WITHOUT_CLASSIFICATION	 handles things like and and not and not not and between and overloaded and overloaded brackets not not not null overloaded not etc and expressions like foo bar maps fooid barid foobar foo maps foobar foo foobarbaz maps foobar barid and barbaz foobarbaz maps barbaz and foobar barid foobarbaz abc maps barbaz and foobar barid and bid foobarbaz abc maps barbaz and foobar barid and bid foobarbaz maps barbaz and foobar barid 
WITHOUT_CLASSIFICATION	 should actually throw exception 
WITHOUT_CLASSIFICATION	 both manytoone and onetoone are represented property entitypersister relying this value determine lazy fetch groups terms fieldlevel interception need make sure that return true here for the case manytoone and onetoone with lazynoproxy impl note lazynoproxy currently forces both lazy and unwrap set true the other case are extremely interested here that lazyproxy where lazy set true but unwrap set false thus use both here under the assumption that this return really only ever used during persister construction determine the lazy propertyfield fetch groupings that assertion changes then this check needs change well partially this issue with the overloading the term lazy here 
WITHOUT_CLASSIFICATION	 the property component 
WITHOUT_CLASSIFICATION	 the ids are fully resolved compare them with isdirty not ismodified 
WITHOUT_CLASSIFICATION	 cant instantiate 
WITHOUT_CLASSIFICATION	 queryjoinfragment join 
WITHOUT_CLASSIFICATION	 property embedded component invoke the identifier 
WITHOUT_CLASSIFICATION	 otherwise 
WITHOUT_CLASSIFICATION	 starts with the name mapped class new style 
WITHOUT_CLASSIFICATION	 treat just like new collection 
WITHOUT_CLASSIFICATION	 skip finalize methods 
WITHOUT_CLASSIFICATION	 return the fully resolved identifier value but not resolve the actual referenced entity instance note the owner the association not really the owner the 
WITHOUT_CLASSIFICATION	 this work only the very highest level the load dont let this method called recursively 
WITHOUT_CLASSIFICATION	 public static jdbcexception string sqlexception root string sql string string sql logerrorstring root logexceptionsroot return new jdbcexceptionstring root sql public static jdbcexception string sqlexception root logerrorstring root logexceptionsroot return new jdbcexceptionstring root 
WITHOUT_CLASSIFICATION	 note that each iteration the loop may add new elements 
WITHOUT_CLASSIFICATION	 know there exactly row can skip would great could always skip this problem for keymanytoone 
WITHOUT_CLASSIFICATION	 this can never happen because this rule will always eliminate the child not case not return xgetfirstchild not not 
WITHOUT_CLASSIFICATION	 need obtain the lock before any actions are executed since this may inversetrue bidirectional association and one the earlier entity actions which actually updates the database this action resposible for secondlevel cache invalidation only 
WITHOUT_CLASSIFICATION	 hhh make sure the callback gets cleared otherwise the instance stays static thread local 
WITHOUT_CLASSIFICATION	 point doing this none was requested 
WITHOUT_CLASSIFICATION	 while constructor running 
WITHOUT_CLASSIFICATION	 there probably row there try update rows were updated will find out 
WITHOUT_CLASSIFICATION	 note interface assumed already contain hibernateproxyclass 
WITHOUT_CLASSIFICATION	 nothing avoid lazy property initialization 
WITHOUT_CLASSIFICATION	 interfaces arguments 
WITHOUT_CLASSIFICATION	 not called runtime doesnt matter its slow 
WITHOUT_CLASSIFICATION	 todo 
WITHOUT_CLASSIFICATION	 chop off the rest the tree 
WITHOUT_CLASSIFICATION	 get the caller 
WITHOUT_CLASSIFICATION	 prefer regeneration identity 
WITHOUT_CLASSIFICATION	 get the caller principals 
WITHOUT_CLASSIFICATION	 refresh doesnt cascade uninitialized collections 
WITHOUT_CLASSIFICATION	 private static final alias defaultalias new alias null 
WITHOUT_CLASSIFICATION	 public boolean key return 
WITHOUT_CLASSIFICATION	 generate select fragment and then property select fragment for each expression just like 
WITHOUT_CLASSIFICATION	 public boolean key return 
WITHOUT_CLASSIFICATION	 special case this the leaf the containment graph even though not immutable 
WITHOUT_CLASSIFICATION	 iterate all the entities currently associated with the persistence context 
WITHOUT_CLASSIFICATION	 according both the ansisql and jpa specs trim takes variable number parameters between and least one paramer trimsource required from the sql spec trim function trim left paren trim operands right paren trim operands trim specification trim character from trim source trim specification leading trailing both trim specification omitted both assumed trim character omitted space assumed 
WITHOUT_CLASSIFICATION	 does this entity entry pertain the entity persister which are interested owner 
WITHOUT_CLASSIFICATION	 prepare persisters and link them with their cache 
WITHOUT_CLASSIFICATION	 check the managed object the parent 
WITHOUT_CLASSIFICATION	 allows various loaders mainly the queryloader check whether scrolling their result set should allowed default allowed 
WITHOUT_CLASSIFICATION	 otherwise the proxy was pruned during the serialization process 
WITHOUT_CLASSIFICATION	 does not handle arrays thats cos they cant lazy newly instantiated collections can the cast 
WITHOUT_CLASSIFICATION	 adds remove sortof alias for delete 
WITHOUT_CLASSIFICATION	 return 
WITHOUT_CLASSIFICATION	 saves updates dont cascade uninitialized collections 
WITHOUT_CLASSIFICATION	 early exit 
WITHOUT_CLASSIFICATION	 create our own copy the usersupplied tuplizer impl map 
WITHOUT_CLASSIFICATION	 the identifier quoted remove the quotes 
WITHOUT_CLASSIFICATION	 can the cast since orphandelete does not apply newly instantiated collections arrays cant track orphans for detached arrays 
WITHOUT_CLASSIFICATION	 truncate the identifier the max alias length less the suffix length 
WITHOUT_CLASSIFICATION	 full joins are not supported yet 
WITHOUT_CLASSIFICATION	 you may still have other resultsets update counts left process here but you cant now the resultset you just got will closed 
WITHOUT_CLASSIFICATION	 null not considered the same type integer nonnls nonnls 
WITHOUT_CLASSIFICATION	 properly handle propertyrefbased associations 
WITHOUT_CLASSIFICATION	 the needs come before where clause properly handle dynamic filters 
WITHOUT_CLASSIFICATION	 determine the getter and setter methods from the proxy interface any determine all interfaces needed the resulting proxy 
WITHOUT_CLASSIFICATION	 add another inner nested select add the main query close off the inner nested select 
WITHOUT_CLASSIFICATION	 destination this was the cause hhh originsettype fromfragment set the parent node type that the ast properly formed the destination node will have all the from text the parent node collection join too voodoo see joinprocessor 
WITHOUT_CLASSIFICATION	 then handle any userdefined entity modes 
WITHOUT_CLASSIFICATION	 strip off any leading and token 
WITHOUT_CLASSIFICATION	 then the pojo tuplizer using the dynamicmap tuplizer pojo representation available 
WITHOUT_CLASSIFICATION	 the condition not already there 
WITHOUT_CLASSIFICATION	 this has been shown happen occasionally rare cases when using transaction manager transactiontimeout where the timeout calls back through hibernates registered transaction synchronization separate reaping thread cases where that reaping thread executes through this block the same time the main application thread does can get into situations where these cmes occur and though not allowed perse the end result without handling specifically infinite looping here simply break the loop 
WITHOUT_CLASSIFICATION	 dontspaceadd 
WITHOUT_CLASSIFICATION	 public component sessionfactory 
WITHOUT_CLASSIFICATION	 for mysql 
WITHOUT_CLASSIFICATION	 detect discriminator values 
WITHOUT_CLASSIFICATION	 set custom entity resolver this entity resolver must set before addxxxmisc call default value link param entityresolver entity resolver use 
WITHOUT_CLASSIFICATION	 handle any filters applied this collection 
WITHOUT_CLASSIFICATION	 handle propertyref 
WITHOUT_CLASSIFICATION	 could not register synchronization the beforeafter completion callbacks ourself but need let jdbccontext know that this what are going doesnt keep trying register synchronizations 
WITHOUT_CLASSIFICATION	 hashmap columnsunique new hashmap 
WITHOUT_CLASSIFICATION	 null caused some problems 
WITHOUT_CLASSIFICATION	 two conditions where need transform this thetajoin syntax elem the root fromelement correlated subqueries the has been set true and elem represents implicit join 
WITHOUT_CLASSIFICATION	 cascade the refresh prior refreshing this entity 
WITHOUT_CLASSIFICATION	 not sure this would ever null but wanted careful 
WITHOUT_CLASSIFICATION	 even inversetrue 
WITHOUT_CLASSIFICATION	 need dirty check manytoones with notfoundignore order update the cache not the database since this case null entity reference can lose information 
WITHOUT_CLASSIFICATION	 register hibernate types for default use scalar sqlquery type auto detection 
WITHOUT_CLASSIFICATION	 true then execute updates otherwise just generate and display updates 
WITHOUT_CLASSIFICATION	 sqlfunction implementation 
WITHOUT_CLASSIFICATION	 only release the connection 
WITHOUT_CLASSIFICATION	 only check the version when upgrading lock modes 
WITHOUT_CLASSIFICATION	 deprecated option 
WITHOUT_CLASSIFICATION	 only carry the method has parameters 
WITHOUT_CLASSIFICATION	 woops got instance another class hierarchy branch 
WITHOUT_CLASSIFICATION	 compositeid 
WITHOUT_CLASSIFICATION	 create outerjoingenerator for this dialect 
WITHOUT_CLASSIFICATION	 actually this last test probably unnecessary since beforecompletion doesnt get called during rollback 
WITHOUT_CLASSIFICATION	 need step through the rows one row time slow 
WITHOUT_CLASSIFICATION	 lock acquisition support 
WITHOUT_CLASSIFICATION	 create dotnode ast for the path and resolve 
WITHOUT_CLASSIFICATION	 its already loaded dont need hydrate 
WITHOUT_CLASSIFICATION	 orphans should deleted during delete 
WITHOUT_CLASSIFICATION	 swallow and continue roll back jta transaction 
WITHOUT_CLASSIFICATION	 here have two possibilities the propertyname matches the explicitly identifier property name the propertyname matches the implicit property name 
WITHOUT_CLASSIFICATION	 the transaction already rolled back jta spec 
WITHOUT_CLASSIFICATION	 found collection element the result set 
WITHOUT_CLASSIFICATION	 this method noop there synchronization 
WITHOUT_CLASSIFICATION	 register the standard dialect resolver 
WITHOUT_CLASSIFICATION	 why all others non final 
WITHOUT_CLASSIFICATION	 even though might find preexisting element join path may not able reuse 
WITHOUT_CLASSIFICATION	 hella important optimization 
WITHOUT_CLASSIFICATION	 return thattypeequalstype value 
WITHOUT_CLASSIFICATION	 null child could occur for from clause filter 
WITHOUT_CLASSIFICATION	 the from element that the property 
WITHOUT_CLASSIFICATION	 since the result set cursor always left the first physical row after the last processed need jump back one position get the key value are interested skipping 
WITHOUT_CLASSIFICATION	 websphere however not sane jeejta container 
WITHOUT_CLASSIFICATION	 loop through all the associated entities and make sure they have been processed before the latest batch associated with this entity type 
WITHOUT_CLASSIFICATION	 for sane jeejta containers the transaction itself functions its identifier 
WITHOUT_CLASSIFICATION	 first try find matching constructor accepting param 
WITHOUT_CLASSIFICATION	 swallow the transaction was finished 
WITHOUT_CLASSIFICATION	 will ignored using the existing entry instead 
WITHOUT_CLASSIFICATION	 seconds 
WITHOUT_CLASSIFICATION	 this property belongs the table and not specifically excluded from optimistic locking optimisticlockfalse 
WITHOUT_CLASSIFICATION	 dont hold transactional lock for this 
WITHOUT_CLASSIFICATION	 some collections are not lazy 
WITHOUT_CLASSIFICATION	 fix the resident flag 
WITHOUT_CLASSIFICATION	 does the limit clause come the start the select statement rather than the end 
WITHOUT_CLASSIFICATION	 all are considered equal 
WITHOUT_CLASSIFICATION	 the following two lines were added ensure that thisparams not null which can happen with twodeep nested subqueries 
WITHOUT_CLASSIFICATION	 set the attributes the property reference expression 
WITHOUT_CLASSIFICATION	 the current batch number the latest batch for this entity type 
WITHOUT_CLASSIFICATION	 take snapshot 
WITHOUT_CLASSIFICATION	 can inner join superclass tables the row must there can never inner join subclass tables 
WITHOUT_CLASSIFICATION	 never evict this node 
WITHOUT_CLASSIFICATION	 does the collection referenced this fromelement specify orderby attribute attach the querys orderby 
WITHOUT_CLASSIFICATION	 create the join element under the from element 
WITHOUT_CLASSIFICATION	 for merging versioned entities consider the version having been changed only when the two version values are different and the target actually represents database state this second condition special case which allows entity merged during the same transaction though during seperate operation which was originally persistedsaved 
WITHOUT_CLASSIFICATION	 moved here from selectclause jsd 
WITHOUT_CLASSIFICATION	 predetermine and cache the hashcode 
WITHOUT_CLASSIFICATION	 not between notbetween 
WITHOUT_CLASSIFICATION	 make sure the root node for the region exists and has dataversion that never complains 
WITHOUT_CLASSIFICATION	 psclose just close not try return the pool note early exit 
WITHOUT_CLASSIFICATION	 map entitymode tuplizer 
WITHOUT_CLASSIFICATION	 now write the values fields onto the prepared statement 
WITHOUT_CLASSIFICATION	 this virtual property 
WITHOUT_CLASSIFICATION	 the currenttimestamp more accurate but only known supported sql server and later sybase not known support all 
WITHOUT_CLASSIFICATION	 this one needed only for guessentitymode 
WITHOUT_CLASSIFICATION	 will check current level some them are not null sublevels they exist 
WITHOUT_CLASSIFICATION	 build the dynamicmap tuplizer 
WITHOUT_CLASSIFICATION	 pointbase has known variation select for update syntax 
WITHOUT_CLASSIFICATION	 then domj tuplizer domj representation available 
WITHOUT_CLASSIFICATION	 see the entity already bound this session not look the entity identifier and assume that the entity persistent the not unsaved that rely foreign keys keep database integrity 
WITHOUT_CLASSIFICATION	 the work 
WITHOUT_CLASSIFICATION	 its uninitialized proxy cant transient 
WITHOUT_CLASSIFICATION	 weve been here before 
WITHOUT_CLASSIFICATION	 return the can use reset the proxy return result 
WITHOUT_CLASSIFICATION	 return false here most databases not properly support this construct 
WITHOUT_CLASSIFICATION	 put the standard tuplizers into the tuplizer map first 
WITHOUT_CLASSIFICATION	 hit the database after checking the session cache for snapshot 
WITHOUT_CLASSIFICATION	 found ctor but was not publicly accessible try request accessibility 
WITHOUT_CLASSIFICATION	 our parent another dot node meaning are being further dereferenced thus need generate join unless the parent refers the associated entitys because our table would know the 
WITHOUT_CLASSIFICATION	 private final sessionfactory 
WITHOUT_CLASSIFICATION	 search for collections reachability updating their role dont want touch collections reachable from deleted object 
WITHOUT_CLASSIFICATION	 cached for efficiency 
WITHOUT_CLASSIFICATION	 sql server just returns automatically 
WITHOUT_CLASSIFICATION	 thissessionfactory sessionfactory 
WITHOUT_CLASSIFICATION	 table support 
WITHOUT_CLASSIFICATION	 was not embedded the argument just 
WITHOUT_CLASSIFICATION	 have specialized case detached entity from the perspective the merge operation specifically have incoming entity instance which has corresponding entry the current persistence context but registered under different entity instance 
WITHOUT_CLASSIFICATION	 where fragment must empty 
WITHOUT_CLASSIFICATION	 its key changed 
WITHOUT_CLASSIFICATION	 int parameterstart list allparams iterator whereparams allparamssublist parameterstart allparamssize iterator 
WITHOUT_CLASSIFICATION	 miscellaneous support 
WITHOUT_CLASSIFICATION	 will need remove olde entries 
WITHOUT_CLASSIFICATION	 add the current fragment the thetajoins node 
WITHOUT_CLASSIFICATION	 force initialize 
WITHOUT_CLASSIFICATION	 lock doesnt cascade uninitialized collections 
WITHOUT_CLASSIFICATION	 return currentid 
WITHOUT_CLASSIFICATION	 null 
WITHOUT_CLASSIFICATION	 reset the 
WITHOUT_CLASSIFICATION	 persister 
WITHOUT_CLASSIFICATION	 processes everything except index 
WITHOUT_CLASSIFICATION	 uninitialized proxy pointing with this session then when accessed the underlying instance will contained 
WITHOUT_CLASSIFICATION	 reset the version 
WITHOUT_CLASSIFICATION	 note this simply constructs raw sqltoken representing the where fragment and injects this into the tree this works however probably not the best longterm solution some point probably want apply additional grammar properly tokenize this where fragment into constituent parts focused the operators embedded within the fragment 
WITHOUT_CLASSIFICATION	 the default simply not lazy fetch properties for now 
WITHOUT_CLASSIFICATION	 aliases for identifier aliasid skip the entity defines nonid property named 
WITHOUT_CLASSIFICATION	 else its elements changed 
WITHOUT_CLASSIFICATION	 this assumes you will want ignore any update counts 
WITHOUT_CLASSIFICATION	 attributes maintained between flush cycles 
WITHOUT_CLASSIFICATION	 now rebuild the insertions list there batch for each entry the name list 
WITHOUT_CLASSIFICATION	 the original and that original was not flagged dirty then reset the targets dirty flag here after the copy operation one thing careful here bare original collection which case should never ever ever reset the dirty flag the target because simply not know 
WITHOUT_CLASSIFICATION	 persistent state 
WITHOUT_CLASSIFICATION	 allow the collectionsnapshot serialized 
WITHOUT_CLASSIFICATION	 first break down the returns into maps keyed alias that role returns can more easily resolved their owners 
WITHOUT_CLASSIFICATION	 add the second join the one that ends the destination table 
WITHOUT_CLASSIFICATION	 generate array column names the first dimension parallel with the return types array the second dimension the list column names for each type 
WITHOUT_CLASSIFICATION	 attributes used only during flush cycle 
WITHOUT_CLASSIFICATION	 create sqltoken nodes for the columns 
WITHOUT_CLASSIFICATION	 current means the reference that was found during flush 
WITHOUT_CLASSIFICATION	 rdms has known variation select for update syntax 
WITHOUT_CLASSIFICATION	 ignore this row results note the early exit 
WITHOUT_CLASSIFICATION	 add the new node the map that dont create twice 
WITHOUT_CLASSIFICATION	 return 
WITHOUT_CLASSIFICATION	 not final because proxy factory creation can fail 
WITHOUT_CLASSIFICATION	 register the fromelement with the from clause now that have the names and aliases 
WITHOUT_CLASSIFICATION	 superclass entityname 
WITHOUT_CLASSIFICATION	 first allow the actual type control the return value the actual underlying sqltype could actually different 
WITHOUT_CLASSIFICATION	 temporary 
WITHOUT_CLASSIFICATION	 cascadesave collections after the collection owner was saved 
WITHOUT_CLASSIFICATION	 pass along our initial embedded parameter nodes the first generated sql fragment that can handled later for parameter binding 
WITHOUT_CLASSIFICATION	 loaded means the reference that consistent with the current database state 
WITHOUT_CLASSIFICATION	 cache the actual the object not the value the propertyref which might not initialized 
WITHOUT_CLASSIFICATION	 init the aliases after initing the constructornode 
WITHOUT_CLASSIFICATION	 you may still have other resultsets update counts left process here but you cant now the resultset you just got will closed 
WITHOUT_CLASSIFICATION	 multiparam string dialect functions 
WITHOUT_CLASSIFICATION	 during flush navigate the object graph collections and decide what with them 
WITHOUT_CLASSIFICATION	 save operations 
WITHOUT_CLASSIFICATION	 the from element that represents the elements the collection 
WITHOUT_CLASSIFICATION	 legacy behavior with abstract attribute specified 
WITHOUT_CLASSIFICATION	 constructors are always considered scalar results 
WITHOUT_CLASSIFICATION	 get ready start adding nodes 
WITHOUT_CLASSIFICATION	 use the column alias 
WITHOUT_CLASSIFICATION	 collection types 
WITHOUT_CLASSIFICATION	 note that this also true datetime param 
WITHOUT_CLASSIFICATION	 dont need worry about existing version being uninitialized because this block isnt called reentrant load reentrant loads always have lock mode none 
WITHOUT_CLASSIFICATION	 note this affects the return value 
WITHOUT_CLASSIFICATION	 denotes whether any hibernate transaction has registered callback against this jdbccontext only one such callback allowed directly serializing this value causes problems with jdbctransaction really any transaction impl where the callback local the transaction instance itself since that transaction not serialized along with the jdbccontext thus handle that fact here explicitly 
WITHOUT_CLASSIFICATION	 note evict operates locally only does not propogate any other nodes the potential cluster this exactly what needed when destroy here destroy used part the process shutting down sessionfactory thus these removals should not propogated 
WITHOUT_CLASSIFICATION	 generate the inner join the elements need joined the collection they are 
WITHOUT_CLASSIFICATION	 otherwise perform deep equivalence check 
WITHOUT_CLASSIFICATION	 need account for allowable within the variant 
WITHOUT_CLASSIFICATION	 for expected parameter type injection expect that the lhs represents some form property ref and that the children the inlist represent oneormore params 
WITHOUT_CLASSIFICATION	 there where node make one 
WITHOUT_CLASSIFICATION	 found the temp should indicate are the midst processing result set containing eager fetches via join fetch 
WITHOUT_CLASSIFICATION	 add the type the list returned sqlresulttypes 
WITHOUT_CLASSIFICATION	 create one 
WITHOUT_CLASSIFICATION	 persists dont cascade uninitialized collections 
WITHOUT_CLASSIFICATION	 lobs cannot compared 
WITHOUT_CLASSIFICATION	 blobs are ignored merge 
WITHOUT_CLASSIFICATION	 hhh implied joins subselect where clause the destination needs added the destinations from clause not sure this will fix everything but works 
WITHOUT_CLASSIFICATION	 value the entity name 
WITHOUT_CLASSIFICATION	 handle the assumed valid cases the only valid datetime addition synatx one the other datetime but not both 
WITHOUT_CLASSIFICATION	 optimization 
WITHOUT_CLASSIFICATION	 the map batch numbers entityinsertaction lists 
WITHOUT_CLASSIFICATION	 optimization optimization 
WITHOUT_CLASSIFICATION	 dont need worry about any condition the clause here since anything the condition already applied the whole query 
WITHOUT_CLASSIFICATION	 resnapshot 
WITHOUT_CLASSIFICATION	 the difficulty here exactly what update order force the version incremented the 
WITHOUT_CLASSIFICATION	 for convenience save some lookups 
WITHOUT_CLASSIFICATION	 regions can get instantiated the course normal work named query region will created the first time the query executed suspend any ongoing 
WITHOUT_CLASSIFICATION	 note this not updated when properties are fetched lazily 
WITHOUT_CLASSIFICATION	 ident node can represent index expression the ident represents naked property ref note this makes the assumption which currently the case the hqlsql grammar that the ident first resolved itself addrexpr resolve the other option that changes call resolve from here but currently unneeded overhead 
WITHOUT_CLASSIFICATION	 early exit 
WITHOUT_CLASSIFICATION	 public list return collectionaliases public list getcollectionowners return collectionowners public list return public list return public map getaliaspersister return aliaspersister public boolean return public list getpersisters return persisters public map getaliasowneralias return aliasowneralias public list getscalartypes return scalartypes public list return scalarcolumnaliases public list getpropertyresults return propertyresults public list return collectionresults public map getaliasreturn return aliasreturn 
WITHOUT_CLASSIFICATION	 this solution would allow eliminate the owner arg disassemble but what the collection was null and then later had elements added seems unsafe value getkey 
WITHOUT_CLASSIFICATION	 xml the entity name 
WITHOUT_CLASSIFICATION	 named query parameter 
WITHOUT_CLASSIFICATION	 tolerates nulls 
WITHOUT_CLASSIFICATION	 check see our proppath actually represents property the persister 
WITHOUT_CLASSIFICATION	 add the token the ast 
WITHOUT_CLASSIFICATION	 use the table fromelement and the property name get the array column names 
WITHOUT_CLASSIFICATION	 set the cache factory 
WITHOUT_CLASSIFICATION	 need strip off the embedded parens that sqlgen does not double these 
WITHOUT_CLASSIFICATION	 memory optimization 
WITHOUT_CLASSIFICATION	 sqlresulttypelist 
WITHOUT_CLASSIFICATION	 this implied join from element then use the impled join type which part the tree parsers state set the gramamar actions 
WITHOUT_CLASSIFICATION	 metatype assumed singlecolumn type 
WITHOUT_CLASSIFICATION	 end unit work 
WITHOUT_CLASSIFICATION	 row 
WITHOUT_CLASSIFICATION	 multitables 
WITHOUT_CLASSIFICATION	 final list extendsqueue 
WITHOUT_CLASSIFICATION	 make sure jbc doesnt look one 
WITHOUT_CLASSIFICATION	 get all the select expressions that just generated and render the select 
WITHOUT_CLASSIFICATION	 visit widthfirst then depth 
WITHOUT_CLASSIFICATION	 the uresolved property path isnt set yet just use the property name 
WITHOUT_CLASSIFICATION	 look through the fromelements children find any collections values that should fetched 
WITHOUT_CLASSIFICATION	 return this better but causes transient object exception 
WITHOUT_CLASSIFICATION	 collections values 
WITHOUT_CLASSIFICATION	 copied from session 
WITHOUT_CLASSIFICATION	 for explicit manytomany relationship add second join from the intermediate manytomany table the destination table also make sure that the from elements idea the destination the destination table 
WITHOUT_CLASSIFICATION	 this should not happen since the dtd prevents 
WITHOUT_CLASSIFICATION	 need parse off the column qualifiers this assuming which true now that this only used from update and delete hql statement parsing 
WITHOUT_CLASSIFICATION	 the current join represents the join between manytomany association table and its target table here need apply any additional filters defined specifically the manytomany 
WITHOUT_CLASSIFICATION	 the from element represents joinfragment and thetastyle join convert its type from joinfragment fromfragment 
WITHOUT_CLASSIFICATION	 check basic level one nullablilty 
WITHOUT_CLASSIFICATION	 add zero quite low timeout option dont block ignore any timeoutexception basically forego caching the query result order avoid blocking reads are done with suspended they should not hold the lock for long not caching the query result since any subsequent read will just see the old result with its outofdate timestamp that result will discarded and the query performed again 
WITHOUT_CLASSIFICATION	 values not null and checkable well look deeper 
WITHOUT_CLASSIFICATION	 possibly handle something parameters for the query 
WITHOUT_CLASSIFICATION	 for non null args check for components and elements containing components 
WITHOUT_CLASSIFICATION	 want handle bidirectional and detached also need load this collection with eager outerjoin fetch this time with criteria and not hql 
WITHOUT_CLASSIFICATION	 cache the hashcode 
WITHOUT_CLASSIFICATION	 public propertyprojection project return 
WITHOUT_CLASSIFICATION	 persistent collections may have components 
WITHOUT_CLASSIFICATION	 have the jbcwritemutex other local thread will trying write this key its possible here some remote thread has come and changed the values again but since are reading the values write jbc right now know are writing the latest values dont assume that what cached entryupdate above what should write jbc now our write could redundant are writing what some remote thread just came wrote there chance that yet another remote thread will update and well then overwrite that later data jbc but all remote nodes will ignore that change their localcache the only place will live will jbc where can only effect the initial state transfer values newly joined nodes populatelocalcache 
WITHOUT_CLASSIFICATION	 test out the optimizer 
WITHOUT_CLASSIFICATION	 registercolumntype typesvarchar mediumtext 
WITHOUT_CLASSIFICATION	 ident might the name class 
WITHOUT_CLASSIFICATION	 here dont want suspend the might caching query results that reflect uncommitted changes cache node other threads can prematurely see those query results immediate replication more overhead plus spread issue above around the cluster 
WITHOUT_CLASSIFICATION	 todo 
WITHOUT_CLASSIFICATION	 for regression testing against output from the old parser found easiest simply reorder the fromelements here into ascending order terms injecting them into the resulting sql ast orders relative those expected the old parser this definitely another those only needed for regression purposes the syntheticandfactory then simply injects them encounters them 
WITHOUT_CLASSIFICATION	 stsettimestamp index new timestamp calgettimeinmillis cal jdk only 
WITHOUT_CLASSIFICATION	 arbitrary clause ignored 
WITHOUT_CLASSIFICATION	 stsetdate index new date calgettimeinmillis cal jdk only 
WITHOUT_CLASSIFICATION	 from 
WITHOUT_CLASSIFICATION	 both are timestamps 
WITHOUT_CLASSIFICATION	 first collect all the select expressions note this must done before invoking setscalarcolumntext because setscalarcolumntext changes the ast 
WITHOUT_CLASSIFICATION	 least one plain old date 
WITHOUT_CLASSIFICATION	 swallow the transaction was successful successfully rolled back 
WITHOUT_CLASSIFICATION	 check for all components values the collection 
WITHOUT_CLASSIFICATION	 after all persisters and named queries are registered 
WITHOUT_CLASSIFICATION	 the test 
WITHOUT_CLASSIFICATION	 limit support ala top 
WITHOUT_CLASSIFICATION	 close called guarantee unbind 
WITHOUT_CLASSIFICATION	 byte text money 
WITHOUT_CLASSIFICATION	 noop 
WITHOUT_CLASSIFICATION	 implied 
WITHOUT_CLASSIFICATION	 the corresponding sql value null the reader got null well 
WITHOUT_CLASSIFICATION	 there data type for this node and were the end the path top most dot node then this might java constant 
WITHOUT_CLASSIFICATION	 fetch reader content the end and put characters stringbuffer 
WITHOUT_CLASSIFICATION	 return stringbuffer content large string 
WITHOUT_CLASSIFICATION	 the where clause was added eliminate this statement from brute force searches 
WITHOUT_CLASSIFICATION	 typeslongvarchar 
WITHOUT_CLASSIFICATION	 todo 
WITHOUT_CLASSIFICATION	 ignore minimalputoverride jbosscache putforexternalread already about minimal can get will promptly return discovers that the node want write already exists 
WITHOUT_CLASSIFICATION	 forcefully remove leading ands from where fragments the grammar will handle adding them 
WITHOUT_CLASSIFICATION	 for nonarrays dont need know the element class 
WITHOUT_CLASSIFICATION	 grab its state from the resultset and keep the session but dont yet initialize the object itself note that acquire lockmoderead even was not requested 
WITHOUT_CLASSIFICATION	 different nullability rules for pkfk 
WITHOUT_CLASSIFICATION	 the types report logical equivalence return true 
WITHOUT_CLASSIFICATION	 cache this 
WITHOUT_CLASSIFICATION	 for subquery the alias use depends few things already know this not overall select this fromelement represents correlation the outermost query the outer query represents multitable persister need use the given alias anticipation one the multitable executors being used this subquery will actually used the select phase that multitable executor otherwise need use the persisters table name the column qualification otherwise not correlated use the given alias 
WITHOUT_CLASSIFICATION	 only really need new array during semiresolve 
WITHOUT_CLASSIFICATION	 classic translator does not support collection ordinal param metadata 
WITHOUT_CLASSIFICATION	 unwrap 
WITHOUT_CLASSIFICATION	 unfetched association can only point entity that already exists the 
WITHOUT_CLASSIFICATION	 here work under the following assumptions valid cases datetime something other than datetime always results datetime will catch invalid conversions datetime datetime always results double datetime something other than datetime always results datetime will catch invalid conversions invalid cases datetime datetime something other than datetime datetime datetime any type datetime any type any type datetime doing allows properly handle parameters either the left right side here the majority cases 
WITHOUT_CLASSIFICATION	 let the interceptor inspect the instance decide 
WITHOUT_CLASSIFICATION	 the types represented the sql result set return the types represented the sql result set 
WITHOUT_CLASSIFICATION	 let the persister inspect the instance decide 
WITHOUT_CLASSIFICATION	 the cascadingaction contract 
WITHOUT_CLASSIFICATION	 todo 
WITHOUT_CLASSIFICATION	 create new filters node parent all filters 
WITHOUT_CLASSIFICATION	 there configured will not able access the object order register synch anyway 
WITHOUT_CLASSIFICATION	 establish the region root node with nonlocking data version 
WITHOUT_CLASSIFICATION	 public object instantiateobject parent sessionimplementor session throws hibernateexception 
WITHOUT_CLASSIFICATION	 nothing 
WITHOUT_CLASSIFICATION	 use the assumed value there one avoid hitting the database 
WITHOUT_CLASSIFICATION	 returns null explicitly the entity not associated with the persistence context make some deeper checks 
WITHOUT_CLASSIFICATION	 int count 
WITHOUT_CLASSIFICATION	 putfield new value the field 
WITHOUT_CLASSIFICATION	 not really necessary guess 
WITHOUT_CLASSIFICATION	 clobs are ignored merge operation 
WITHOUT_CLASSIFICATION	 the first key found after the given key 
WITHOUT_CLASSIFICATION	 collections cannot compared 
WITHOUT_CLASSIFICATION	 remember the value 
WITHOUT_CLASSIFICATION	 collectionname 
WITHOUT_CLASSIFICATION	 must use the remembered value since not available from the entityentry during assembly 
WITHOUT_CLASSIFICATION	 collections dont dirty unversioned parent entity 
WITHOUT_CLASSIFICATION	 return false 
WITHOUT_CLASSIFICATION	 this just handles particular case component projection perhaps get rid and throw exception 
WITHOUT_CLASSIFICATION	 note avoid joining the next table the named property just the foreign key value 
WITHOUT_CLASSIFICATION	 the key the owning entity itself get the from the key 
WITHOUT_CLASSIFICATION	 checkforend false 
WITHOUT_CLASSIFICATION	 ignore subselect keywords 
WITHOUT_CLASSIFICATION	 copy elements into newly empty target collection 
WITHOUT_CLASSIFICATION	 end array start filling again from start 
WITHOUT_CLASSIFICATION	 for null target target which the same the original need put the merged elements new collection 
WITHOUT_CLASSIFICATION	 ran out keys try 
WITHOUT_CLASSIFICATION	 default just use unanticipated capacity since dont know how extract the capacity use from original here 
WITHOUT_CLASSIFICATION	 the first found after the given 
WITHOUT_CLASSIFICATION	 ran out ids try 
WITHOUT_CLASSIFICATION	 get the elements back into the target making sure handle dirty flag 
WITHOUT_CLASSIFICATION	 check collection currently being loaded 
WITHOUT_CLASSIFICATION	 check already completely loaded but unowned 
WITHOUT_CLASSIFICATION	 initialize this collection 
WITHOUT_CLASSIFICATION	 create new collection wrapper initialized later 
WITHOUT_CLASSIFICATION	 some jdbc drivers erroneously return empty array here for null value 
WITHOUT_CLASSIFICATION	 cannot batch fetch unique key propertyref associations 
WITHOUT_CLASSIFICATION	 already know current not null 
WITHOUT_CLASSIFICATION	 the owner the association not the owner the 
WITHOUT_CLASSIFICATION	 constructors 
WITHOUT_CLASSIFICATION	 instance variables 
WITHOUT_CLASSIFICATION	 public methods 
WITHOUT_CLASSIFICATION	 compare the two maps for equality 
WITHOUT_CLASSIFICATION	 simple tests that require synchronization 
WITHOUT_CLASSIFICATION	 sybase fail dont that sigh 
WITHOUT_CLASSIFICATION	 stream closed the finally 
WITHOUT_CLASSIFICATION	 release the jdk internal caches everytime ensure this plays nicely with destroyable classloaders 
WITHOUT_CLASSIFICATION	 try pretty print 
WITHOUT_CLASSIFICATION	 otherwise just dump 
WITHOUT_CLASSIFICATION	 its interface cant really tell anything 
WITHOUT_CLASSIFICATION	 use default behavior 
WITHOUT_CLASSIFICATION	 note early return 
WITHOUT_CLASSIFICATION	 want able just use the defaults jndi environment properties are not supplied dont put null anywhere 
WITHOUT_CLASSIFICATION	 clone 
WITHOUT_CLASSIFICATION	 serialize 
WITHOUT_CLASSIFICATION	 warning can cause recursive calls proxy initialization 
WITHOUT_CLASSIFICATION	 static methods only hide constructor 
WITHOUT_CLASSIFICATION	 character 
WITHOUT_CLASSIFICATION	 returnign null 
WITHOUT_CLASSIFICATION	 includes last 
WITHOUT_CLASSIFICATION	 include the following 
WITHOUT_CLASSIFICATION	 first time find match 
WITHOUT_CLASSIFICATION	 entitynames may now include slashes for the representations classname may inner class 
WITHOUT_CLASSIFICATION	 wrapped iterators 
WITHOUT_CLASSIFICATION	 index current iterator the wrapped iterators array 
WITHOUT_CLASSIFICATION	 the current iterator 
WITHOUT_CLASSIFICATION	 the last used iterator 
WITHOUT_CLASSIFICATION	 was boolean expression 
WITHOUT_CLASSIFICATION	 call this before any iterator method make sure that the current iterator not exhausted 
WITHOUT_CLASSIFICATION	 doable needed 
WITHOUT_CLASSIFICATION	 set last used iterator here case the user calls remove before calling hasnext next although they shouldnt 
WITHOUT_CLASSIFICATION	 peek ahead 
WITHOUT_CLASSIFICATION	 reach the end the string finding the matching end that exception 
WITHOUT_CLASSIFICATION	 there were queued additions and the role has cache 
WITHOUT_CLASSIFICATION	 print page 
WITHOUT_CLASSIFICATION	 and this not forced initialization during flush 
WITHOUT_CLASSIFICATION	 have placeholder spin forward till find the end 
WITHOUT_CLASSIFICATION	 make sure spinning forward did not put past the end the buffer 
WITHOUT_CLASSIFICATION	 first try locate this resource through the current context classloader 
WITHOUT_CLASSIFICATION	 next try locate this resource through this classs classloader 
WITHOUT_CLASSIFICATION	 next try locate this resource through the system classloader 
WITHOUT_CLASSIFICATION	 anywhere else should look 
WITHOUT_CLASSIFICATION	 would need identityset for this 
WITHOUT_CLASSIFICATION	 arraysaslist doesnt primitive arrays 
WITHOUT_CLASSIFICATION	 aload 
WITHOUT_CLASSIFICATION	 faster 
WITHOUT_CLASSIFICATION	 pass the entityname not collectionid 
WITHOUT_CLASSIFICATION	 right represents joins originating from left both right and left reprersent joins originating from the same fromelement 
WITHOUT_CLASSIFICATION	 the name class 
WITHOUT_CLASSIFICATION	 its the listener class name 
WITHOUT_CLASSIFICATION	 allow 
WITHOUT_CLASSIFICATION	 default element set elements specified 
WITHOUT_CLASSIFICATION	 look for the instance uuid 
WITHOUT_CLASSIFICATION	 first lets determine whether apply cglib javassist based instrumentation 
WITHOUT_CLASSIFICATION	 make sure dont override previous set values 
WITHOUT_CLASSIFICATION	 entirely optional 
WITHOUT_CLASSIFICATION	 its the listener instance better 
WITHOUT_CLASSIFICATION	 readresolveobject 
WITHOUT_CLASSIFICATION	 true 
WITHOUT_CLASSIFICATION	 defensive convenience methods 
WITHOUT_CLASSIFICATION	 make sure you log the exception might swallowed 
WITHOUT_CLASSIFICATION	 begin unit work 
WITHOUT_CLASSIFICATION	 write html header 
WITHOUT_CLASSIFICATION	 handle actions 
WITHOUT_CLASSIFICATION	 start the session used for this request 
WITHOUT_CLASSIFICATION	 cleanup code 
WITHOUT_CLASSIFICATION	 make the session available the session factorys current context 
WITHOUT_CLASSIFICATION	 remove session from current context 
WITHOUT_CLASSIFICATION	 eager fetch the collection can use detached 
WITHOUT_CLASSIFICATION	 event anevent event session fetchmodejoin add expressioneqid eventid uniqueresult eager fetch the colleciton can use detached 
WITHOUT_CLASSIFICATION	 end first unit work 
WITHOUT_CLASSIFICATION	 bidirectional safety method setting both sides 
WITHOUT_CLASSIFICATION	 begin second unit work 
WITHOUT_CLASSIFICATION	 reattachment aperson 
WITHOUT_CLASSIFICATION	 the getemailaddresses might trigger lazy load the collection 
WITHOUT_CLASSIFICATION	 need our get now and avoid doing other work there problem 
WITHOUT_CLASSIFICATION	 jbc put version the node when created part some internal operation are always newer but the jbc version something odd has happened 
WITHOUT_CLASSIFICATION	 not null the isolation level has been specified the configuration file otherwise left the drivers default value 
WITHOUT_CLASSIFICATION	 configured outside hibernate servlet container java bean container already has proxool pools running and this provider just borrow one these 
WITHOUT_CLASSIFICATION	 loading collection xrefs 
WITHOUT_CLASSIFICATION	 collection load contexts 
WITHOUT_CLASSIFICATION	 the cache the actual plans 
WITHOUT_CLASSIFICATION	 always optional for consistency with sqloql 
WITHOUT_CLASSIFICATION	 process the new hql style where aliases are assigned after the class name path expression using the construction 
WITHOUT_CLASSIFICATION	 primitive type invokespecial 
WITHOUT_CLASSIFICATION	 start performing the updates 
WITHOUT_CLASSIFICATION	 array primitive type nothing 
WITHOUT_CLASSIFICATION	 jdbc params are based 
WITHOUT_CLASSIFICATION	 dont care 
WITHOUT_CLASSIFICATION	 the inverse makes sense that bound session then gets deserialized ahead and rebind the session map 
WITHOUT_CLASSIFICATION	 recognition code 
WITHOUT_CLASSIFICATION	 handle path expression class name that appears the start the new hql style alias that appears the start the old hql style 
WITHOUT_CLASSIFICATION	 important reuse the same event instances for performance 
WITHOUT_CLASSIFICATION	 dont care about other param types here just those explicitly userdefined 
WITHOUT_CLASSIFICATION	 handle not not between not 
WITHOUT_CLASSIFICATION	 named parameter 
WITHOUT_CLASSIFICATION	 could either ordinal jpapositional parameter 
WITHOUT_CLASSIFICATION	 strip the where 
WITHOUT_CLASSIFICATION	 peek ahead showed this jpapositional parameter 
WITHOUT_CLASSIFICATION	 make sure this name integral 
WITHOUT_CLASSIFICATION	 the very least cleanup the data 
WITHOUT_CLASSIFICATION	 seconds 
WITHOUT_CLASSIFICATION	 cannot instantiated 
WITHOUT_CLASSIFICATION	 transfer explicitly defined entity name handle the lazy attribute 
WITHOUT_CLASSIFICATION	 keep the behavior consistent even for boundary usages 
WITHOUT_CLASSIFICATION	 perform the actual work 
WITHOUT_CLASSIFICATION	 the failfast put outside the scope the jta txn 
WITHOUT_CLASSIFICATION	 get metas from joinedsubclass 
WITHOUT_CLASSIFICATION	 ignore 
WITHOUT_CLASSIFICATION	 parameters the property mapping should override parameters the typedef 
WITHOUT_CLASSIFICATION	 note special case default join and nonlazy for the second join the manytomany 
WITHOUT_CLASSIFICATION	 create the node initially with the param name that shows appropriately the original text attribute 
WITHOUT_CLASSIFICATION	 dynamic insert 
WITHOUT_CLASSIFICATION	 clock over the first invocation 
WITHOUT_CLASSIFICATION	 state 
WITHOUT_CLASSIFICATION	 finally handle the exception 
WITHOUT_CLASSIFICATION	 detached collection that belonged different entity 
WITHOUT_CLASSIFICATION	 void 
WITHOUT_CLASSIFICATION	 element index 
WITHOUT_CLASSIFICATION	 note that might better iterate the snapshot but this safe assuming the user implements equals properly required the set contract 
WITHOUT_CLASSIFICATION	 collections detect changes made via their public interface and mark themselves dirty performance optimization 
WITHOUT_CLASSIFICATION	 saveorupdatecopy deprecated 
WITHOUT_CLASSIFICATION	 set 
WITHOUT_CLASSIFICATION	 collectionpersister should not null but dont want throw exception null 
WITHOUT_CLASSIFICATION	 case multi token keywords group and order the next token should otherwise this just ident 
WITHOUT_CLASSIFICATION	 the default for all dialects based sqlstate since sqlerrorcode extremely vendorspecific specific dialects may override return whatever most appropriate for that vendor 
WITHOUT_CLASSIFICATION	 only necessary for postgre 
WITHOUT_CLASSIFICATION	 otherwise null brand new collection this will also inefficiently handle arrays which have snapshot cant any better type 
WITHOUT_CLASSIFICATION	 detached collection that originally belonged the same entity 
WITHOUT_CLASSIFICATION	 add the comment nest the main query outer select add the rownnumber bit into the outer query select list 
WITHOUT_CLASSIFICATION	 you may still have other resultsets update counts left process here but you cant now the resultset you just got will closed 
WITHOUT_CLASSIFICATION	 note for object sql datatype mappings see configuration manager advanced sql system ddl datatype mappings tbd binary changed jsl 
WITHOUT_CLASSIFICATION	 see the second lookahed token can identifier 
WITHOUT_CLASSIFICATION	 case the current token after from and before 
WITHOUT_CLASSIFICATION	 trimendkeyword stringexpression from stringexpression use hibernate implementation from one the parameters they pass position registerfunction trim new trim from 
WITHOUT_CLASSIFICATION	 whether this dialect has identity clause added the data type completely seperate identity data type 
WITHOUT_CLASSIFICATION	 null isnull 
WITHOUT_CLASSIFICATION	 create nodes that track line and column number 
WITHOUT_CLASSIFICATION	 add not its negated 
WITHOUT_CLASSIFICATION	 null isnull 
WITHOUT_CLASSIFICATION	 the path ast should dotnode and should have been evaluated already 
WITHOUT_CLASSIFICATION	 force substitution 
WITHOUT_CLASSIFICATION	 otherwise handle the error normally 
WITHOUT_CLASSIFICATION	 the database now holds lock the object flushed from the cache release the soft lock 
WITHOUT_CLASSIFICATION	 now update the object has outside the main block above because collections 
WITHOUT_CLASSIFICATION	 named queries 
WITHOUT_CLASSIFICATION	 this situation where the entity assigned postinsert generator and was saved outside the transaction forcing delayed 
WITHOUT_CLASSIFICATION	 grab its state saved deletion 
WITHOUT_CLASSIFICATION	 grab its current state 
WITHOUT_CLASSIFICATION	 this will throw error theres something wrong 
WITHOUT_CLASSIFICATION	 collection deletions are special case since update can add deletions collections not loaded the session 
WITHOUT_CLASSIFICATION	 the naturalid marked nonmutable not retrieved during normal databasesnapshot operation 
WITHOUT_CLASSIFICATION	 watch out for case where old still referenced somewhere the object graph which user error 
WITHOUT_CLASSIFICATION	 slice get the columns for this component property 
WITHOUT_CLASSIFICATION	 schedule the update note that intentionally not pass 
WITHOUT_CLASSIFICATION	 substitutes into values sideeffect 
WITHOUT_CLASSIFICATION	 give the interceptor chance process property values the properties were modified the interceptor need set them back the object 
WITHOUT_CLASSIFICATION	 not 
WITHOUT_CLASSIFICATION	 compare cached state ignoring collections unless versioned 
WITHOUT_CLASSIFICATION	 was dirtied collection only 
WITHOUT_CLASSIFICATION	 check nullability but not perform command execute well use scheduled updates for that 
WITHOUT_CLASSIFICATION	 this dot expression now refers the resulting from element 
WITHOUT_CLASSIFICATION	 not like notlike 
WITHOUT_CLASSIFICATION	 the stuff just detect any silly users who set circular shared references betweento collections 
WITHOUT_CLASSIFICATION	 detached collection wrappers that get found reattached during flush shouldnt ignored 
WITHOUT_CLASSIFICATION	 not isnotnull isnull 
WITHOUT_CLASSIFICATION	 the unique property value represented here may may not serializable explicit check here order generate better error message 
WITHOUT_CLASSIFICATION	 the version newly instantiated object not the same the version seed value use that the unsavedvalue 
WITHOUT_CLASSIFICATION	 never have null out reference uninitialized proxy 
WITHOUT_CLASSIFICATION	 not notlike like 
WITHOUT_CLASSIFICATION	 give the interceptor chance modify property values 
WITHOUT_CLASSIFICATION	 now might need recalculate the dirtyproperties array 
WITHOUT_CLASSIFICATION	 use the current version 
WITHOUT_CLASSIFICATION	 object loaded update 
WITHOUT_CLASSIFICATION	 ignore this row the collection process being loaded somewhere further the stack 
WITHOUT_CLASSIFICATION	 entity load contexts currently not yet used 
WITHOUT_CLASSIFICATION	 dirty check against the usual snapshot the entity 
WITHOUT_CLASSIFICATION	 this implementation supposed tolerate incorrect unsavedvalue mappings for the purpose 
WITHOUT_CLASSIFICATION	 wrap any new collections directly referenced the object its components 
WITHOUT_CLASSIFICATION	 skip this check for compositeids relating domj entitymode alternatively could add check make sure the incoming value instance element 
WITHOUT_CLASSIFICATION	 upgrade the lock necessary lockresult lockmode 
WITHOUT_CLASSIFICATION	 now any collections that are initialized inside this block not get updated they are ignored until the next flush 
WITHOUT_CLASSIFICATION	 not 
WITHOUT_CLASSIFICATION	 must clone embedded composite identifiers will get back the same instance that pass 
WITHOUT_CLASSIFICATION	 subinsertions should occur before containing insertion try the callback now 
WITHOUT_CLASSIFICATION	 not 
WITHOUT_CLASSIFICATION	 not 
WITHOUT_CLASSIFICATION	 not 
WITHOUT_CLASSIFICATION	 the entity not associated with the session try interceptor and unsavedvalue 
WITHOUT_CLASSIFICATION	 and the expected token type was identifier then 
WITHOUT_CLASSIFICATION	 igndore 
WITHOUT_CLASSIFICATION	 jsd the fix for hhh 
WITHOUT_CLASSIFICATION	 the token can tell could identifier 
WITHOUT_CLASSIFICATION	 are now new tree level 
WITHOUT_CLASSIFICATION	 dirty check against the database snapshot possiblenecessary 
WITHOUT_CLASSIFICATION	 the interceptor handled the dirty checking 
WITHOUT_CLASSIFICATION	 use the delegate 
WITHOUT_CLASSIFICATION	 get metas from subclass 
WITHOUT_CLASSIFICATION	 evict operations 
WITHOUT_CLASSIFICATION	 get the from the object 
WITHOUT_CLASSIFICATION	 the put outside the scope the jta txn 
WITHOUT_CLASSIFICATION	 what the version the database 
WITHOUT_CLASSIFICATION	 hhh 
WITHOUT_CLASSIFICATION	 will result sql update 
WITHOUT_CLASSIFICATION	 else nothing dont even reassociate object 
WITHOUT_CLASSIFICATION	 existing row insert 
WITHOUT_CLASSIFICATION	 inner classes moved here from sqlgeng 
WITHOUT_CLASSIFICATION	 reference type 
WITHOUT_CLASSIFICATION	 should the first but just safe 
WITHOUT_CLASSIFICATION	 return proxy appropriate 
WITHOUT_CLASSIFICATION	 some filters affecting the collection are enabled the session not the put into the cache 
WITHOUT_CLASSIFICATION	 generate explicit join for the root dot node the implied joins will collected and passed the root dot node 
WITHOUT_CLASSIFICATION	 session considered contain entity only the entity has entry the sessions persistence context and the entry reports that the entity has not been removed 
WITHOUT_CLASSIFICATION	 and the token could identifer and the error mismatched token error 
WITHOUT_CLASSIFICATION	 where clause was specified the updatedelete query use limit the returned ids here 
WITHOUT_CLASSIFICATION	 default implementation this node has data type and that data type not association then this scalar 
WITHOUT_CLASSIFICATION	 resolve the lhs fully generate implicit joins pass the property name that the resolver can discover foreign key properties 
WITHOUT_CLASSIFICATION	 the propertytype null and there isnt parent just stop now there was problem resolving the node anyway 
WITHOUT_CLASSIFICATION	 not look for existing join the same path because makes sense join twice the same collection role 
WITHOUT_CLASSIFICATION	 return new uninitialized proxy 
WITHOUT_CLASSIFICATION	 this object was already loaded 
WITHOUT_CLASSIFICATION	 entity was found secondlevel cache 
WITHOUT_CLASSIFICATION	 intializes result sideeffect 
WITHOUT_CLASSIFICATION	 note max because first zerobased while max not 
WITHOUT_CLASSIFICATION	 shallow query although technically there should fetching here 
WITHOUT_CLASSIFICATION	 delegate the queryloader 
WITHOUT_CLASSIFICATION	 remember the parameters for the compilation 
WITHOUT_CLASSIFICATION	 package local methods for the queryloader delegate 
WITHOUT_CLASSIFICATION	 double 
WITHOUT_CLASSIFICATION	 now done entity sourcegetentitymode 
WITHOUT_CLASSIFICATION	 use the token identifier 
WITHOUT_CLASSIFICATION	 some statistics 
WITHOUT_CLASSIFICATION	 safe from concurrent modification because how entrylist implemented identitymap 
WITHOUT_CLASSIFICATION	 transform the tree 
WITHOUT_CLASSIFICATION	 parse the query string into hql ast 
WITHOUT_CLASSIFICATION	 not actually propogate antlrexceptions cause log here for diagnostic purposes 
WITHOUT_CLASSIFICATION	 this needs safe from concurrent modification problems safe because how identitymap implements entryset 
WITHOUT_CLASSIFICATION	 only needed during compilation phase 
WITHOUT_CLASSIFICATION	 update the status the object and necessary schedule update 
WITHOUT_CLASSIFICATION	 schedule updates collections 
WITHOUT_CLASSIFICATION	 need lock the collection caches before executing entity insertsupdates order account for bidi associations 
WITHOUT_CLASSIFICATION	 the database has changed now the subselect results need invalidated 
WITHOUT_CLASSIFICATION	 the collection dereferenced remove from the session cache iterremove does not work since the entryset not backed the set 
WITHOUT_CLASSIFICATION	 phase parse the hql into ast 
WITHOUT_CLASSIFICATION	 key entity involved with the operation performed the listener value flag indicating the listener explicitly operates the entity 
WITHOUT_CLASSIFICATION	 get snapshot 
WITHOUT_CLASSIFICATION	 public final currency getcurrencyint col throws hibernateexception return currency getcol 
WITHOUT_CLASSIFICATION	 right represents joins originating from left 
WITHOUT_CLASSIFICATION	 the query already compiled skip the compilation 
WITHOUT_CLASSIFICATION	 remember that ordinal parameters numbers are based 
WITHOUT_CLASSIFICATION	 all clear 
WITHOUT_CLASSIFICATION	 ignore the token class name parameter and use specific token class 
WITHOUT_CLASSIFICATION	 this query and are loading multiple instances the same collection role 
WITHOUT_CLASSIFICATION	 early exit 
WITHOUT_CLASSIFICATION	 before any callbacks etc subdeletions see that this deletion happened first 
WITHOUT_CLASSIFICATION	 ensures that containing deletions happen before subdeletions 
WITHOUT_CLASSIFICATION	 cascadedelete collections before the collection owner deleted 
WITHOUT_CLASSIFICATION	 cascadedelete manytoone after the parent was deleted 
WITHOUT_CLASSIFICATION	 initialized proxy let cascade handle later 
WITHOUT_CLASSIFICATION	 assign the requested the proxy before reassociating the proxy 
WITHOUT_CLASSIFICATION	 uninitialized proxy noop dont even need return since never save 
WITHOUT_CLASSIFICATION	 initialize properties the event 
WITHOUT_CLASSIFICATION	 return the the event object 
WITHOUT_CLASSIFICATION	 transient deleted 
WITHOUT_CLASSIFICATION	 assume this newly instantiated transient object which should saved rather than updated 
WITHOUT_CLASSIFICATION	 this transient object with existing persistent state not loaded the session 
WITHOUT_CLASSIFICATION	 check two adjecent nodes the top the fromclause tree 
WITHOUT_CLASSIFICATION	 cachedstate 
WITHOUT_CLASSIFICATION	 detached collection 
WITHOUT_CLASSIFICATION	 the collection belonged different entity clean the existing state the collection 
WITHOUT_CLASSIFICATION	 logdebug calling onload 
WITHOUT_CLASSIFICATION	 note performexecutions clears all collectionxxxxtion collections the collection actions the session 
WITHOUT_CLASSIFICATION	 the entity came from update 
WITHOUT_CLASSIFICATION	 need check even was not initialized because delayed adds 
WITHOUT_CLASSIFICATION	 note early exit 
WITHOUT_CLASSIFICATION	 template null just write the function out appears the hql statement 
WITHOUT_CLASSIFICATION	 semantic action processing 
WITHOUT_CLASSIFICATION	 find any entities that are still transient after retry 
WITHOUT_CLASSIFICATION	 initialize sql nodes here 
WITHOUT_CLASSIFICATION	 check the persistence context for entry relating this entity merged 
WITHOUT_CLASSIFICATION	 deleted 
WITHOUT_CLASSIFICATION	 set the unresolved path this node and the parent set the text for the parent 
WITHOUT_CLASSIFICATION	 second lock timeout 
WITHOUT_CLASSIFICATION	 property prop new property propsetnameid propsetvalueid 
WITHOUT_CLASSIFICATION	 before cascade 
WITHOUT_CLASSIFICATION	 continue well find out ends not getting saved later 
WITHOUT_CLASSIFICATION	 cascade first that all unsaved objects get their copy created before actually copy 
WITHOUT_CLASSIFICATION	 check that entity requestedid 
WITHOUT_CLASSIFICATION	 not collection return the entity property mapping 
WITHOUT_CLASSIFICATION	 collection manytoany mappings used circumvent the componentcollection check below 
WITHOUT_CLASSIFICATION	 otherwise the destination node was implied the from clause and the from clause processor will automatically add the right place 
WITHOUT_CLASSIFICATION	 the first identifier the path referrs the class alias not the class name then this correlated subselect its correlated subselect use the existing table alias otherwise generate new one 
WITHOUT_CLASSIFICATION	 this uses but notice that compound paths are not valid only bare names and simple paths 
WITHOUT_CLASSIFICATION	 add the query spaces 
WITHOUT_CLASSIFICATION	 reset the node type because the rest the system expecting fromfragment all wanted was for the factory create the right subclass this might get reset again later anyway make the sql generation simpler 
WITHOUT_CLASSIFICATION	 explicit true this explict select arraylist sqlresulttypelist new arraylist 
WITHOUT_CLASSIFICATION	 type generate the select expression 
WITHOUT_CLASSIFICATION	 the expression list has exactly one expression and the type the expression collection then this might collection function such indexc sizec 
WITHOUT_CLASSIFICATION	 the uberrule here that need include subclass joins the fromelement any way dereferenced property from the subclass table otherwise end with column references qualified nonexistent table reference the resulting sql 
WITHOUT_CLASSIFICATION	 cascade first that all unsaved objects get their copy created before actually copy 
WITHOUT_CLASSIFICATION	 copyvalues works reflection explicitly mark the entity instance dirty 
WITHOUT_CLASSIFICATION	 the following variables are stacks that keep information about each subexpression the list nested subexpressions are currently processing 
WITHOUT_CLASSIFICATION	 need even collect this information the persister considered multitable 
WITHOUT_CLASSIFICATION	 soon encounter our first letter return the substring from that position 
WITHOUT_CLASSIFICATION	 retrieve the value the designated column the current row this resultset object javaioreader object 
WITHOUT_CLASSIFICATION	 for arrays replaceelements may return different reference since the array length might not match 
WITHOUT_CLASSIFICATION	 should not able reach last without maxposition being set unless there are results 
WITHOUT_CLASSIFICATION	 not use proxiesbykey since not all proxies that point this sessions instances are that collection 
WITHOUT_CLASSIFICATION	 this should call resolve not resolveidentifier cos might propertyref and did not cache the referenced value 
WITHOUT_CLASSIFICATION	 have ttnotfoundignorett association mapped formula always need dirty check can update the secondlevel cache 
WITHOUT_CLASSIFICATION	 now have the value the propertyref reference however need dig little deeper that property might also entity type which case need resolve its identitifier 
WITHOUT_CLASSIFICATION	 true this query and are loading multiple instances the same collection role otherwise this and are loading single collection batch 
WITHOUT_CLASSIFICATION	 persister 
WITHOUT_CLASSIFICATION	 this method should implemented assuming its valid startstopstart leave state appropriate for another start 
WITHOUT_CLASSIFICATION	 dont want waste effort setting option jbc already local mode jbc replasync then check they passed config option disable query replication 
WITHOUT_CLASSIFICATION	 see had invalidation from the same initial preinvalidation timestamp only increment the new current value increase 
WITHOUT_CLASSIFICATION	 the workspace node has null well not weve been modified noncomparable manner which have treat being newer 
WITHOUT_CLASSIFICATION	 maintain correct duplication loaded cartesian product 
WITHOUT_CLASSIFICATION	 datasource unpooled jdbcurl 
WITHOUT_CLASSIFICATION	 shortcircuits new elements the old list contains only orphans old elements orphans neither 
WITHOUT_CLASSIFICATION	 get the updated snapshot the entity state cloning current state safe copy place since this time noone else should have has reference the array 
WITHOUT_CLASSIFICATION	 long 
WITHOUT_CLASSIFICATION	 set the existing pool flag true 
WITHOUT_CLASSIFICATION	 validate that alias name was provided determine which pool use 
WITHOUT_CLASSIFICATION	 have created the pool ourselves shut down 
WITHOUT_CLASSIFICATION	 the load which takes entity does not pass entityname 
WITHOUT_CLASSIFICATION	 note expected the syntax typelistenerclass where sep any whitespace comma 
WITHOUT_CLASSIFICATION	 tree cache optimistic mode seems have very difficult time with remove calls nonexistent nodes npes 
WITHOUT_CLASSIFICATION	 does not refer alias projection look for property 
WITHOUT_CLASSIFICATION	 nothing for persistent instances 
WITHOUT_CLASSIFICATION	 optimisticcache impl 
WITHOUT_CLASSIFICATION	 assume true since dont really know and doesnt matter 
WITHOUT_CLASSIFICATION	 show the modified ast 
WITHOUT_CLASSIFICATION	 note firstrow zerobased 
WITHOUT_CLASSIFICATION	 initialize dirty flags for arrays collections with composite elements and reset reached doupdate etc 
WITHOUT_CLASSIFICATION	 tell the dot node about the join type 
WITHOUT_CLASSIFICATION	 among other things updatereachables will recursively load all collections that are moving roles this might cause entities loaded 
WITHOUT_CLASSIFICATION	 postflushing section 
WITHOUT_CLASSIFICATION	 otherwise recreate the mapping between the collection and its key 
WITHOUT_CLASSIFICATION	 create parameter specification for the collection filter 
WITHOUT_CLASSIFICATION	 attach any mappingdefined order fragments 
WITHOUT_CLASSIFICATION	 found some extends attributes referencing entities which were not already processed here need locate all entitynames and classnames contained this document itself making sure that these get removed from the extendz list such that only extends names which require delay processing external this document and not yet processed are contained the returned result 
WITHOUT_CLASSIFICATION	 make sure that the persister versioned 
WITHOUT_CLASSIFICATION	 for nativesql queries the param metadata determined outside any relation query plan because query plan creation andor retreival for nativesql query depends all the return types having been set which might not the case upfront when param metadata would most useful 
WITHOUT_CLASSIFICATION	 this function has template redirect output and catch the arguments 
WITHOUT_CLASSIFICATION	 use the assigned the instance 
WITHOUT_CLASSIFICATION	 array holder found unwrappered array this cant occur because now always call wrap before getting here return ahnull true type 
WITHOUT_CLASSIFICATION	 collection loaded the current session can not possibly the collection belonging the entity passed update 
WITHOUT_CLASSIFICATION	 the data type not association type could not have been the from clause 
WITHOUT_CLASSIFICATION	 need generate ids part this bulk insert note that this only supported for sequencestyle generators and postinsertstyle generators basically only indb generators 
WITHOUT_CLASSIFICATION	 first look for reference projection alias 
WITHOUT_CLASSIFICATION	 handle trace logging 
WITHOUT_CLASSIFICATION	 there are collection fetches then further checks are needed 
WITHOUT_CLASSIFICATION	 commented out inspection int getwarningcount 
WITHOUT_CLASSIFICATION	 session happens get serialized completely correct need make sure that unbinding that session occurs 
WITHOUT_CLASSIFICATION	 make sure alias applied the table name 
WITHOUT_CLASSIFICATION	 switch 
WITHOUT_CLASSIFICATION	 use the explicitly declared select expression determine the return types indicated each select token 
WITHOUT_CLASSIFICATION	 select clauses for insert statements should alwasy treated shallow 
WITHOUT_CLASSIFICATION	 after that process the joins invoke delegate the work this farily complex 
WITHOUT_CLASSIFICATION	 cache impl 
WITHOUT_CLASSIFICATION	 simple cache param metadata based query string ideally the original usersupplied query string should used retreive this metadata not the paralistexpanded query string avoid unnecessary cache entries used solely for caching param metadata for nativesql queries see for discussion why 
WITHOUT_CLASSIFICATION	 alias references and identifiers use the same node class 
WITHOUT_CLASSIFICATION	 make new one 
WITHOUT_CLASSIFICATION	 these are just two unrelated table references 
WITHOUT_CLASSIFICATION	 again both should fromelements 
WITHOUT_CLASSIFICATION	 check set parentchild nodes the fromclause tree determine comma required between them 
WITHOUT_CLASSIFICATION	 phase analyze the hql ast and produce sql ast 
WITHOUT_CLASSIFICATION	 phase generate the sql 
WITHOUT_CLASSIFICATION	 otherwise have nonscalar select with defined collection fetches make sure that there only single root entity the return tuples 
WITHOUT_CLASSIFICATION	 paramtranslations new 
WITHOUT_CLASSIFICATION	 are already processing dotstructure 
WITHOUT_CLASSIFICATION	 should mean that such property was found 
WITHOUT_CLASSIFICATION	 initialize the error handling delegate 
WITHOUT_CLASSIFICATION	 was there explicit select expression 
WITHOUT_CLASSIFICATION	 resolve everything this dot but dont resolve the placeholders yet 
WITHOUT_CLASSIFICATION	 not notbetween between 
WITHOUT_CLASSIFICATION	 just add not parent 
WITHOUT_CLASSIFICATION	 first save off the pertinent ids the return value 
WITHOUT_CLASSIFICATION	 check see the connection autocommit mode connection means aggressive connection release outside jta transaction context must autocommit mode 
WITHOUT_CLASSIFICATION	 first save off the pertinent ids saving the number pertinent ids for return 
WITHOUT_CLASSIFICATION	 start performing the deletes 
WITHOUT_CLASSIFICATION	 dont forget resolve the argument resolve the collection function now 
WITHOUT_CLASSIFICATION	 otherwise everything 
WITHOUT_CLASSIFICATION	 rearrange the tree that the collection function the root and the lhs the path 
WITHOUT_CLASSIFICATION	 protected regionrootlistener listener 
WITHOUT_CLASSIFICATION	 inject the where after the parent 
WITHOUT_CLASSIFICATION	 never include subclasses for implied from elements 
WITHOUT_CLASSIFICATION	 for pessimistic locking just want toss out our ref any old invalid root node and get the latest may null 
WITHOUT_CLASSIFICATION	 the rest only matters for optimistic locking where need establish the proper data version the region root 
WITHOUT_CLASSIFICATION	 prepare the left hand side and get the data type 
WITHOUT_CLASSIFICATION	 this dot has already been resolved stop now 
WITHOUT_CLASSIFICATION	 the property another class 
WITHOUT_CLASSIFICATION	 otherwise this primitive type 
WITHOUT_CLASSIFICATION	 foobarssize also handles deprecated stuff like foobarsmaxelement for backwardness 
WITHOUT_CLASSIFICATION	 for timestamps default separate config 
WITHOUT_CLASSIFICATION	 optimisticlockall include all updatable properties optimisticlockdirty include all properties are updating this time 
WITHOUT_CLASSIFICATION	 this property belongs the table and not specifically excluded from optimistic locking optimisticlockfalse 
WITHOUT_CLASSIFICATION	 information about properties this class including inherited properties only really needed for updatableinsertable properties 
WITHOUT_CLASSIFICATION	 here render the select column list based the properties defined being generated for partial component generation currently just reselect the whole component rather than trying handle the individual generated portions 
WITHOUT_CLASSIFICATION	 note addduplicatealias already performs nullness checks the alias 
WITHOUT_CLASSIFICATION	 the fromclauses are the same can little more aggressive terms what reuse 
WITHOUT_CLASSIFICATION	 again null null here 
WITHOUT_CLASSIFICATION	 otherwise subquery case dont reuse the fromelement are processing the fromclause the subquery 
WITHOUT_CLASSIFICATION	 know only the lhshand type use that 
WITHOUT_CLASSIFICATION	 the referenced node text the special 
WITHOUT_CLASSIFICATION	 only the identifier property field name can reference the associated entitys 
WITHOUT_CLASSIFICATION	 append the new property name onto the unresolved path 
WITHOUT_CLASSIFICATION	 tell the destination fromelement includesubclasses 
WITHOUT_CLASSIFICATION	 the lhs collection use 
WITHOUT_CLASSIFICATION	 dont resolve the node again 
WITHOUT_CLASSIFICATION	 lists arrays sets maps bags 
WITHOUT_CLASSIFICATION	 have something like rhs 
WITHOUT_CLASSIFICATION	 finish all the removes first take care possible unique constraints and that can take better advantage batching 
WITHOUT_CLASSIFICATION	 use combination foreign key columns and columns since the ordering removal and addition not guaranteed when child moves from one parent another 
WITHOUT_CLASSIFICATION	 make sure dont rerelease the same cache 
WITHOUT_CLASSIFICATION	 use different delegate than the nonoptimistic superclass default 
WITHOUT_CLASSIFICATION	 have something like lhs 
WITHOUT_CLASSIFICATION	 dont create unique key cos some databases dont like nullable columns 
WITHOUT_CLASSIFICATION	 isset collectionisset issorted collectionissorted 
WITHOUT_CLASSIFICATION	 know only the rhshand type use that 
WITHOUT_CLASSIFICATION	 jbc using invalidation dont want propagate changes use the timestamps cache manage invalidation 
WITHOUT_CLASSIFICATION	 dont hold the jbc node lock throughout the that prevents updates add zero low timeout option dont block waiting for txs that did put commit 
WITHOUT_CLASSIFICATION	 double check the distributed cache 
WITHOUT_CLASSIFICATION	 get exclusive right update jbc for this key from this node 
WITHOUT_CLASSIFICATION	 one the other needs datetime for get into this method the first place 
WITHOUT_CLASSIFICATION	 add the condition the join sequence that qualifies the indexed element 
WITHOUT_CLASSIFICATION	 sometimes use the element table alias sometimes use the umm collection table alias many many 
WITHOUT_CLASSIFICATION	 now set the text for this node should the element columns 
WITHOUT_CLASSIFICATION	 get the function return value type based the type the first argument 
WITHOUT_CLASSIFICATION	 this will call initializetok 
WITHOUT_CLASSIFICATION	 mutation depends the types nodes invloved 
WITHOUT_CLASSIFICATION	 logic operators definition resolve booleans 
WITHOUT_CLASSIFICATION	 generated select expressions are already resolved nothing 
WITHOUT_CLASSIFICATION	 the path may reference alias defined the parent query 
WITHOUT_CLASSIFICATION	 the hql class alias refers the class name 
WITHOUT_CLASSIFICATION	 associate the table alias with the element 
WITHOUT_CLASSIFICATION	 try the parent fromclause 
WITHOUT_CLASSIFICATION	 make sure that all from elements registered with this from clause are actually the ast 
WITHOUT_CLASSIFICATION	 invoke setscalarcolumntext each constructor argument 
WITHOUT_CLASSIFICATION	 collect the select expressions skip the first child because the class name 
WITHOUT_CLASSIFICATION	 return empty type array 
WITHOUT_CLASSIFICATION	 ensure async semantics jbcache 
WITHOUT_CLASSIFICATION	 there order make one 
WITHOUT_CLASSIFICATION	 initial load from jbc 
WITHOUT_CLASSIFICATION	 find the where there where find the from 
WITHOUT_CLASSIFICATION	 now inject the newly built order into the tree 
WITHOUT_CLASSIFICATION	 logic operators definition resolve boolean 
WITHOUT_CLASSIFICATION	 render the identifier select fragment using the table alias 
WITHOUT_CLASSIFICATION	 class names the from clause result joinsequence the old fromparser does this 
WITHOUT_CLASSIFICATION	 will still issued when used null 
WITHOUT_CLASSIFICATION	 otherwise use the property mapping 
WITHOUT_CLASSIFICATION	 the standard comparator types are not serializable but are singletons 
WITHOUT_CLASSIFICATION	 ignore 
WITHOUT_CLASSIFICATION	 generate implicit joins only necessary 
WITHOUT_CLASSIFICATION	 the property special collection property name return 
WITHOUT_CLASSIFICATION	 collection components 
WITHOUT_CLASSIFICATION	 construct the cache 
WITHOUT_CLASSIFICATION	 seconds 
WITHOUT_CLASSIFICATION	 need seed the version value part this bulk insert 
WITHOUT_CLASSIFICATION	 make sure the lhs assignable 
WITHOUT_CLASSIFICATION	 false indicates not generate parens around the assignment 
WITHOUT_CLASSIFICATION	 currently allowed 
WITHOUT_CLASSIFICATION	 nonselect queries the only time should need join are subquery from clause 
WITHOUT_CLASSIFICATION	 return classalias null classname classalias 
WITHOUT_CLASSIFICATION	 this explicit from element 
WITHOUT_CLASSIFICATION	 swaldman define cpstyle configuration parameters for initialpoolsize which hibernate sensibly lets default minpoolsize but well let users override with the cpstyle property they want 
WITHOUT_CLASSIFICATION	 fetch cant used with scroll iterate 
WITHOUT_CLASSIFICATION	 its not implied implied and its many many join where the target wasnt found 
WITHOUT_CLASSIFICATION	 need wrtap the param cast 
WITHOUT_CLASSIFICATION	 since this explicit from element cant implied the from clause 
WITHOUT_CLASSIFICATION	 nothing eplicit from elements are always the projection list 
WITHOUT_CLASSIFICATION	 propertyname refers something like collectionsize 
WITHOUT_CLASSIFICATION	 property name subpath component 
WITHOUT_CLASSIFICATION	 notify the from element that being referenced the select 
WITHOUT_CLASSIFICATION	 dotnode uses null here 
WITHOUT_CLASSIFICATION	 represent fromclause alias 
WITHOUT_CLASSIFICATION	 are the rhs the dot representing naked comppropref 
WITHOUT_CLASSIFICATION	 represent naked simple propref 
WITHOUT_CLASSIFICATION	 early exit return the resolve call explicitly coming from dotnode can resolve this 
WITHOUT_CLASSIFICATION	 assume this idents text does not refer property the given persister 
WITHOUT_CLASSIFICATION	 just ignore for now itll get resolved later 
WITHOUT_CLASSIFICATION	 this not actually constant but reference from element 
WITHOUT_CLASSIFICATION	 these pieces are needed for usage select clause 
WITHOUT_CLASSIFICATION	 assume not refer property the given persister 
WITHOUT_CLASSIFICATION	 true the pool borrowed from the outside false used create 
WITHOUT_CLASSIFICATION	 get connection from the pool thru drivermanager cfr proxool doc 
WITHOUT_CLASSIFICATION	 set the transaction isolation defined 
WITHOUT_CLASSIFICATION	 naked propertyrefs cannot used with aliased from element 
WITHOUT_CLASSIFICATION	 not overwrite the column text that has already been rendered during resolve 
WITHOUT_CLASSIFICATION	 look class name using the first identifier the path 
WITHOUT_CLASSIFICATION	 toggle autocommit false set 
WITHOUT_CLASSIFICATION	 add the query spaces 
WITHOUT_CLASSIFICATION	 return the connection 
WITHOUT_CLASSIFICATION	 the from element isnt the same clause create new from element 
WITHOUT_CLASSIFICATION	 correlated subqueries create special implied from nodes because correlated subselects cant use ansistyle join 
WITHOUT_CLASSIFICATION	 get the configurator files available 
WITHOUT_CLASSIFICATION	 collection entities 
WITHOUT_CLASSIFICATION	 collection components 
WITHOUT_CLASSIFICATION	 default the proxool alias setting 
WITHOUT_CLASSIFICATION	 collection scalar elements 
WITHOUT_CLASSIFICATION	 only build caches none were passed passing caches counts clear statement exactly what wanted 
WITHOUT_CLASSIFICATION	 dont include subclasses for implied collection joins subquery joins 
WITHOUT_CLASSIFICATION	 treat explict from elements subqueries properly 
WITHOUT_CLASSIFICATION	 semantic action handling 
WITHOUT_CLASSIFICATION	 append the stem the proxool pool alias 
WITHOUT_CLASSIFICATION	 configured using the jaxp configurator 
WITHOUT_CLASSIFICATION	 configured using the properties file configurator 
WITHOUT_CLASSIFICATION	 remember isolation level 
WITHOUT_CLASSIFICATION	 the provider was leeching off existing pool dont close 
WITHOUT_CLASSIFICATION	 note because were using astutilcreateparent the tree must created from the bottom empty exists query selectfrom from 
WITHOUT_CLASSIFICATION	 the root fromelement correlated subqueries need this piece 
WITHOUT_CLASSIFICATION	 create the from element for the target the elements the collection 
WITHOUT_CLASSIFICATION	 the join implied then dont include subclasses the element 
WITHOUT_CLASSIFICATION	 not really manytoone association necessarily 
WITHOUT_CLASSIFICATION	 the associated entity implied but must included the from the collection alias the role 
WITHOUT_CLASSIFICATION	 always overwrite nonversioned data 
WITHOUT_CLASSIFICATION	 tag this node join dont include subclasses the join this clollection join 
WITHOUT_CLASSIFICATION	 public currency getcurrencyint col throws hibernateexception 
WITHOUT_CLASSIFICATION	 get the class name the associated entity 
WITHOUT_CLASSIFICATION	 default pojo 
WITHOUT_CLASSIFICATION	 use setparameter for null values 
WITHOUT_CLASSIFICATION	 origin path implied columns classalias 
WITHOUT_CLASSIFICATION	 implied 
WITHOUT_CLASSIFICATION	 for implied manytomany just add the end join 
WITHOUT_CLASSIFICATION	 interceptor returned null the dirtycheck ourself possible 
WITHOUT_CLASSIFICATION	 note this 
WITHOUT_CLASSIFICATION	 error message constants 
WITHOUT_CLASSIFICATION	 the standard sql function name currenttimestamp 
WITHOUT_CLASSIFICATION	 scan for next nonwhitespace token 
WITHOUT_CLASSIFICATION	 this causes the factory instantiate the desired class 
WITHOUT_CLASSIFICATION	 private type sqlresulttypes 
WITHOUT_CLASSIFICATION	 private cacheentry cacheentry 
WITHOUT_CLASSIFICATION	 typefactorydeepcopy currentstate proptypes deletedstate session 
WITHOUT_CLASSIFICATION	 frontbase has known variation select for update syntax 
WITHOUT_CLASSIFICATION	 public type getsqlresulttypes return sqlresulttypes 
WITHOUT_CLASSIFICATION	 type 
WITHOUT_CLASSIFICATION	 always add the type the return type list 
WITHOUT_CLASSIFICATION	 have the entity entry perform postupdate processing passing the update state and the new version one 
WITHOUT_CLASSIFICATION	 this entity defines proeprty generation process those generated values 
WITHOUT_CLASSIFICATION	 add the fetched entities 
WITHOUT_CLASSIFICATION	 just especially for the trivial collection filter 
WITHOUT_CLASSIFICATION	 need look from the persistencecontext 
WITHOUT_CLASSIFICATION	 sort first role name 
WITHOUT_CLASSIFICATION	 function support 
WITHOUT_CLASSIFICATION	 update last nonwhitespace token necessary 
WITHOUT_CLASSIFICATION	 then 
WITHOUT_CLASSIFICATION	 nothing 
WITHOUT_CLASSIFICATION	 arraylist sqlresulttypelist 
WITHOUT_CLASSIFICATION	 this method called when new nonnull collection persisted when existing nonnull collection moved new owner 
WITHOUT_CLASSIFICATION	 definitely dont have this 
WITHOUT_CLASSIFICATION	 remove initial 
WITHOUT_CLASSIFICATION	 generate the select expression 
WITHOUT_CLASSIFICATION	 now update all changed added rows fks 
WITHOUT_CLASSIFICATION	 boolean put cacheentry 
WITHOUT_CLASSIFICATION	 union subclass support 
WITHOUT_CLASSIFICATION	 skip distinct and all return the first expression node 
WITHOUT_CLASSIFICATION	 generate the property select tokens 
WITHOUT_CLASSIFICATION	 get the function name node 
WITHOUT_CLASSIFICATION	 this handles hhh where there strange property name where clause the lookahead contains dot then something that isnt ident 
WITHOUT_CLASSIFICATION	 method expressions select should always considered scalar 
WITHOUT_CLASSIFICATION	 areturn return the value the field 
WITHOUT_CLASSIFICATION	 nothing only need notify the cache 
WITHOUT_CLASSIFICATION	 sort first entity name 
WITHOUT_CLASSIFICATION	 this elements then create new from element 
WITHOUT_CLASSIFICATION	 then 
WITHOUT_CLASSIFICATION	 not elementsx 
WITHOUT_CLASSIFICATION	 dialect function 
WITHOUT_CLASSIFICATION	 safe 
WITHOUT_CLASSIFICATION	 collection property function 
WITHOUT_CLASSIFICATION	 the constant ident figure out what means 
WITHOUT_CLASSIFICATION	 transformations took place handle would noninstrumented class 
WITHOUT_CLASSIFICATION	 ident class alias the from 
WITHOUT_CLASSIFICATION	 resolve identity column 
WITHOUT_CLASSIFICATION	 see the entry represents class file 
WITHOUT_CLASSIFICATION	 otherwise its literal 
WITHOUT_CLASSIFICATION	 the name entity class 
WITHOUT_CLASSIFICATION	 the class discriminator value 
WITHOUT_CLASSIFICATION	 add space before the display text 
WITHOUT_CLASSIFICATION	 find create the where clause 
WITHOUT_CLASSIFICATION	 child parentgetfirstchild 
WITHOUT_CLASSIFICATION	 set the name bulk accessor 
WITHOUT_CLASSIFICATION	 invokespecial 
WITHOUT_CLASSIFICATION	 aload load bean 
WITHOUT_CLASSIFICATION	 filter conditions need inserted before the hql where condition and the theta join node this because binds the filter parameters first then binds all the hql query parameters see 
WITHOUT_CLASSIFICATION	 checkcast cast bean 
WITHOUT_CLASSIFICATION	 put the filters node before the hql condition and theta joins 
WITHOUT_CLASSIFICATION	 astore store bean 
WITHOUT_CLASSIFICATION	 add the current fragment the filters node 
WITHOUT_CLASSIFICATION	 create new thetajoins node parent all filters 
WITHOUT_CLASSIFICATION	 aload args 
WITHOUT_CLASSIFICATION	 put the thetajoins node before the hql condition after the filters 
WITHOUT_CLASSIFICATION	 first try get the persister using the given name directly 
WITHOUT_CLASSIFICATION	 iconsti continue aastore growing stack 
WITHOUT_CLASSIFICATION	 unable locate using this name 
WITHOUT_CLASSIFICATION	 that didnt work try using the import name 
WITHOUT_CLASSIFICATION	 implicit joins use theta style where explicit joins use join after from 
WITHOUT_CLASSIFICATION	 locate the registered function the given name 
WITHOUT_CLASSIFICATION	 determine the type the first argument 
WITHOUT_CLASSIFICATION	 use the dot node emit the first column name create the column names folled the column aliases 
WITHOUT_CLASSIFICATION	 append the text the current node 
WITHOUT_CLASSIFICATION	 the node has first child recurse into the first child 
WITHOUT_CLASSIFICATION	 new 
WITHOUT_CLASSIFICATION	 there second child rhs recurse into that child 
WITHOUT_CLASSIFICATION	 aload load the raw bean 
WITHOUT_CLASSIFICATION	 invokevirtual 
WITHOUT_CLASSIFICATION	 aastore args 
WITHOUT_CLASSIFICATION	 istore store 
WITHOUT_CLASSIFICATION	 aload load the bean 
WITHOUT_CLASSIFICATION	 current stack len 
WITHOUT_CLASSIFICATION	 iterate through the aliasjoinsequence pairs and generate sql token nodes 
WITHOUT_CLASSIFICATION	 this used during sqlgenerator processing 
WITHOUT_CLASSIFICATION	 start region handling exception 
WITHOUT_CLASSIFICATION	 there from fragment and the from element explicit then add the from part 
WITHOUT_CLASSIFICATION	 frag 
WITHOUT_CLASSIFICATION	 iinc 
WITHOUT_CLASSIFICATION	 the from fragment will probably begin with remove this present 
WITHOUT_CLASSIFICATION	 aload load the raw bean 
WITHOUT_CLASSIFICATION	 select from class egperson order pname paddress 
WITHOUT_CLASSIFICATION	 oracle sqlstate code for deadlock 
WITHOUT_CLASSIFICATION	 aload load the args 
WITHOUT_CLASSIFICATION	 otherwise try use the noarg constructor 
WITHOUT_CLASSIFICATION	 iconsti 
WITHOUT_CLASSIFICATION	 eat and try next 
WITHOUT_CLASSIFICATION	 aaload 
WITHOUT_CLASSIFICATION	 checkcast 
WITHOUT_CLASSIFICATION	 default mode 
WITHOUT_CLASSIFICATION	 checkcast case reference type 
WITHOUT_CLASSIFICATION	 current stack len 
WITHOUT_CLASSIFICATION	 some point the processing went bad need make sure the connection handle gets released try cleanup the jta context much possible 
WITHOUT_CLASSIFICATION	 end region handling exception 
WITHOUT_CLASSIFICATION	 register exception table 
WITHOUT_CLASSIFICATION	 private constructor stops checkstyle from complaining 
WITHOUT_CLASSIFICATION	 reset the dotcount but not the path after reset 
WITHOUT_CLASSIFICATION	 after reset 
WITHOUT_CLASSIFICATION	 following methods dont delegate since they have little logic its clearer just implement them here 
WITHOUT_CLASSIFICATION	 dotcount 
WITHOUT_CLASSIFICATION	 local variables target obj each oldvalue 
WITHOUT_CLASSIFICATION	 astore store exception 
WITHOUT_CLASSIFICATION	 aload load exception 
WITHOUT_CLASSIFICATION	 this bean args raw bean 
WITHOUT_CLASSIFICATION	 iload 
WITHOUT_CLASSIFICATION	 the corresponding rhs 
WITHOUT_CLASSIFICATION	 invokespecial 
WITHOUT_CLASSIFICATION	 athrow 
WITHOUT_CLASSIFICATION	 warning classfile only 
WITHOUT_CLASSIFICATION	 its 
WITHOUT_CLASSIFICATION	 swallow 
WITHOUT_CLASSIFICATION	 its the property name 
WITHOUT_CLASSIFICATION	 join 
WITHOUT_CLASSIFICATION	 local variable this 
WITHOUT_CLASSIFICATION	 important 
WITHOUT_CLASSIFICATION	 association 
WITHOUT_CLASSIFICATION	 aload load this 
WITHOUT_CLASSIFICATION	 allow index function 
WITHOUT_CLASSIFICATION	 aload load callback 
WITHOUT_CLASSIFICATION	 case nonstatic field 
WITHOUT_CLASSIFICATION	 log message about potential connection leaks 
WITHOUT_CLASSIFICATION	 getfield get each field 
WITHOUT_CLASSIFICATION	 ifnonnull 
WITHOUT_CLASSIFICATION	 return each type 
WITHOUT_CLASSIFICATION	 store each type 
WITHOUT_CLASSIFICATION	 manytomany 
WITHOUT_CLASSIFICATION	 ldc name the field 
WITHOUT_CLASSIFICATION	 opening paren new foo 
WITHOUT_CLASSIFICATION	 are inside new result but not inside nested function 
WITHOUT_CLASSIFICATION	 invokeinterface invoke callbackread each type 
WITHOUT_CLASSIFICATION	 special case 
WITHOUT_CLASSIFICATION	 the name sql function 
WITHOUT_CLASSIFICATION	 this basically copypaste orderbyparser might worth refactoring 
WITHOUT_CLASSIFICATION	 select from class egperson group pname paddress 
WITHOUT_CLASSIFICATION	 return aliases not supported classic translator 
WITHOUT_CLASSIFICATION	 register collection role 
WITHOUT_CLASSIFICATION	 just the regular thing you cant find the ctor your ast must have default ctor use this 
WITHOUT_CLASSIFICATION	 the keyword used specify identity column identity column key generation supported 
WITHOUT_CLASSIFICATION	 following doesnt handle null not null but unnecessary since this would mean all rows 
WITHOUT_CLASSIFICATION	 crossjoinsaddname 
WITHOUT_CLASSIFICATION	 select clause hql 
WITHOUT_CLASSIFICATION	 invokeinterface 
WITHOUT_CLASSIFICATION	 ifnonnull label 
WITHOUT_CLASSIFICATION	 are the lhs the dot representing naked comppropref 
WITHOUT_CLASSIFICATION	 load 
WITHOUT_CLASSIFICATION	 select clause 
WITHOUT_CLASSIFICATION	 putfield 
WITHOUT_CLASSIFICATION	 there was select clause 
WITHOUT_CLASSIFICATION	 return 
WITHOUT_CLASSIFICATION	 ldc field name 
WITHOUT_CLASSIFICATION	 getfield old value the field 
WITHOUT_CLASSIFICATION	 return the concrete type the underlying type concrete type was not specified 
WITHOUT_CLASSIFICATION	 not array 
WITHOUT_CLASSIFICATION	 array reference type 
WITHOUT_CLASSIFICATION	 collectionrole 
WITHOUT_CLASSIFICATION	 boolean 
WITHOUT_CLASSIFICATION	 char 
WITHOUT_CLASSIFICATION	 short 
WITHOUT_CLASSIFICATION	 classic parser does not support bulk manipulation statements 
WITHOUT_CLASSIFICATION	 float 
WITHOUT_CLASSIFICATION	 this called when its time fully resolve path expression 
WITHOUT_CLASSIFICATION	 cant cache this stuff either perinvocation 
WITHOUT_CLASSIFICATION	 this the legacy behaviour for hql queries 
WITHOUT_CLASSIFICATION	 bad type 
WITHOUT_CLASSIFICATION	 not known 
WITHOUT_CLASSIFICATION	 boolean byte char int short 
WITHOUT_CLASSIFICATION	 need this since join condition can appear inside parens 
WITHOUT_CLASSIFICATION	 deliberately excluded 
WITHOUT_CLASSIFICATION	 mainly for oscache 
WITHOUT_CLASSIFICATION	 decrement the lock 
WITHOUT_CLASSIFICATION	 recache the updated state 
WITHOUT_CLASSIFICATION	 noop 
WITHOUT_CLASSIFICATION	 null clientlock remotely possible but will never happen practice 
WITHOUT_CLASSIFICATION	 requiring rely lock timeout the case unsuccessful update 
WITHOUT_CLASSIFICATION	 the user provided resulttransformer not the one used with select new here avoid mangling results 
WITHOUT_CLASSIFICATION	 disassemble positional parameters 
WITHOUT_CLASSIFICATION	 otherwise trimspecification andor trimcharacter have been specified need decide which options are present and the right thing should leading trimcharacters trimmed should trailing trimcharacters trimmed the trimcharacter what trimmed off the trimsource from where should trimmed 
WITHOUT_CLASSIFICATION	 this called from settingsfactory irregardless trivial simply disregard 
WITHOUT_CLASSIFICATION	 nothing subclasses may override 
WITHOUT_CLASSIFICATION	 table 
WITHOUT_CLASSIFICATION	 inside between and expression 
WITHOUT_CLASSIFICATION	 were odd even number nots encountered the join string built compound paths inside this expression flag indicating the subexpression known boolean 
WITHOUT_CLASSIFICATION	 manytomany 
WITHOUT_CLASSIFICATION	 cope with 
WITHOUT_CLASSIFICATION	 cope with continued path expression baz 
WITHOUT_CLASSIFICATION	 cope with subselect 
WITHOUT_CLASSIFICATION	 use the value newly instantiated instance the unsavedvalue 
WITHOUT_CLASSIFICATION	 close extra brackets opened 
WITHOUT_CLASSIFICATION	 take note when this boolean expression 
WITHOUT_CLASSIFICATION	 before calling interceptor for consistency with normal load 
WITHOUT_CLASSIFICATION	 noop ccs did not have such concept 
WITHOUT_CLASSIFICATION	 joinprocessor needs know the where clause fragment came from dynamic filter not can put the where clause fragment the right place the sql ast hasfiltercondition keeps track that fact 
WITHOUT_CLASSIFICATION	 process token mapping path expressions sql expressions 
WITHOUT_CLASSIFICATION	 open any extra brackets might need 
WITHOUT_CLASSIFICATION	 cope with special cases and not 
WITHOUT_CLASSIFICATION	 the next one must also 
WITHOUT_CLASSIFICATION	 add any joins 
WITHOUT_CLASSIFICATION	 get metas from hibernatemapping 
WITHOUT_CLASSIFICATION	 get metas from class 
WITHOUT_CLASSIFICATION	 path expression 
WITHOUT_CLASSIFICATION	 dbobjectname 
WITHOUT_CLASSIFICATION	 just decrement the lock dont recache dont know which transaction won 
WITHOUT_CLASSIFICATION	 mutable 
WITHOUT_CLASSIFICATION	 container for collections load when the owning entity not yet loaded for now this purely transient 
WITHOUT_CLASSIFICATION	 where 
WITHOUT_CLASSIFICATION	 polymorphism 
WITHOUT_CLASSIFICATION	 properties that have tried load and not found the database 
WITHOUT_CLASSIFICATION	 the path expression continues after 
WITHOUT_CLASSIFICATION	 careful with this 
WITHOUT_CLASSIFICATION	 the path expression ends the 
WITHOUT_CLASSIFICATION	 finish off the join 
WITHOUT_CLASSIFICATION	 notice since they are part compound identifiers 
WITHOUT_CLASSIFICATION	 cannot instantiate 
WITHOUT_CLASSIFICATION	 start looking for hql keywords 
WITHOUT_CLASSIFICATION	 inner joins can abbreviated join 
WITHOUT_CLASSIFICATION	 outer optional and ignored 
WITHOUT_CLASSIFICATION	 now anything that not hql keyword 
WITHOUT_CLASSIFICATION	 process the old hql style where aliases appear first using the class constructions 
WITHOUT_CLASSIFICATION	 treat classname 
WITHOUT_CLASSIFICATION	 treat path expression 
WITHOUT_CLASSIFICATION	 starts with path expression new style 
WITHOUT_CLASSIFICATION	 allow odmg oql style from person pcars 
WITHOUT_CLASSIFICATION	 handle quoted strings 
WITHOUT_CLASSIFICATION	 version timestamp 
WITHOUT_CLASSIFICATION	 primary key constraint 
WITHOUT_CLASSIFICATION	 this either version tag with type attribute timestamp tag 
WITHOUT_CLASSIFICATION	 object insertions updates and deletions have list semantics because they must happen the right order respect referential integrity 
WITHOUT_CLASSIFICATION	 ignore whitespace 
WITHOUT_CLASSIFICATION	 replacements 
WITHOUT_CLASSIFICATION	 handle hql collection syntax 
WITHOUT_CLASSIFICATION	 uuidhex deprecated 
WITHOUT_CLASSIFICATION	 impl 
WITHOUT_CLASSIFICATION	 hilo params 
WITHOUT_CLASSIFICATION	 sql query 
WITHOUT_CLASSIFICATION	 for ejb 
WITHOUT_CLASSIFICATION	 performance opt 
WITHOUT_CLASSIFICATION	 sql update 
WITHOUT_CLASSIFICATION	 hilo config 
WITHOUT_CLASSIFICATION	 dont allow comments these insert statements comments totally blow the oracle getgeneratedkeys support 
WITHOUT_CLASSIFICATION	 throw new associated object first disable cascade for inverse association 
WITHOUT_CLASSIFICATION	 count 
WITHOUT_CLASSIFICATION	 ahead and set the lazy here since pojoproxy can override 
WITHOUT_CLASSIFICATION	 dynamic update 
WITHOUT_CLASSIFICATION	 import 
WITHOUT_CLASSIFICATION	 batch size 
WITHOUT_CLASSIFICATION	 need dirty check collections since they can cause owner version number increment 
WITHOUT_CLASSIFICATION	 select before update 
WITHOUT_CLASSIFICATION	 optimistic lock mode 
WITHOUT_CLASSIFICATION	 first element array reserved for the actual instance are loading 
WITHOUT_CLASSIFICATION	 nothing until hit the rsult set containing the generated 
WITHOUT_CLASSIFICATION	 use the delegate resolve identifiers from element aliases 
WITHOUT_CLASSIFICATION	 loaded entity instances entitykey 
WITHOUT_CLASSIFICATION	 the given name unqualified may neen qualify 
WITHOUT_CLASSIFICATION	 the default 
WITHOUT_CLASSIFICATION	 cascadesave manytoone before the parent saved 
WITHOUT_CLASSIFICATION	 properties 
WITHOUT_CLASSIFICATION	 joined subclasses 
WITHOUT_CLASSIFICATION	 even process null collections 
WITHOUT_CLASSIFICATION	 keep the existing version number the case replicate 
WITHOUT_CLASSIFICATION	 new entitykey persister sourcegetentitymode 
WITHOUT_CLASSIFICATION	 identity map collectionentry instances the collection wrapper 
WITHOUT_CLASSIFICATION	 tablename 
WITHOUT_CLASSIFICATION	 tablespecific parameters 
WITHOUT_CLASSIFICATION	 joingetkeysettype new type lazzgetidentifier 
WITHOUT_CLASSIFICATION	 found another way ensure that all batched joined inserts have been executed 
WITHOUT_CLASSIFICATION	 identifiergenerator implementation 
WITHOUT_CLASSIFICATION	 implementation 
WITHOUT_CLASSIFICATION	 prepare and execute the insert 
WITHOUT_CLASSIFICATION	 columns 
WITHOUT_CLASSIFICATION	 everything went commit the transaction and close the obtained connection handle 
WITHOUT_CLASSIFICATION	 fetch the generated separate query 
WITHOUT_CLASSIFICATION	 just hit the last position 
WITHOUT_CLASSIFICATION	 scroll ahead 
WITHOUT_CLASSIFICATION	 scroll backward 
WITHOUT_CLASSIFICATION	 column index 
WITHOUT_CLASSIFICATION	 have not yet hit the last result 
WITHOUT_CLASSIFICATION	 state 
WITHOUT_CLASSIFICATION	 criteria impl 
WITHOUT_CLASSIFICATION	 column uniquekey 
WITHOUT_CLASSIFICATION	 this when all the properties are updateable since there certain likelihood that the information will already snapshotcached 
WITHOUT_CLASSIFICATION	 state 
WITHOUT_CLASSIFICATION	 criteria impl 
WITHOUT_CLASSIFICATION	 caches 
WITHOUT_CLASSIFICATION	 generators 
WITHOUT_CLASSIFICATION	 cache region defined the rootclass the hierarchy 
WITHOUT_CLASSIFICATION	 jndi serialization 
WITHOUT_CLASSIFICATION	 checking for named queries 
WITHOUT_CLASSIFICATION	 stats 
WITHOUT_CLASSIFICATION	 check named hql queries 
WITHOUT_CLASSIFICATION	 prevents this session from adding things cache 
WITHOUT_CLASSIFICATION	 for dynamicclass 
WITHOUT_CLASSIFICATION	 test this entity see must query 
WITHOUT_CLASSIFICATION	 note early exit 
WITHOUT_CLASSIFICATION	 for 
WITHOUT_CLASSIFICATION	 ignore this error for now 
WITHOUT_CLASSIFICATION	 must add jndi after adding hashmaps because some jndi servers use serialization 
WITHOUT_CLASSIFICATION	 look for existing collection part the persistence context 
WITHOUT_CLASSIFICATION	 make sure this defined parameter and check the incoming value type 
WITHOUT_CLASSIFICATION	 for each the defined parameters make sure its value has been set 
WITHOUT_CLASSIFICATION	 never need apply locks the sql 
WITHOUT_CLASSIFICATION	 deletes 
WITHOUT_CLASSIFICATION	 updates 
WITHOUT_CLASSIFICATION	 loading 
WITHOUT_CLASSIFICATION	 selectrange terminated declaration from 
WITHOUT_CLASSIFICATION	 for any 
WITHOUT_CLASSIFICATION	 insertable simply because that the user did not specify anything just override 
WITHOUT_CLASSIFICATION	 properties generated update can never updateable 
WITHOUT_CLASSIFICATION	 updateable only because the user did not specify anything just override 
WITHOUT_CLASSIFICATION	 the user specifically supplied updatetrue which constitutes illegal combo 
WITHOUT_CLASSIFICATION	 rolename 
WITHOUT_CLASSIFICATION	 first try load from the temp associated this 
WITHOUT_CLASSIFICATION	 otherwise immediately materialize 
WITHOUT_CLASSIFICATION	 autoflushing support stateless session 
WITHOUT_CLASSIFICATION	 fetch strategy 
WITHOUT_CLASSIFICATION	 after setting values object entitymode 
WITHOUT_CLASSIFICATION	 sort 
WITHOUT_CLASSIFICATION	 saveorupdate operations 
WITHOUT_CLASSIFICATION	 update operations 
WITHOUT_CLASSIFICATION	 lock operations 
WITHOUT_CLASSIFICATION	 persist operations 
WITHOUT_CLASSIFICATION	 persistonflush operations 
WITHOUT_CLASSIFICATION	 delete operations 
WITHOUT_CLASSIFICATION	 loadget operations 
WITHOUT_CLASSIFICATION	 refresh operations 
WITHOUT_CLASSIFICATION	 unsorted natural comparatorclassname 
WITHOUT_CLASSIFICATION	 replicate operations 
WITHOUT_CLASSIFICATION	 set second pass 
WITHOUT_CLASSIFICATION	 not autoflush while outside transaction 
WITHOUT_CLASSIFICATION	 this internal error some sort 
WITHOUT_CLASSIFICATION	 not return proxy this option indicates are initializing proxy 
WITHOUT_CLASSIFICATION	 for any will have use reflection 
WITHOUT_CLASSIFICATION	 only collections belonging deleted entities are allowed dereferenced the case orphan delete 
WITHOUT_CLASSIFICATION	 was previously unreferenced need flush order get its state into the database order execute query 
WITHOUT_CLASSIFICATION	 not for internal use 
WITHOUT_CLASSIFICATION	 otherwise only need flush there are inmemory changes the queried tables 
WITHOUT_CLASSIFICATION	 initialized see the underlying instance contained since need account for the fact that might have been evicted 
WITHOUT_CLASSIFICATION	 decode row selection 
WITHOUT_CLASSIFICATION	 basically just adapted copy findcriteriaimpl 
WITHOUT_CLASSIFICATION	 need writeobject this since interceptor user defined 
WITHOUT_CLASSIFICATION	 the oldtime standby 
WITHOUT_CLASSIFICATION	 parameter bind values 
WITHOUT_CLASSIFICATION	 parameter handling code 
WITHOUT_CLASSIFICATION	 execution methods 
WITHOUT_CLASSIFICATION	 note special case onetoone constrainedfalse cannot proxied default join and nonlazy 
WITHOUT_CLASSIFICATION	 use old defaults outerjoin specified 
WITHOUT_CLASSIFICATION	 have cglib enhanced entity 
WITHOUT_CLASSIFICATION	 have javassist enhanced entity 
WITHOUT_CLASSIFICATION	 fieldinterceptor impl 
WITHOUT_CLASSIFICATION	 subclass accesses 
WITHOUT_CLASSIFICATION	 fieldhandler impl 
WITHOUT_CLASSIFICATION	 should not need grow beyond the size the total number columns the 
WITHOUT_CLASSIFICATION	 should probably noop commitrollback here least jta scenarios 
WITHOUT_CLASSIFICATION	 various expectation instances 
WITHOUT_CLASSIFICATION	 explicitly perform checking 
WITHOUT_CLASSIFICATION	 used from testsuite 
WITHOUT_CLASSIFICATION	 generator 
WITHOUT_CLASSIFICATION	 register synch statsconnect 
WITHOUT_CLASSIFICATION	 calls executebatch 
WITHOUT_CLASSIFICATION	 big deal 
WITHOUT_CLASSIFICATION	 big deal 
WITHOUT_CLASSIFICATION	 see explanation above 
WITHOUT_CLASSIFICATION	 are the process releasing sense checking for aggressiverelease possibility 
WITHOUT_CLASSIFICATION	 early exit 
WITHOUT_CLASSIFICATION	 resultset impl overridden 
WITHOUT_CLASSIFICATION	 resultset impl delegated 
WITHOUT_CLASSIFICATION	 unsavedvalue 
WITHOUT_CLASSIFICATION	 version unsavedvalue 
WITHOUT_CLASSIFICATION	 not necessarily unique property reference 
WITHOUT_CLASSIFICATION	 bind the where 
WITHOUT_CLASSIFICATION	 refer comment 
WITHOUT_CLASSIFICATION	 implementation 
WITHOUT_CLASSIFICATION	 note success false because dont know the outcome the transaction 
WITHOUT_CLASSIFICATION	 bind the orderby 
WITHOUT_CLASSIFICATION	 already have callback registered either local transaction has accepted callback responsibilities have previously registered transaction synch 
WITHOUT_CLASSIFICATION	 bind the filters 
WITHOUT_CLASSIFICATION	 overriding inherited meta attribute hbx hbx 
WITHOUT_CLASSIFICATION	 first iterate over all elements capable defining extends attribute collecting all found extends references they cannot resolved against the already processed mappings 
WITHOUT_CLASSIFICATION	 sessionfactory name 
WITHOUT_CLASSIFICATION	 jdbc and connection settings 
WITHOUT_CLASSIFICATION	 interrogate jdbc metadata 
WITHOUT_CLASSIFICATION	 user supplied jdbc connections 
WITHOUT_CLASSIFICATION	 transaction settings 
WITHOUT_CLASSIFICATION	 sql generation settings 
WITHOUT_CLASSIFICATION	 query parser settings 
WITHOUT_CLASSIFICATION	 secondlevel query cache 
WITHOUT_CLASSIFICATION	 sql exception converter 
WITHOUT_CLASSIFICATION	 statistics and logging 
WITHOUT_CLASSIFICATION	 postinitialize will called after initialization 
WITHOUT_CLASSIFICATION	 cannot handle single quotes 
WITHOUT_CLASSIFICATION	 schema export 
WITHOUT_CLASSIFICATION	 todo for private static final logger log this the legacy logging category 
WITHOUT_CLASSIFICATION	 dotted and not loadcollection nor returnjoin regular property 
WITHOUT_CLASSIFICATION	 dont even bother trying read further 
WITHOUT_CLASSIFICATION	 private todo hhh and hhh private bytecodeprovider bytecodeprovider 
WITHOUT_CLASSIFICATION	 public getters 
WITHOUT_CLASSIFICATION	 generated properties can never insertable 
WITHOUT_CLASSIFICATION	 package protected setters 
WITHOUT_CLASSIFICATION	 public bytecodeprovider getbytecodeprovider return bytecodeprovider void bytecodeprovider bytecodeprovider 
WITHOUT_CLASSIFICATION	 using local since the inheritedmetas this point not the correct map since always the empty map 
WITHOUT_CLASSIFICATION	 protected list extendsqueue 
WITHOUT_CLASSIFICATION	 extendsqueue new arraylist 
WITHOUT_CLASSIFICATION	 new 
WITHOUT_CLASSIFICATION	 doc null then for whatever reason the cached file cannot used 
WITHOUT_CLASSIFICATION	 position cursor the last row 
WITHOUT_CLASSIFICATION	 sequentially read the result set reverse until recognize change the key value that point are pointed the last physical sequential row for the logical row which are interested processing 
WITHOUT_CLASSIFICATION	 read backwards until read past the first physical sequential row with the key are interested loading 
WITHOUT_CLASSIFICATION	 finally read ahead one row position result set cursor the first physical row are interested loading 
WITHOUT_CLASSIFICATION	 this method may called many times 
WITHOUT_CLASSIFICATION	 force the proxy resolve itself 
WITHOUT_CLASSIFICATION	 this equivalent the old behavior 
WITHOUT_CLASSIFICATION	 null owner will retrieved from session 
WITHOUT_CLASSIFICATION	 iterator iterator 
WITHOUT_CLASSIFICATION	 iterator iter 
WITHOUT_CLASSIFICATION	 found 
WITHOUT_CLASSIFICATION	 final string querystring 
WITHOUT_CLASSIFICATION	 private final list extendsqueue 
WITHOUT_CLASSIFICATION	 string string 
WITHOUT_CLASSIFICATION	 set false fix hhh 
WITHOUT_CLASSIFICATION	 orphan delete not supported for entitymodedomj 
WITHOUT_CLASSIFICATION	 element 
WITHOUT_CLASSIFICATION	 can reuse for each row 
WITHOUT_CLASSIFICATION	 cant reuse this case 
WITHOUT_CLASSIFICATION	 needed for soap libraries etc 
WITHOUT_CLASSIFICATION	 any earlier proxy takes precedence 
WITHOUT_CLASSIFICATION	 first need suspend any current jta transaction and obtain jdbc connection 
WITHOUT_CLASSIFICATION	 only returned one entity query key more efficient 
WITHOUT_CLASSIFICATION	 the element has been removed from the set 
WITHOUT_CLASSIFICATION	 the element has changed 
WITHOUT_CLASSIFICATION	 careful these methods not initialize the collection 
WITHOUT_CLASSIFICATION	 needed that remove this collection from the secondlevel cache 
WITHOUT_CLASSIFICATION	 override some subclasses 
WITHOUT_CLASSIFICATION	 override some subclasses 
WITHOUT_CLASSIFICATION	 this bit after setting initialized true will recurse 
WITHOUT_CLASSIFICATION	 create the collection holding the orphans 
WITHOUT_CLASSIFICATION	 collect entityidentifiers the current elements add them into hashset for fast access 
WITHOUT_CLASSIFICATION	 iterate over the old list 
WITHOUT_CLASSIFICATION	 arraynull templistgeti 
WITHOUT_CLASSIFICATION	 manytomany decrement currentdepth here allow join across the association table without exceeding maxfetchdepth the currentdepth bit 
WITHOUT_CLASSIFICATION	 write doesnt 
WITHOUT_CLASSIFICATION	 this the regression style determination which matches the logic the classic translator 
WITHOUT_CLASSIFICATION	 handle empty collection 
WITHOUT_CLASSIFICATION	 handle empty collections 
WITHOUT_CLASSIFICATION	 else this not collection initializer and empty collections will detected looking for the owners identifier the result set 
WITHOUT_CLASSIFICATION	 finally what its all about 
WITHOUT_CLASSIFICATION	 here not bother with the discriminator 
WITHOUT_CLASSIFICATION	 validate instances validatable 
WITHOUT_CLASSIFICATION	 null version means the object the process being loaded somewhere else the resultset 
WITHOUT_CLASSIFICATION	 problematic for keymanytoone 
WITHOUT_CLASSIFICATION	 use the passed 
WITHOUT_CLASSIFICATION	 the property collection 
WITHOUT_CLASSIFICATION	 anyway here implement set semantics for onetomany bag 
WITHOUT_CLASSIFICATION	 search for note that this code incorrect for other than onetomany 
WITHOUT_CLASSIFICATION	 composite key 
WITHOUT_CLASSIFICATION	 batch use foo and bar 
WITHOUT_CLASSIFICATION	 must collection fetch 
WITHOUT_CLASSIFICATION	 needed later for manytomanyfilter application 
WITHOUT_CLASSIFICATION	 collection wrappers the collectionkey keycollectionkey 
WITHOUT_CLASSIFICATION	 might still need apply collection ordering based manytomany defined orderby 
WITHOUT_CLASSIFICATION	 belong other persister belong other persister 
WITHOUT_CLASSIFICATION	 found 
WITHOUT_CLASSIFICATION	 can use inner join for the manytomany 
WITHOUT_CLASSIFICATION	 disable join back this same association 
WITHOUT_CLASSIFICATION	 note unlike all other loaders this one not multithreaded cacheable 
WITHOUT_CLASSIFICATION	 alias may null early exit 
WITHOUT_CLASSIFICATION	 compound path 
WITHOUT_CLASSIFICATION	 its the root criteria are done 
WITHOUT_CLASSIFICATION	 otherwise recurse 
WITHOUT_CLASSIFICATION	 the criteria instance 
WITHOUT_CLASSIFICATION	 the entity name 
WITHOUT_CLASSIFICATION	 not found inner query try the outer query 
WITHOUT_CLASSIFICATION	 refers alias projection 
WITHOUT_CLASSIFICATION	 should never happen think 
WITHOUT_CLASSIFICATION	 convert the string value into the proper type 
WITHOUT_CLASSIFICATION	 and the qualifier not the alias this criteria check see belong some criteria other than the one that created 
WITHOUT_CLASSIFICATION	 otherwise this ordinary value 
WITHOUT_CLASSIFICATION	 currently not cachable autodiscover types effect select 
WITHOUT_CLASSIFICATION	 list operations 
WITHOUT_CLASSIFICATION	 private final string sqlaliases private final string sqlaliassuffixes 
WITHOUT_CLASSIFICATION	 this only needed afaict for resulttransformer processing 
WITHOUT_CLASSIFICATION	 replace with corresponding column aliases 
WITHOUT_CLASSIFICATION	 additional open braces found the string append the rest the string its entirty and quit this loop 
WITHOUT_CLASSIFICATION	 apend everything until the next encountered open brace 
WITHOUT_CLASSIFICATION	 pad with nulls from the current last element the new index 
WITHOUT_CLASSIFICATION	 simple table alias foo 
WITHOUT_CLASSIFICATION	 passing through anything not know support jdbc escape sequences 
WITHOUT_CLASSIFICATION	 the current alias referencing the collection eagerly fetched 
WITHOUT_CLASSIFICATION	 property reference foobar 
WITHOUT_CLASSIFICATION	 private final list scalartypes new arraylist private final list scalarcolumnaliases new arraylist 
WITHOUT_CLASSIFICATION	 now process the returns 
WITHOUT_CLASSIFICATION	 already been processed 
WITHOUT_CLASSIFICATION	 make sure the owner alias known 
WITHOUT_CLASSIFICATION	 scalartypesadd typereturngettype 
WITHOUT_CLASSIFICATION	 this returns alias has not been processed yet further processing this return 
WITHOUT_CLASSIFICATION	 owneralias 
WITHOUT_CLASSIFICATION	 from map 
WITHOUT_CLASSIFICATION	 from sortedmap 
WITHOUT_CLASSIFICATION	 cannot instantiated 
WITHOUT_CLASSIFICATION	 inject the data 
WITHOUT_CLASSIFICATION	 default pool size 
WITHOUT_CLASSIFICATION	 debug level enabled then log the password otherwise mask 
WITHOUT_CLASSIFICATION	 register cleanup synch 
WITHOUT_CLASSIFICATION	 wrap the session the proxy 
WITHOUT_CLASSIFICATION	 then bind 
WITHOUT_CLASSIFICATION	 limit the methods available transaction active 
WITHOUT_CLASSIFICATION	 allow these deprecated methods pass through 
WITHOUT_CLASSIFICATION	 serialization 
WITHOUT_CLASSIFICATION	 add temp entry that the next step circularreference safe only needed because some types dont take proper advantage twophaseload esp components 
WITHOUT_CLASSIFICATION	 this the second pass through merge here limit the replacement associations types value types were already replaced during the first pass 
WITHOUT_CLASSIFICATION	 handle collectionfiter compilation important note this modifying the input hql tree not the output tree 
WITHOUT_CLASSIFICATION	 private string propertyname 
WITHOUT_CLASSIFICATION	 string stringhelperqualify collection cpgetkeycolumnnames 
WITHOUT_CLASSIFICATION	 collection where 
WITHOUT_CLASSIFICATION	 unsupported 
WITHOUT_CLASSIFICATION	 not composite key use foo for batching batch and not composite key use foo 
WITHOUT_CLASSIFICATION	 currently only the hibernatesupplied dbtimestamptype supported here 
WITHOUT_CLASSIFICATION	 implicit polymorphism not supported would need union 
WITHOUT_CLASSIFICATION	 pull off the last 
WITHOUT_CLASSIFICATION	 always insert and let fail constraint violation 
WITHOUT_CLASSIFICATION	 default naturalids are immutable constant 
WITHOUT_CLASSIFICATION	 have the form trimfrom trimsource this functionally equivalent trimtrimsource 
WITHOUT_CLASSIFICATION	 astore store the raw bean 
WITHOUT_CLASSIFICATION	 not sure this even valid subtree but was itd represent two unrelated table references 
WITHOUT_CLASSIFICATION	 grrr for differentiation mysql storage engines 
WITHOUT_CLASSIFICATION	 string keycols 
WITHOUT_CLASSIFICATION	 oracle did add support for ansi case statements 
WITHOUT_CLASSIFICATION	 refresh does not pass entityname 
WITHOUT_CLASSIFICATION	 informix doesnt have bit type 
WITHOUT_CLASSIFICATION	 not 
WITHOUT_CLASSIFICATION	 strip tableowner because informix always returns constraint names 
WITHOUT_CLASSIFICATION	 build the map standard ansi sql aggregation functions 
WITHOUT_CLASSIFICATION	 pre behavior 
WITHOUT_CLASSIFICATION	 finally use the sqltype hibernate types did not find match 
WITHOUT_CLASSIFICATION	 because numeric can anything 
WITHOUT_CLASSIFICATION	 constructors and factory methods 
WITHOUT_CLASSIFICATION	 standard sql functions can overridden subclasses 
WITHOUT_CLASSIFICATION	 map ansi extract override subclasses 
WITHOUT_CLASSIFICATION	 database type mapping support 
WITHOUT_CLASSIFICATION	 hibernate type mapping support 
WITHOUT_CLASSIFICATION	 native identifier generatiion 
WITHOUT_CLASSIFICATION	 limitoffset support 
WITHOUT_CLASSIFICATION	 default report support 
WITHOUT_CLASSIFICATION	 sqlresulttypes 
WITHOUT_CLASSIFICATION	 default report support for nowait lock semantics 
WITHOUT_CLASSIFICATION	 current timestamp support 
WITHOUT_CLASSIFICATION	 identifier quoting support 
WITHOUT_CLASSIFICATION	 default 
WITHOUT_CLASSIFICATION	 this now handled earlier this method 
WITHOUT_CLASSIFICATION	 loader implementation 
WITHOUT_CLASSIFICATION	 loader overrides 
WITHOUT_CLASSIFICATION	 not isnull isnotnull 
WITHOUT_CLASSIFICATION	 here assume sqlserver using snapshot isolation which does not have this problem 
WITHOUT_CLASSIFICATION	 query translator methods 
WITHOUT_CLASSIFICATION	 oracle and previous define only date type which used represent all aspects datetime 
WITHOUT_CLASSIFICATION	 cascade 
WITHOUT_CLASSIFICATION	 implementation private methods 
WITHOUT_CLASSIFICATION	 trim off the 
WITHOUT_CLASSIFICATION	 check violation 
WITHOUT_CLASSIFICATION	 unique violation 
WITHOUT_CLASSIFICATION	 foreign key violation 
WITHOUT_CLASSIFICATION	 deduplicate unique constraints sharing the same columns this needed hibernate annotations since creates automagically unique constraints for the user 
WITHOUT_CLASSIFICATION	 support dialects that have their own identity data type 
WITHOUT_CLASSIFICATION	 not null violation 
WITHOUT_CLASSIFICATION	 all other 
WITHOUT_CLASSIFICATION	 register the type the out param postgresql uses typesother 
WITHOUT_CLASSIFICATION	 seems have spotty lob suppport 
WITHOUT_CLASSIFICATION	 hhh 
WITHOUT_CLASSIFICATION	 ignore probably not the classpath 
WITHOUT_CLASSIFICATION	 numeric functions 
WITHOUT_CLASSIFICATION	 used also for generation names 
WITHOUT_CLASSIFICATION	 usually useless 
WITHOUT_CLASSIFICATION	 not add unique constraint not supporting unique and nullable columns 
WITHOUT_CLASSIFICATION	 for backward compatibility disable this 
WITHOUT_CLASSIFICATION	 may final may final may final 
WITHOUT_CLASSIFICATION	 may final 
WITHOUT_CLASSIFICATION	 may final 
WITHOUT_CLASSIFICATION	 custom sql 
WITHOUT_CLASSIFICATION	 primary key constraint 
WITHOUT_CLASSIFICATION	 ignore 
WITHOUT_CLASSIFICATION	 time and date functions 
WITHOUT_CLASSIFICATION	 system functions 
WITHOUT_CLASSIFICATION	 not null implicit 
WITHOUT_CLASSIFICATION	 display the dialect version 
WITHOUT_CLASSIFICATION	 nothing stateful session 
WITHOUT_CLASSIFICATION	 the rdms concat function only supports parameters 
WITHOUT_CLASSIFICATION	 flat recursive algorithm 
WITHOUT_CLASSIFICATION	 identifier mapper getkey will included the and checked later needs excluded 
WITHOUT_CLASSIFICATION	 dialect method overrides 
WITHOUT_CLASSIFICATION	 original dialectjava returns for update 
WITHOUT_CLASSIFICATION	 pass the column name generated almost always has single column 
WITHOUT_CLASSIFICATION	 needed satisfy keyvalue 
WITHOUT_CLASSIFICATION	 verify the state this new method hibernate dialectjava 
WITHOUT_CLASSIFICATION	 origial dialectjava returns true 
WITHOUT_CLASSIFICATION	 index should last column listed 
WITHOUT_CLASSIFICATION	 sequence methods start the rdms dialect needs these 
WITHOUT_CLASSIFICATION	 methods make possible use the native generator 
WITHOUT_CLASSIFICATION	 formula index use the element columns the 
WITHOUT_CLASSIFICATION	 dont create unique key cos some databases dont like nullable columns 
WITHOUT_CLASSIFICATION	 sequence methods end 
WITHOUT_CLASSIFICATION	 used with drop table delete all records the table 
WITHOUT_CLASSIFICATION	 foreign key element for onetomany 
WITHOUT_CLASSIFICATION	 todo could just return all false 
WITHOUT_CLASSIFICATION	 the case foreign key something other than the handled 
WITHOUT_CLASSIFICATION	 the object persistent 
WITHOUT_CLASSIFICATION	 rdms supports the union all clause 
WITHOUT_CLASSIFICATION	 multiparam dialect functions 
WITHOUT_CLASSIFICATION	 function templates 
WITHOUT_CLASSIFICATION	 not null implicit 
WITHOUT_CLASSIFICATION	 this assumes schema support which present and later 
WITHOUT_CLASSIFICATION	 hsqldb only supports readuncommitted transaction isolation 
WITHOUT_CLASSIFICATION	 the entity associated with the session check its status 
WITHOUT_CLASSIFICATION	 timesten has blobclob support but these types may suitable for some applications the length limited million bytes 
WITHOUT_CLASSIFICATION	 new methods dialect 
WITHOUT_CLASSIFICATION	 public boolean return false 
WITHOUT_CLASSIFICATION	 timesten has known variation select for update syntax 
WITHOUT_CLASSIFICATION	 iterate entries ordered capacity find first fit 
WITHOUT_CLASSIFICATION	 add new ordered map 
WITHOUT_CLASSIFICATION	 expected type intrinsic here 
WITHOUT_CLASSIFICATION	 return 
WITHOUT_CLASSIFICATION	 return propertyname 
WITHOUT_CLASSIFICATION	 return 
WITHOUT_CLASSIFICATION	 indexisformula 
WITHOUT_CLASSIFICATION	 return isonetomany 
WITHOUT_CLASSIFICATION	 instanceof associationtype 
WITHOUT_CLASSIFICATION	 need determine the best way know that two joinables represent single manytomany 
WITHOUT_CLASSIFICATION	 strip leading 
WITHOUT_CLASSIFICATION	 public boolean issubselectloadable 
WITHOUT_CLASSIFICATION	 columns 
WITHOUT_CLASSIFICATION	 sql statements 
WITHOUT_CLASSIFICATION	 extra information about the element type 
WITHOUT_CLASSIFICATION	 types 
WITHOUT_CLASSIFICATION	 custom sql 
WITHOUT_CLASSIFICATION	 private final string 
WITHOUT_CLASSIFICATION	 return select currenttimestamp from rdbdatabase 
WITHOUT_CLASSIFICATION	 dynamic filters specifically for manytomany inside the collection 
WITHOUT_CLASSIFICATION	 dynamic filters for the collection 
WITHOUT_CLASSIFICATION	 registercolumntype data types 
WITHOUT_CLASSIFICATION	 ibid for currenttime and currentdate 
WITHOUT_CLASSIFICATION	 weve been blocking for the mutex perhaps another thread has already reestablished the root case the node was reestablised via replication confirm its marked resident status which doesnt replicate 
WITHOUT_CLASSIFICATION	 tell hibernate use getbytes instead getbinarystream 
WITHOUT_CLASSIFICATION	 batch statements 
WITHOUT_CLASSIFICATION	 element 
WITHOUT_CLASSIFICATION	 might want special case for this very common for money types and here converted 
WITHOUT_CLASSIFICATION	 pointbase bit 
WITHOUT_CLASSIFICATION	 pointbase tinyint 
WITHOUT_CLASSIFICATION	 nativesql collect element column and autoaliases 
WITHOUT_CLASSIFICATION	 index and row select 
WITHOUT_CLASSIFICATION	 sql server least through does not support defining cascade delete constraints which can circel back the mutating table 
WITHOUT_CLASSIFICATION	 nativesql collect index column and autoaliases 
WITHOUT_CLASSIFICATION	 registercolumntype typesclob mediumtext registercolumntype typesclob text 
WITHOUT_CLASSIFICATION	 registercolumntype typesvarchar mediumtext registercolumntype typesvarchar text 
WITHOUT_CLASSIFICATION	 generate the sql 
WITHOUT_CLASSIFICATION	 not all classpersisters implement propertymapping 
WITHOUT_CLASSIFICATION	 handle any filters applied this collection for manytomany 
WITHOUT_CLASSIFICATION	 there userspecified loader return that todo filters 
WITHOUT_CLASSIFICATION	 take care any entities that might have been evicted 
WITHOUT_CLASSIFICATION	 run subquery loader 
WITHOUT_CLASSIFICATION	 cant change the running cache just check the cache has and were with that 
WITHOUT_CLASSIFICATION	 sybase bit type does not support null values 
WITHOUT_CLASSIFICATION	 could register the session against the transaction even though not started but wed have guarentee ever getting the map entries cleaned aside from spawning threads 
WITHOUT_CLASSIFICATION	 needed arrays 
WITHOUT_CLASSIFICATION	 this assumes you will want ignore any update counts 
WITHOUT_CLASSIFICATION	 todo something with formulas 
WITHOUT_CLASSIFICATION	 assertion 
WITHOUT_CLASSIFICATION	 remove all the old entries 
WITHOUT_CLASSIFICATION	 create all the new entries 
WITHOUT_CLASSIFICATION	 delete all the deleted entries 
WITHOUT_CLASSIFICATION	 insert all the new entries 
